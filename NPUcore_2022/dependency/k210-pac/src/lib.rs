#![doc = "Peripheral access API for K210 microcontrollers (generated using svd2rust v0.17.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.17.0/svd2rust/#peripheral-api"]
#![deny(const_err)]
#![deny(dead_code)]
#![deny(improper_ctypes)]
#![deny(missing_docs)]
#![deny(no_mangle_generic_items)]
#![deny(non_shorthand_field_patterns)]
#![deny(overflowing_literals)]
#![deny(path_statements)]
#![deny(patterns_in_fns_without_body)]
#![deny(private_in_public)]
#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
#![deny(unused_comparisons)]
#![deny(unused_parens)]
#![deny(while_true)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
extern crate bare_metal;
extern crate riscv;
#[cfg(feature = "rt")]
extern crate riscv_rt;
extern crate vcell;
use core::marker::PhantomData;
use core::ops::Deref;
#[doc(hidden)]
pub mod interrupt {
    #[doc = r"Enumeration of all the interrupts"]
    #[derive(Copy, Clone, Debug)]
    #[repr(u8)]
    pub enum Interrupt {
        #[doc = "1 - SPI0"]
        SPI0 = 1,
        #[doc = "2 - SPI1"]
        SPI1 = 2,
        #[doc = "3 - SPI_SLAVE"]
        SPI_SLAVE = 3,
        #[doc = "4 - SPI3"]
        SPI3 = 4,
        #[doc = "5 - I2S0"]
        I2S0 = 5,
        #[doc = "6 - I2S1"]
        I2S1 = 6,
        #[doc = "7 - I2S2"]
        I2S2 = 7,
        #[doc = "8 - I2C0"]
        I2C0 = 8,
        #[doc = "9 - I2C1"]
        I2C1 = 9,
        #[doc = "10 - I2C2"]
        I2C2 = 10,
        #[doc = "11 - UART1"]
        UART1 = 11,
        #[doc = "12 - UART2"]
        UART2 = 12,
        #[doc = "13 - UART3"]
        UART3 = 13,
        #[doc = "14 - TIMER0 channel 0 or 1 interrupt"]
        TIMER0A = 14,
        #[doc = "15 - TIMER0 channel 2 or 3 interrupt"]
        TIMER0B = 15,
        #[doc = "16 - TIMER1 channel 0 or 1 interrupt"]
        TIMER1A = 16,
        #[doc = "17 - TIMER1 channel 2 or 3 interrupt"]
        TIMER1B = 17,
        #[doc = "18 - TIMER2 channel 0 or 1 interrupt"]
        TIMER2A = 18,
        #[doc = "19 - TIMER2 channel 2 or 3 interrupt"]
        TIMER2B = 19,
        #[doc = "20 - RTC"]
        RTC = 20,
        #[doc = "21 - WDT0"]
        WDT0 = 21,
        #[doc = "22 - WDT1"]
        WDT1 = 22,
        #[doc = "23 - APB_GPIO"]
        APB_GPIO = 23,
        #[doc = "24 - DVP"]
        DVP = 24,
        #[doc = "25 - KPU"]
        KPU = 25,
        #[doc = "26 - FFT"]
        FFT = 26,
        #[doc = "27 - DMA0"]
        DMA0 = 27,
        #[doc = "28 - DMA1"]
        DMA1 = 28,
        #[doc = "29 - DMA2"]
        DMA2 = 29,
        #[doc = "30 - DMA3"]
        DMA3 = 30,
        #[doc = "31 - DMA4"]
        DMA4 = 31,
        #[doc = "32 - DMA5"]
        DMA5 = 32,
        #[doc = "33 - UARTHS"]
        UARTHS = 33,
        #[doc = "34 - GPIOHS0"]
        GPIOHS0 = 34,
        #[doc = "35 - GPIOHS1"]
        GPIOHS1 = 35,
        #[doc = "36 - GPIOHS2"]
        GPIOHS2 = 36,
        #[doc = "37 - GPIOHS3"]
        GPIOHS3 = 37,
        #[doc = "38 - GPIOHS4"]
        GPIOHS4 = 38,
        #[doc = "39 - GPIOHS5"]
        GPIOHS5 = 39,
        #[doc = "40 - GPIOHS6"]
        GPIOHS6 = 40,
        #[doc = "41 - GPIOHS7"]
        GPIOHS7 = 41,
        #[doc = "42 - GPIOHS8"]
        GPIOHS8 = 42,
        #[doc = "43 - GPIOHS9"]
        GPIOHS9 = 43,
        #[doc = "44 - GPIOHS10"]
        GPIOHS10 = 44,
        #[doc = "45 - GPIOHS11"]
        GPIOHS11 = 45,
        #[doc = "46 - GPIOHS12"]
        GPIOHS12 = 46,
        #[doc = "47 - GPIOHS13"]
        GPIOHS13 = 47,
        #[doc = "48 - GPIOHS14"]
        GPIOHS14 = 48,
        #[doc = "49 - GPIOHS15"]
        GPIOHS15 = 49,
        #[doc = "50 - GPIOHS16"]
        GPIOHS16 = 50,
        #[doc = "51 - GPIOHS17"]
        GPIOHS17 = 51,
        #[doc = "52 - GPIOHS18"]
        GPIOHS18 = 52,
        #[doc = "53 - GPIOHS19"]
        GPIOHS19 = 53,
        #[doc = "54 - GPIOHS20"]
        GPIOHS20 = 54,
        #[doc = "55 - GPIOHS21"]
        GPIOHS21 = 55,
        #[doc = "56 - GPIOHS22"]
        GPIOHS22 = 56,
        #[doc = "57 - GPIOHS23"]
        GPIOHS23 = 57,
        #[doc = "58 - GPIOHS24"]
        GPIOHS24 = 58,
        #[doc = "59 - GPIOHS25"]
        GPIOHS25 = 59,
        #[doc = "60 - GPIOHS26"]
        GPIOHS26 = 60,
        #[doc = "61 - GPIOHS27"]
        GPIOHS27 = 61,
        #[doc = "62 - GPIOHS28"]
        GPIOHS28 = 62,
        #[doc = "63 - GPIOHS29"]
        GPIOHS29 = 63,
        #[doc = "64 - GPIOHS30"]
        GPIOHS30 = 64,
        #[doc = "65 - GPIOHS31"]
        GPIOHS31 = 65,
    }
    unsafe impl bare_metal::Nr for Interrupt {
        #[inline(always)]
        fn nr(&self) -> u8 {
            *self as u8
        }
    }
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl Interrupt {
        #[inline]
        pub fn try_from(value: u8) -> Result<Self, TryFromInterruptError> {
            match value {
                1 => Ok(Interrupt::SPI0),
                2 => Ok(Interrupt::SPI1),
                3 => Ok(Interrupt::SPI_SLAVE),
                4 => Ok(Interrupt::SPI3),
                5 => Ok(Interrupt::I2S0),
                6 => Ok(Interrupt::I2S1),
                7 => Ok(Interrupt::I2S2),
                8 => Ok(Interrupt::I2C0),
                9 => Ok(Interrupt::I2C1),
                10 => Ok(Interrupt::I2C2),
                11 => Ok(Interrupt::UART1),
                12 => Ok(Interrupt::UART2),
                13 => Ok(Interrupt::UART3),
                14 => Ok(Interrupt::TIMER0A),
                15 => Ok(Interrupt::TIMER0B),
                16 => Ok(Interrupt::TIMER1A),
                17 => Ok(Interrupt::TIMER1B),
                18 => Ok(Interrupt::TIMER2A),
                19 => Ok(Interrupt::TIMER2B),
                20 => Ok(Interrupt::RTC),
                21 => Ok(Interrupt::WDT0),
                22 => Ok(Interrupt::WDT1),
                23 => Ok(Interrupt::APB_GPIO),
                24 => Ok(Interrupt::DVP),
                25 => Ok(Interrupt::KPU),
                26 => Ok(Interrupt::FFT),
                27 => Ok(Interrupt::DMA0),
                28 => Ok(Interrupt::DMA1),
                29 => Ok(Interrupt::DMA2),
                30 => Ok(Interrupt::DMA3),
                31 => Ok(Interrupt::DMA4),
                32 => Ok(Interrupt::DMA5),
                33 => Ok(Interrupt::UARTHS),
                34 => Ok(Interrupt::GPIOHS0),
                35 => Ok(Interrupt::GPIOHS1),
                36 => Ok(Interrupt::GPIOHS2),
                37 => Ok(Interrupt::GPIOHS3),
                38 => Ok(Interrupt::GPIOHS4),
                39 => Ok(Interrupt::GPIOHS5),
                40 => Ok(Interrupt::GPIOHS6),
                41 => Ok(Interrupt::GPIOHS7),
                42 => Ok(Interrupt::GPIOHS8),
                43 => Ok(Interrupt::GPIOHS9),
                44 => Ok(Interrupt::GPIOHS10),
                45 => Ok(Interrupt::GPIOHS11),
                46 => Ok(Interrupt::GPIOHS12),
                47 => Ok(Interrupt::GPIOHS13),
                48 => Ok(Interrupt::GPIOHS14),
                49 => Ok(Interrupt::GPIOHS15),
                50 => Ok(Interrupt::GPIOHS16),
                51 => Ok(Interrupt::GPIOHS17),
                52 => Ok(Interrupt::GPIOHS18),
                53 => Ok(Interrupt::GPIOHS19),
                54 => Ok(Interrupt::GPIOHS20),
                55 => Ok(Interrupt::GPIOHS21),
                56 => Ok(Interrupt::GPIOHS22),
                57 => Ok(Interrupt::GPIOHS23),
                58 => Ok(Interrupt::GPIOHS24),
                59 => Ok(Interrupt::GPIOHS25),
                60 => Ok(Interrupt::GPIOHS26),
                61 => Ok(Interrupt::GPIOHS27),
                62 => Ok(Interrupt::GPIOHS28),
                63 => Ok(Interrupt::GPIOHS29),
                64 => Ok(Interrupt::GPIOHS30),
                65 => Ok(Interrupt::GPIOHS31),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    #[doc = r" Assigns a handler to an interrupt"]
    #[doc = r""]
    #[doc = r" This macro takes two arguments: the name of an interrupt and the path to the"]
    #[doc = r" function that will be used as the handler of that interrupt. That function"]
    #[doc = r" must have signature `fn()`."]
    #[doc = r""]
    #[doc = r" Optionally, a third argument may be used to declare interrupt local data."]
    #[doc = r" The handler will have exclusive access to these *local* variables on each"]
    #[doc = r" invocation. If the third argument is used then the signature of the handler"]
    #[doc = r" function must be `fn(&mut $NAME::Locals)` where `$NAME` is the first argument"]
    #[doc = r" passed to the macro."]
    #[doc = r""]
    #[doc = r" # Example"]
    #[doc = r""]
    #[doc = r" ``` ignore"]
    #[doc = r" interrupt!(TIM2, periodic);"]
    #[doc = r""]
    #[doc = r" fn periodic() {"]
    #[doc = r#"     print!(".");"#]
    #[doc = r" }"]
    #[doc = r""]
    #[doc = r" interrupt!(TIM3, tick, locals: {"]
    #[doc = r"     tick: bool = false;"]
    #[doc = r" });"]
    #[doc = r""]
    #[doc = r" fn tick(locals: &mut TIM3::Locals) {"]
    #[doc = r"     locals.tick = !locals.tick;"]
    #[doc = r""]
    #[doc = r"     if locals.tick {"]
    #[doc = r#"         println!("Tick");"#]
    #[doc = r"     } else {"]
    #[doc = r#"         println!("Tock");"#]
    #[doc = r"     }"]
    #[doc = r" }"]
    #[doc = r" ```"]
    macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ty = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ]
mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ]
# [ no_mangle ]
pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ]
# [ no_mangle ]
pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } }
}
pub use self::interrupt::Interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also `modify`'ed."]
    pub trait Readable {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also `modify`'ed."]
    pub trait Writable {}
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait ResetValue {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Type;
        #[doc = " Reset value of the register."]
        fn reset_value() -> Self::Type;
    }
    #[doc = " This structure provides volatile access to registers."]
    pub struct Reg<U, REG> {
        register: vcell::VolatileCell<U>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<U: Send, REG> Send for Reg<U, REG> {}
    impl<U, REG> Reg<U, REG>
    where
        Self: Readable,
        U: Copy,
    {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<U, Self> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<U, REG> Reg<U, REG>
    where
        Self: ResetValue<Type = U> + Writable,
        U: Copy,
    {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(Self::reset_value())
        }
    }
    impl<U, REG> Reg<U, REG>
    where
        Self: ResetValue<Type = U> + Writable,
        U: Copy,
    {
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W<U, Self>) -> &mut W<U, Self>,
        {
            self.register.set(
                f(&mut W {
                    bits: Self::reset_value(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<U, REG> Reg<U, REG>
    where
        Self: Writable,
        U: Copy + Default,
    {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[inline(always)]
        pub fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut W<U, Self>) -> &mut W<U, Self>,
        {
            self.register.set(
                f(&mut W {
                    bits: U::default(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<U, REG> Reg<U, REG>
    where
        Self: Readable + Writable,
        U: Copy,
    {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&R<U, Self>, &'w mut W<U, Self>) -> &'w mut W<U, Self>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &R {
                        bits,
                        _reg: marker::PhantomData,
                    },
                    &mut W {
                        bits,
                        _reg: marker::PhantomData,
                    },
                )
                .bits,
            );
        }
    }
    #[doc = " Register/field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub struct R<U, T> {
        pub(crate) bits: U,
        _reg: marker::PhantomData<T>,
    }
    impl<U, T> R<U, T>
    where
        U: Copy,
    {
        #[doc = " Creates a new instance of the reader."]
        #[inline(always)]
        pub(crate) fn new(bits: U) -> Self {
            Self {
                bits,
                _reg: marker::PhantomData,
            }
        }
        #[doc = " Reads raw bits from register/field."]
        #[inline(always)]
        pub fn bits(&self) -> U {
            self.bits
        }
    }
    impl<U, T, FI> PartialEq<FI> for R<U, T>
    where
        U: PartialEq,
        FI: Copy + Into<U>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&(*other).into())
        }
    }
    impl<FI> R<bool, FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub struct W<U, REG> {
        #[doc = "Writable bits"]
        pub(crate) bits: U,
        _reg: marker::PhantomData<REG>,
    }
    impl<U, REG> W<U, REG> {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: U) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Used if enumerated values cover not the whole range."]
    #[derive(Clone, Copy, PartialEq)]
    pub enum Variant<U, T> {
        #[doc = " Expected variant."]
        Val(T),
        #[doc = " Raw bits."]
        Res(U),
    }
}
#[doc = "Core Local Interruptor"]
pub struct CLINT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CLINT {}
impl CLINT {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const clint::RegisterBlock {
        0x0200_0000 as *const _
    }
}
impl Deref for CLINT {
    type Target = clint::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*CLINT::ptr() }
    }
}
#[doc = "Core Local Interruptor"]
pub mod clint {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Hart software interrupt register"]
        pub msip: [MSIP; 2],
        _reserved1: [u8; 16376usize],
        #[doc = "0x4000 - Hart time comparator register"]
        pub mtimecmp: [MTIMECMP; 2],
        _reserved2: [u8; 32744usize],
        #[doc = "0xbff8 - Timer register"]
        pub mtime: MTIME,
    }
    #[doc = "Hart software interrupt register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msip](msip) module"]
    pub type MSIP = crate::Reg<u32, _MSIP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MSIP;
    #[doc = "`read()` method returns [msip::R](msip::R) reader structure"]
    impl crate::Readable for MSIP {}
    #[doc = "`write(|w| ..)` method takes [msip::W](msip::W) writer structure"]
    impl crate::Writable for MSIP {}
    #[doc = "Hart software interrupt register"]
    pub mod msip {
        #[doc = "Reader of register msip[%s]"]
        pub type R = crate::R<u32, super::MSIP>;
        #[doc = "Writer for register msip[%s]"]
        pub type W = crate::W<u32, super::MSIP>;
        #[doc = "Register msip[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::MSIP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Hart time comparator register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mtimecmp](mtimecmp) module"]
    pub type MTIMECMP = crate::Reg<u64, _MTIMECMP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MTIMECMP;
    #[doc = "`read()` method returns [mtimecmp::R](mtimecmp::R) reader structure"]
    impl crate::Readable for MTIMECMP {}
    #[doc = "`write(|w| ..)` method takes [mtimecmp::W](mtimecmp::W) writer structure"]
    impl crate::Writable for MTIMECMP {}
    #[doc = "Hart time comparator register"]
    pub mod mtimecmp {
        #[doc = "Reader of register mtimecmp[%s]"]
        pub type R = crate::R<u64, super::MTIMECMP>;
        #[doc = "Writer for register mtimecmp[%s]"]
        pub type W = crate::W<u64, super::MTIMECMP>;
        #[doc = "Register mtimecmp[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::MTIMECMP {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Timer register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mtime](mtime) module"]
    pub type MTIME = crate::Reg<u64, _MTIME>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MTIME;
    #[doc = "`read()` method returns [mtime::R](mtime::R) reader structure"]
    impl crate::Readable for MTIME {}
    #[doc = "`write(|w| ..)` method takes [mtime::W](mtime::W) writer structure"]
    impl crate::Writable for MTIME {}
    #[doc = "Timer register"]
    pub mod mtime {
        #[doc = "Reader of register mtime"]
        pub type R = crate::R<u64, super::MTIME>;
        #[doc = "Writer for register mtime"]
        pub type W = crate::W<u64, super::MTIME>;
        #[doc = "Register mtime `reset()`'s with value 0"]
        impl crate::ResetValue for super::MTIME {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Platform-Level Interrupt Controller"]
pub struct PLIC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PLIC {}
impl PLIC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const plic::RegisterBlock {
        0x0c00_0000 as *const _
    }
}
impl Deref for PLIC {
    type Target = plic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*PLIC::ptr() }
    }
}
#[doc = "Platform-Level Interrupt Controller"]
pub mod plic {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Source Priority Register"]
        pub priority: [PRIORITY; 1024],
        #[doc = "0x1000 - Interrupt Pending Register"]
        pub pending: [PENDING; 32],
        _reserved2: [u8; 3968usize],
        #[doc = "0x2000 - Target Interrupt Enables"]
        pub target_enables: [TARGET_ENABLES; 4],
        _reserved3: [u8; 2088448usize],
        #[doc = "0x200000 - Target Configuration"]
        pub targets: [TARGETS; 4],
    }
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct TARGET_ENABLES {
        #[doc = "0x00 - Interrupt Enable Register"]
        pub enable: [self::target_enables::ENABLE; 32],
    }
    #[doc = r"Register block"]
    #[doc = "Target Interrupt Enables"]
    pub mod target_enables {
        #[doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [enable](enable) module"]
        pub type ENABLE = crate::Reg<u32, _ENABLE>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _ENABLE;
        #[doc = "`read()` method returns [enable::R](enable::R) reader structure"]
        impl crate::Readable for ENABLE {}
        #[doc = "`write(|w| ..)` method takes [enable::W](enable::W) writer structure"]
        impl crate::Writable for ENABLE {}
        #[doc = "Interrupt Enable Register"]
        pub mod enable {
            #[doc = "Reader of register enable[%s]"]
            pub type R = crate::R<u32, super::ENABLE>;
            #[doc = "Writer for register enable[%s]"]
            pub type W = crate::W<u32, super::ENABLE>;
            #[doc = "Register enable[%s]
`reset()`'s with value 0"]
            impl crate::ResetValue for super::ENABLE {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
    }
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct TARGETS {
        #[doc = "0x00 - Priority Threshold Register"]
        pub threshold: self::targets::THRESHOLD,
        #[doc = "0x04 - Claim/Complete Register"]
        pub claim: self::targets::CLAIM,
        _reserved2: [u8; 4084usize],
        #[doc = "0xffc - Padding to make sure targets is an array"]
        pub _reserved: self::targets::_RESERVED,
    }
    #[doc = r"Register block"]
    #[doc = "Target Configuration"]
    pub mod targets {
        #[doc = "Priority Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [threshold](threshold) module"]
        pub type THRESHOLD = crate::Reg<u32, _THRESHOLD>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _THRESHOLD;
        #[doc = "`read()` method returns [threshold::R](threshold::R) reader structure"]
        impl crate::Readable for THRESHOLD {}
        #[doc = "`write(|w| ..)` method takes [threshold::W](threshold::W) writer structure"]
        impl crate::Writable for THRESHOLD {}
        #[doc = "Priority Threshold Register"]
        pub mod threshold {
            #[doc = "Reader of register threshold"]
            pub type R = crate::R<u32, super::THRESHOLD>;
            #[doc = "Writer for register threshold"]
            pub type W = crate::W<u32, super::THRESHOLD>;
            #[doc = "Register threshold `reset()`'s with value 0"]
            impl crate::ResetValue for super::THRESHOLD {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum PRIORITY_A {
                #[doc = "0: Never interrupt"]
                NEVER = 0,
                #[doc = "1: Priority 1"]
                P1 = 1,
                #[doc = "2: Priority 2"]
                P2 = 2,
                #[doc = "3: Priority 3"]
                P3 = 3,
                #[doc = "4: Priority 4"]
                P4 = 4,
                #[doc = "5: Priority 5"]
                P5 = 5,
                #[doc = "6: Priority 6"]
                P6 = 6,
                #[doc = "7: Priority 7"]
                P7 = 7,
            }
            impl From<PRIORITY_A> for u8 {
                #[inline(always)]
                fn from(variant: PRIORITY_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `priority`"]
            pub type PRIORITY_R = crate::R<u8, PRIORITY_A>;
            impl PRIORITY_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> PRIORITY_A {
                    match self.bits {
                        0 => PRIORITY_A::NEVER,
                        1 => PRIORITY_A::P1,
                        2 => PRIORITY_A::P2,
                        3 => PRIORITY_A::P3,
                        4 => PRIORITY_A::P4,
                        5 => PRIORITY_A::P5,
                        6 => PRIORITY_A::P6,
                        7 => PRIORITY_A::P7,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `NEVER`"]
                #[inline(always)]
                pub fn is_never(&self) -> bool {
                    *self == PRIORITY_A::NEVER
                }
                #[doc = "Checks if the value of the field is `P1`"]
                #[inline(always)]
                pub fn is_p1(&self) -> bool {
                    *self == PRIORITY_A::P1
                }
                #[doc = "Checks if the value of the field is `P2`"]
                #[inline(always)]
                pub fn is_p2(&self) -> bool {
                    *self == PRIORITY_A::P2
                }
                #[doc = "Checks if the value of the field is `P3`"]
                #[inline(always)]
                pub fn is_p3(&self) -> bool {
                    *self == PRIORITY_A::P3
                }
                #[doc = "Checks if the value of the field is `P4`"]
                #[inline(always)]
                pub fn is_p4(&self) -> bool {
                    *self == PRIORITY_A::P4
                }
                #[doc = "Checks if the value of the field is `P5`"]
                #[inline(always)]
                pub fn is_p5(&self) -> bool {
                    *self == PRIORITY_A::P5
                }
                #[doc = "Checks if the value of the field is `P6`"]
                #[inline(always)]
                pub fn is_p6(&self) -> bool {
                    *self == PRIORITY_A::P6
                }
                #[doc = "Checks if the value of the field is `P7`"]
                #[inline(always)]
                pub fn is_p7(&self) -> bool {
                    *self == PRIORITY_A::P7
                }
            }
            #[doc = "Write proxy for field `priority`"]
            pub struct PRIORITY_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PRIORITY_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: PRIORITY_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Never interrupt"]
                #[inline(always)]
                pub fn never(self) -> &'a mut W {
                    self.variant(PRIORITY_A::NEVER)
                }
                #[doc = "Priority 1"]
                #[inline(always)]
                pub fn p1(self) -> &'a mut W {
                    self.variant(PRIORITY_A::P1)
                }
                #[doc = "Priority 2"]
                #[inline(always)]
                pub fn p2(self) -> &'a mut W {
                    self.variant(PRIORITY_A::P2)
                }
                #[doc = "Priority 3"]
                #[inline(always)]
                pub fn p3(self) -> &'a mut W {
                    self.variant(PRIORITY_A::P3)
                }
                #[doc = "Priority 4"]
                #[inline(always)]
                pub fn p4(self) -> &'a mut W {
                    self.variant(PRIORITY_A::P4)
                }
                #[doc = "Priority 5"]
                #[inline(always)]
                pub fn p5(self) -> &'a mut W {
                    self.variant(PRIORITY_A::P5)
                }
                #[doc = "Priority 6"]
                #[inline(always)]
                pub fn p6(self) -> &'a mut W {
                    self.variant(PRIORITY_A::P6)
                }
                #[doc = "Priority 7"]
                #[inline(always)]
                pub fn p7(self) -> &'a mut W {
                    self.variant(PRIORITY_A::P7)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:2"]
                #[inline(always)]
                pub fn priority(&self) -> PRIORITY_R {
                    PRIORITY_R::new((self.bits & 0x07) as u8)
                }
            }
            impl W {
                #[doc = "Bits 0:2"]
                #[inline(always)]
                pub fn priority(&mut self) -> PRIORITY_W {
                    PRIORITY_W { w: self }
                }
            }
        }
        #[doc = "Claim/Complete Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [claim](claim) module"]
        pub type CLAIM = crate::Reg<u32, _CLAIM>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _CLAIM;
        #[doc = "`read()` method returns [claim::R](claim::R) reader structure"]
        impl crate::Readable for CLAIM {}
        #[doc = "`write(|w| ..)` method takes [claim::W](claim::W) writer structure"]
        impl crate::Writable for CLAIM {}
        #[doc = "Claim/Complete Register"]
        pub mod claim {
            #[doc = "Reader of register claim"]
            pub type R = crate::R<u32, super::CLAIM>;
            #[doc = "Writer for register claim"]
            pub type W = crate::W<u32, super::CLAIM>;
            #[doc = "Register claim `reset()`'s with value 0"]
            impl crate::ResetValue for super::CLAIM {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Padding to make sure targets is an array\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [_reserved](_reserved) module"]
        pub type _RESERVED = crate::Reg<u32, __RESERVED>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct __RESERVED;
        #[doc = "`read()` method returns [_reserved::R](_reserved::R) reader structure"]
        impl crate::Readable for _RESERVED {}
        #[doc = "`write(|w| ..)` method takes [_reserved::W](_reserved::W) writer structure"]
        impl crate::Writable for _RESERVED {}
        #[doc = "Padding to make sure targets is an array"]
        pub mod _reserved {
            #[doc = "Reader of register _reserved"]
            pub type R = crate::R<u32, super::_RESERVED>;
            #[doc = "Writer for register _reserved"]
            pub type W = crate::W<u32, super::_RESERVED>;
            #[doc = "Register _reserved `reset()`'s with value 0"]
            impl crate::ResetValue for super::_RESERVED {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
    }
    #[doc = "Interrupt Source Priority Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [priority](priority) module"]
    pub type PRIORITY = crate::Reg<u32, _PRIORITY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRIORITY;
    #[doc = "`read()` method returns [priority::R](priority::R) reader structure"]
    impl crate::Readable for PRIORITY {}
    #[doc = "`write(|w| ..)` method takes [priority::W](priority::W) writer structure"]
    impl crate::Writable for PRIORITY {}
    #[doc = "Interrupt Source Priority Register"]
    pub mod priority {
        #[doc = "Reader of register priority[%s]"]
        pub type R = crate::R<u32, super::PRIORITY>;
        #[doc = "Writer for register priority[%s]"]
        pub type W = crate::W<u32, super::PRIORITY>;
        #[doc = "Register priority[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::PRIORITY {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Pending Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pending](pending) module"]
    pub type PENDING = crate::Reg<u32, _PENDING>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PENDING;
    #[doc = "`read()` method returns [pending::R](pending::R) reader structure"]
    impl crate::Readable for PENDING {}
    #[doc = "`write(|w| ..)` method takes [pending::W](pending::W) writer structure"]
    impl crate::Writable for PENDING {}
    #[doc = "Interrupt Pending Register"]
    pub mod pending {
        #[doc = "Reader of register pending[%s]"]
        pub type R = crate::R<u32, super::PENDING>;
        #[doc = "Writer for register pending[%s]"]
        pub type W = crate::W<u32, super::PENDING>;
        #[doc = "Register pending[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::PENDING {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "High-speed UART"]
pub struct UARTHS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UARTHS {}
impl UARTHS {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uarths::RegisterBlock {
        0x3800_0000 as *const _
    }
}
impl Deref for UARTHS {
    type Target = uarths::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*UARTHS::ptr() }
    }
}
#[doc = "High-speed UART"]
pub mod uarths {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Transmit Data Register"]
        pub txdata: TXDATA,
        #[doc = "0x04 - Receive Data Register"]
        pub rxdata: RXDATA,
        #[doc = "0x08 - Transmit Control Register"]
        pub txctrl: TXCTRL,
        #[doc = "0x0c - Receive Control Register"]
        pub rxctrl: RXCTRL,
        #[doc = "0x10 - Interrupt Enable Register"]
        pub ie: IE,
        #[doc = "0x14 - Interrupt Pending Register"]
        pub ip: IP,
        #[doc = "0x18 - Baud Rate Divisor Register"]
        pub div: DIV,
    }
    #[doc = "Transmit Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdata](txdata) module"]
    pub type TXDATA = crate::Reg<u32, _TXDATA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXDATA;
    #[doc = "`read()` method returns [txdata::R](txdata::R) reader structure"]
    impl crate::Readable for TXDATA {}
    #[doc = "`write(|w| ..)` method takes [txdata::W](txdata::W) writer structure"]
    impl crate::Writable for TXDATA {}
    #[doc = "Transmit Data Register"]
    pub mod txdata {
        #[doc = "Reader of register txdata"]
        pub type R = crate::R<u32, super::TXDATA>;
        #[doc = "Writer for register txdata"]
        pub type W = crate::W<u32, super::TXDATA>;
        #[doc = "Register txdata `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXDATA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `data`"]
        pub type DATA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `data`"]
        pub struct DATA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `full`"]
        pub type FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `full`"]
        pub struct FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Transmit data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 31 - Transmit FIFO full"]
            #[inline(always)]
            pub fn full(&self) -> FULL_R {
                FULL_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Transmit data"]
            #[inline(always)]
            pub fn data(&mut self) -> DATA_W {
                DATA_W { w: self }
            }
            #[doc = "Bit 31 - Transmit FIFO full"]
            #[inline(always)]
            pub fn full(&mut self) -> FULL_W {
                FULL_W { w: self }
            }
        }
    }
    #[doc = "Receive Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdata](rxdata) module"]
    pub type RXDATA = crate::Reg<u32, _RXDATA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXDATA;
    #[doc = "`read()` method returns [rxdata::R](rxdata::R) reader structure"]
    impl crate::Readable for RXDATA {}
    #[doc = "`write(|w| ..)` method takes [rxdata::W](rxdata::W) writer structure"]
    impl crate::Writable for RXDATA {}
    #[doc = "Receive Data Register"]
    pub mod rxdata {
        #[doc = "Reader of register rxdata"]
        pub type R = crate::R<u32, super::RXDATA>;
        #[doc = "Writer for register rxdata"]
        pub type W = crate::W<u32, super::RXDATA>;
        #[doc = "Register rxdata `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXDATA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `data`"]
        pub type DATA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `data`"]
        pub struct DATA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `empty`"]
        pub type EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `empty`"]
        pub struct EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Received data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 31 - Receive FIFO empty"]
            #[inline(always)]
            pub fn empty(&self) -> EMPTY_R {
                EMPTY_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Received data"]
            #[inline(always)]
            pub fn data(&mut self) -> DATA_W {
                DATA_W { w: self }
            }
            #[doc = "Bit 31 - Receive FIFO empty"]
            #[inline(always)]
            pub fn empty(&mut self) -> EMPTY_W {
                EMPTY_W { w: self }
            }
        }
    }
    #[doc = "Transmit Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txctrl](txctrl) module"]
    pub type TXCTRL = crate::Reg<u32, _TXCTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXCTRL;
    #[doc = "`read()` method returns [txctrl::R](txctrl::R) reader structure"]
    impl crate::Readable for TXCTRL {}
    #[doc = "`write(|w| ..)` method takes [txctrl::W](txctrl::W) writer structure"]
    impl crate::Writable for TXCTRL {}
    #[doc = "Transmit Control Register"]
    pub mod txctrl {
        #[doc = "Reader of register txctrl"]
        pub type R = crate::R<u32, super::TXCTRL>;
        #[doc = "Writer for register txctrl"]
        pub type W = crate::W<u32, super::TXCTRL>;
        #[doc = "Register txctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXCTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `txen`"]
        pub type TXEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `txen`"]
        pub struct TXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `nstop`"]
        pub type NSTOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `nstop`"]
        pub struct NSTOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NSTOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `txcnt`"]
        pub type TXCNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `txcnt`"]
        pub struct TXCNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXCNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 16)) | (((value as u32) & 0x07) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Transmit enable"]
            #[inline(always)]
            pub fn txen(&self) -> TXEN_R {
                TXEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Number of stop bits"]
            #[inline(always)]
            pub fn nstop(&self) -> NSTOP_R {
                NSTOP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bits 16:18 - Transmit watermark level"]
            #[inline(always)]
            pub fn txcnt(&self) -> TXCNT_R {
                TXCNT_R::new(((self.bits >> 16) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transmit enable"]
            #[inline(always)]
            pub fn txen(&mut self) -> TXEN_W {
                TXEN_W { w: self }
            }
            #[doc = "Bit 1 - Number of stop bits"]
            #[inline(always)]
            pub fn nstop(&mut self) -> NSTOP_W {
                NSTOP_W { w: self }
            }
            #[doc = "Bits 16:18 - Transmit watermark level"]
            #[inline(always)]
            pub fn txcnt(&mut self) -> TXCNT_W {
                TXCNT_W { w: self }
            }
        }
    }
    #[doc = "Receive Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxctrl](rxctrl) module"]
    pub type RXCTRL = crate::Reg<u32, _RXCTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXCTRL;
    #[doc = "`read()` method returns [rxctrl::R](rxctrl::R) reader structure"]
    impl crate::Readable for RXCTRL {}
    #[doc = "`write(|w| ..)` method takes [rxctrl::W](rxctrl::W) writer structure"]
    impl crate::Writable for RXCTRL {}
    #[doc = "Receive Control Register"]
    pub mod rxctrl {
        #[doc = "Reader of register rxctrl"]
        pub type R = crate::R<u32, super::RXCTRL>;
        #[doc = "Writer for register rxctrl"]
        pub type W = crate::W<u32, super::RXCTRL>;
        #[doc = "Register rxctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXCTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rxen`"]
        pub type RXEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rxen`"]
        pub struct RXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `rxcnt`"]
        pub type RXCNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `rxcnt`"]
        pub struct RXCNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXCNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 16)) | (((value as u32) & 0x07) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Receive enable"]
            #[inline(always)]
            pub fn rxen(&self) -> RXEN_R {
                RXEN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 16:18 - Receive watermark level"]
            #[inline(always)]
            pub fn rxcnt(&self) -> RXCNT_R {
                RXCNT_R::new(((self.bits >> 16) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Receive enable"]
            #[inline(always)]
            pub fn rxen(&mut self) -> RXEN_W {
                RXEN_W { w: self }
            }
            #[doc = "Bits 16:18 - Receive watermark level"]
            #[inline(always)]
            pub fn rxcnt(&mut self) -> RXCNT_W {
                RXCNT_W { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ie](ie) module"]
    pub type IE = crate::Reg<u32, _IE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IE;
    #[doc = "`read()` method returns [ie::R](ie::R) reader structure"]
    impl crate::Readable for IE {}
    #[doc = "`write(|w| ..)` method takes [ie::W](ie::W) writer structure"]
    impl crate::Writable for IE {}
    #[doc = "Interrupt Enable Register"]
    pub mod ie {
        #[doc = "Reader of register ie"]
        pub type R = crate::R<u32, super::IE>;
        #[doc = "Writer for register ie"]
        pub type W = crate::W<u32, super::IE>;
        #[doc = "Register ie `reset()`'s with value 0"]
        impl crate::ResetValue for super::IE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `txwm`"]
        pub type TXWM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `txwm`"]
        pub struct TXWM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXWM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `rxwm`"]
        pub type RXWM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rxwm`"]
        pub struct RXWM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXWM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Transmit watermark interrupt enable"]
            #[inline(always)]
            pub fn txwm(&self) -> TXWM_R {
                TXWM_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Receive watermark interrupt enable"]
            #[inline(always)]
            pub fn rxwm(&self) -> RXWM_R {
                RXWM_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transmit watermark interrupt enable"]
            #[inline(always)]
            pub fn txwm(&mut self) -> TXWM_W {
                TXWM_W { w: self }
            }
            #[doc = "Bit 1 - Receive watermark interrupt enable"]
            #[inline(always)]
            pub fn rxwm(&mut self) -> RXWM_W {
                RXWM_W { w: self }
            }
        }
    }
    #[doc = "Interrupt Pending Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ip](ip) module"]
    pub type IP = crate::Reg<u32, _IP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IP;
    #[doc = "`read()` method returns [ip::R](ip::R) reader structure"]
    impl crate::Readable for IP {}
    #[doc = "`write(|w| ..)` method takes [ip::W](ip::W) writer structure"]
    impl crate::Writable for IP {}
    #[doc = "Interrupt Pending Register"]
    pub mod ip {
        #[doc = "Reader of register ip"]
        pub type R = crate::R<u32, super::IP>;
        #[doc = "Writer for register ip"]
        pub type W = crate::W<u32, super::IP>;
        #[doc = "Register ip `reset()`'s with value 0"]
        impl crate::ResetValue for super::IP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `txwm`"]
        pub type TXWM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `txwm`"]
        pub struct TXWM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXWM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `rxwm`"]
        pub type RXWM_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rxwm`"]
        pub struct RXWM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXWM_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Transmit watermark interrupt pending"]
            #[inline(always)]
            pub fn txwm(&self) -> TXWM_R {
                TXWM_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Receive watermark interrupt pending"]
            #[inline(always)]
            pub fn rxwm(&self) -> RXWM_R {
                RXWM_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transmit watermark interrupt pending"]
            #[inline(always)]
            pub fn txwm(&mut self) -> TXWM_W {
                TXWM_W { w: self }
            }
            #[doc = "Bit 1 - Receive watermark interrupt pending"]
            #[inline(always)]
            pub fn rxwm(&mut self) -> RXWM_W {
                RXWM_W { w: self }
            }
        }
    }
    #[doc = "Baud Rate Divisor Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [div](div) module"]
    pub type DIV = crate::Reg<u32, _DIV>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIV;
    #[doc = "`read()` method returns [div::R](div::R) reader structure"]
    impl crate::Readable for DIV {}
    #[doc = "`write(|w| ..)` method takes [div::W](div::W) writer structure"]
    impl crate::Writable for DIV {}
    #[doc = "Baud Rate Divisor Register"]
    pub mod div {
        #[doc = "Reader of register div"]
        pub type R = crate::R<u32, super::DIV>;
        #[doc = "Writer for register div"]
        pub type W = crate::W<u32, super::DIV>;
        #[doc = "Register div `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIV {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `div`"]
        pub type DIV_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `div`"]
        pub struct DIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Baud rate divisor"]
            #[inline(always)]
            pub fn div(&self) -> DIV_R {
                DIV_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Baud rate divisor"]
            #[inline(always)]
            pub fn div(&mut self) -> DIV_W {
                DIV_W { w: self }
            }
        }
    }
}
#[doc = "High-speed GPIO"]
pub struct GPIOHS {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOHS {}
impl GPIOHS {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpiohs::RegisterBlock {
        0x3800_1000 as *const _
    }
}
impl Deref for GPIOHS {
    type Target = gpiohs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIOHS::ptr() }
    }
}
#[doc = "High-speed GPIO"]
pub mod gpiohs {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Input Value Register"]
        pub input_val: INPUT_VAL,
        #[doc = "0x04 - Pin Input Enable Register"]
        pub input_en: INPUT_EN,
        #[doc = "0x08 - Pin Output Enable Register"]
        pub output_en: OUTPUT_EN,
        #[doc = "0x0c - Output Value Register"]
        pub output_val: OUTPUT_VAL,
        #[doc = "0x10 - Internal Pull-Up Enable Register"]
        pub pullup_en: PULLUP_EN,
        #[doc = "0x14 - Drive Strength Register"]
        pub drive: DRIVE,
        #[doc = "0x18 - Rise Interrupt Enable Register"]
        pub rise_ie: RISE_IE,
        #[doc = "0x1c - Rise Interrupt Pending Register"]
        pub rise_ip: RISE_IP,
        #[doc = "0x20 - Fall Interrupt Enable Register"]
        pub fall_ie: FALL_IE,
        #[doc = "0x24 - Fall Interrupt Pending Register"]
        pub fall_ip: FALL_IP,
        #[doc = "0x28 - High Interrupt Enable Register"]
        pub high_ie: HIGH_IE,
        #[doc = "0x2c - High Interrupt Pending Register"]
        pub high_ip: HIGH_IP,
        #[doc = "0x30 - Low Interrupt Enable Register"]
        pub low_ie: LOW_IE,
        #[doc = "0x34 - Low Interrupt Pending Register"]
        pub low_ip: LOW_IP,
        #[doc = "0x38 - HW I/O Function Enable Register"]
        pub iof_en: IOF_EN,
        #[doc = "0x3c - HW I/O Function Select Register"]
        pub iof_sel: IOF_SEL,
        #[doc = "0x40 - Output XOR (invert) Register"]
        pub output_xor: OUTPUT_XOR,
    }
    #[doc = "Input Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [input_val](input_val) module"]
    pub type INPUT_VAL = crate::Reg<u32, _INPUT_VAL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INPUT_VAL;
    #[doc = "`read()` method returns [input_val::R](input_val::R) reader structure"]
    impl crate::Readable for INPUT_VAL {}
    #[doc = "`write(|w| ..)` method takes [input_val::W](input_val::W) writer structure"]
    impl crate::Writable for INPUT_VAL {}
    #[doc = "Input Value Register"]
    pub mod input_val {
        #[doc = "Reader of register input_val"]
        pub type R = crate::R<u32, super::INPUT_VAL>;
        #[doc = "Writer for register input_val"]
        pub type W = crate::W<u32, super::INPUT_VAL>;
        #[doc = "Register input_val `reset()`'s with value 0"]
        impl crate::ResetValue for super::INPUT_VAL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Pin Input Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [input_en](input_en) module"]
    pub type INPUT_EN = crate::Reg<u32, _INPUT_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INPUT_EN;
    #[doc = "`read()` method returns [input_en::R](input_en::R) reader structure"]
    impl crate::Readable for INPUT_EN {}
    #[doc = "`write(|w| ..)` method takes [input_en::W](input_en::W) writer structure"]
    impl crate::Writable for INPUT_EN {}
    #[doc = "Pin Input Enable Register"]
    pub mod input_en {
        #[doc = "Reader of register input_en"]
        pub type R = crate::R<u32, super::INPUT_EN>;
        #[doc = "Writer for register input_en"]
        pub type W = crate::W<u32, super::INPUT_EN>;
        #[doc = "Register input_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::INPUT_EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Pin Output Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [output_en](output_en) module"]
    pub type OUTPUT_EN = crate::Reg<u32, _OUTPUT_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OUTPUT_EN;
    #[doc = "`read()` method returns [output_en::R](output_en::R) reader structure"]
    impl crate::Readable for OUTPUT_EN {}
    #[doc = "`write(|w| ..)` method takes [output_en::W](output_en::W) writer structure"]
    impl crate::Writable for OUTPUT_EN {}
    #[doc = "Pin Output Enable Register"]
    pub mod output_en {
        #[doc = "Reader of register output_en"]
        pub type R = crate::R<u32, super::OUTPUT_EN>;
        #[doc = "Writer for register output_en"]
        pub type W = crate::W<u32, super::OUTPUT_EN>;
        #[doc = "Register output_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::OUTPUT_EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Output Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [output_val](output_val) module"]
    pub type OUTPUT_VAL = crate::Reg<u32, _OUTPUT_VAL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OUTPUT_VAL;
    #[doc = "`read()` method returns [output_val::R](output_val::R) reader structure"]
    impl crate::Readable for OUTPUT_VAL {}
    #[doc = "`write(|w| ..)` method takes [output_val::W](output_val::W) writer structure"]
    impl crate::Writable for OUTPUT_VAL {}
    #[doc = "Output Value Register"]
    pub mod output_val {
        #[doc = "Reader of register output_val"]
        pub type R = crate::R<u32, super::OUTPUT_VAL>;
        #[doc = "Writer for register output_val"]
        pub type W = crate::W<u32, super::OUTPUT_VAL>;
        #[doc = "Register output_val `reset()`'s with value 0"]
        impl crate::ResetValue for super::OUTPUT_VAL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Internal Pull-Up Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pullup_en](pullup_en) module"]
    pub type PULLUP_EN = crate::Reg<u32, _PULLUP_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PULLUP_EN;
    #[doc = "`read()` method returns [pullup_en::R](pullup_en::R) reader structure"]
    impl crate::Readable for PULLUP_EN {}
    #[doc = "`write(|w| ..)` method takes [pullup_en::W](pullup_en::W) writer structure"]
    impl crate::Writable for PULLUP_EN {}
    #[doc = "Internal Pull-Up Enable Register"]
    pub mod pullup_en {
        #[doc = "Reader of register pullup_en"]
        pub type R = crate::R<u32, super::PULLUP_EN>;
        #[doc = "Writer for register pullup_en"]
        pub type W = crate::W<u32, super::PULLUP_EN>;
        #[doc = "Register pullup_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::PULLUP_EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Drive Strength Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [drive](drive) module"]
    pub type DRIVE = crate::Reg<u32, _DRIVE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DRIVE;
    #[doc = "`read()` method returns [drive::R](drive::R) reader structure"]
    impl crate::Readable for DRIVE {}
    #[doc = "`write(|w| ..)` method takes [drive::W](drive::W) writer structure"]
    impl crate::Writable for DRIVE {}
    #[doc = "Drive Strength Register"]
    pub mod drive {
        #[doc = "Reader of register drive"]
        pub type R = crate::R<u32, super::DRIVE>;
        #[doc = "Writer for register drive"]
        pub type W = crate::W<u32, super::DRIVE>;
        #[doc = "Register drive `reset()`'s with value 0"]
        impl crate::ResetValue for super::DRIVE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Rise Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rise_ie](rise_ie) module"]
    pub type RISE_IE = crate::Reg<u32, _RISE_IE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RISE_IE;
    #[doc = "`read()` method returns [rise_ie::R](rise_ie::R) reader structure"]
    impl crate::Readable for RISE_IE {}
    #[doc = "`write(|w| ..)` method takes [rise_ie::W](rise_ie::W) writer structure"]
    impl crate::Writable for RISE_IE {}
    #[doc = "Rise Interrupt Enable Register"]
    pub mod rise_ie {
        #[doc = "Reader of register rise_ie"]
        pub type R = crate::R<u32, super::RISE_IE>;
        #[doc = "Writer for register rise_ie"]
        pub type W = crate::W<u32, super::RISE_IE>;
        #[doc = "Register rise_ie `reset()`'s with value 0"]
        impl crate::ResetValue for super::RISE_IE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Rise Interrupt Pending Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rise_ip](rise_ip) module"]
    pub type RISE_IP = crate::Reg<u32, _RISE_IP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RISE_IP;
    #[doc = "`read()` method returns [rise_ip::R](rise_ip::R) reader structure"]
    impl crate::Readable for RISE_IP {}
    #[doc = "`write(|w| ..)` method takes [rise_ip::W](rise_ip::W) writer structure"]
    impl crate::Writable for RISE_IP {}
    #[doc = "Rise Interrupt Pending Register"]
    pub mod rise_ip {
        #[doc = "Reader of register rise_ip"]
        pub type R = crate::R<u32, super::RISE_IP>;
        #[doc = "Writer for register rise_ip"]
        pub type W = crate::W<u32, super::RISE_IP>;
        #[doc = "Register rise_ip `reset()`'s with value 0"]
        impl crate::ResetValue for super::RISE_IP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Fall Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fall_ie](fall_ie) module"]
    pub type FALL_IE = crate::Reg<u32, _FALL_IE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FALL_IE;
    #[doc = "`read()` method returns [fall_ie::R](fall_ie::R) reader structure"]
    impl crate::Readable for FALL_IE {}
    #[doc = "`write(|w| ..)` method takes [fall_ie::W](fall_ie::W) writer structure"]
    impl crate::Writable for FALL_IE {}
    #[doc = "Fall Interrupt Enable Register"]
    pub mod fall_ie {
        #[doc = "Reader of register fall_ie"]
        pub type R = crate::R<u32, super::FALL_IE>;
        #[doc = "Writer for register fall_ie"]
        pub type W = crate::W<u32, super::FALL_IE>;
        #[doc = "Register fall_ie `reset()`'s with value 0"]
        impl crate::ResetValue for super::FALL_IE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Fall Interrupt Pending Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fall_ip](fall_ip) module"]
    pub type FALL_IP = crate::Reg<u32, _FALL_IP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FALL_IP;
    #[doc = "`read()` method returns [fall_ip::R](fall_ip::R) reader structure"]
    impl crate::Readable for FALL_IP {}
    #[doc = "`write(|w| ..)` method takes [fall_ip::W](fall_ip::W) writer structure"]
    impl crate::Writable for FALL_IP {}
    #[doc = "Fall Interrupt Pending Register"]
    pub mod fall_ip {
        #[doc = "Reader of register fall_ip"]
        pub type R = crate::R<u32, super::FALL_IP>;
        #[doc = "Writer for register fall_ip"]
        pub type W = crate::W<u32, super::FALL_IP>;
        #[doc = "Register fall_ip `reset()`'s with value 0"]
        impl crate::ResetValue for super::FALL_IP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "High Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [high_ie](high_ie) module"]
    pub type HIGH_IE = crate::Reg<u32, _HIGH_IE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _HIGH_IE;
    #[doc = "`read()` method returns [high_ie::R](high_ie::R) reader structure"]
    impl crate::Readable for HIGH_IE {}
    #[doc = "`write(|w| ..)` method takes [high_ie::W](high_ie::W) writer structure"]
    impl crate::Writable for HIGH_IE {}
    #[doc = "High Interrupt Enable Register"]
    pub mod high_ie {
        #[doc = "Reader of register high_ie"]
        pub type R = crate::R<u32, super::HIGH_IE>;
        #[doc = "Writer for register high_ie"]
        pub type W = crate::W<u32, super::HIGH_IE>;
        #[doc = "Register high_ie `reset()`'s with value 0"]
        impl crate::ResetValue for super::HIGH_IE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "High Interrupt Pending Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [high_ip](high_ip) module"]
    pub type HIGH_IP = crate::Reg<u32, _HIGH_IP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _HIGH_IP;
    #[doc = "`read()` method returns [high_ip::R](high_ip::R) reader structure"]
    impl crate::Readable for HIGH_IP {}
    #[doc = "`write(|w| ..)` method takes [high_ip::W](high_ip::W) writer structure"]
    impl crate::Writable for HIGH_IP {}
    #[doc = "High Interrupt Pending Register"]
    pub mod high_ip {
        #[doc = "Reader of register high_ip"]
        pub type R = crate::R<u32, super::HIGH_IP>;
        #[doc = "Writer for register high_ip"]
        pub type W = crate::W<u32, super::HIGH_IP>;
        #[doc = "Register high_ip `reset()`'s with value 0"]
        impl crate::ResetValue for super::HIGH_IP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Low Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [low_ie](low_ie) module"]
    pub type LOW_IE = crate::Reg<u32, _LOW_IE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LOW_IE;
    #[doc = "`read()` method returns [low_ie::R](low_ie::R) reader structure"]
    impl crate::Readable for LOW_IE {}
    #[doc = "`write(|w| ..)` method takes [low_ie::W](low_ie::W) writer structure"]
    impl crate::Writable for LOW_IE {}
    #[doc = "Low Interrupt Enable Register"]
    pub mod low_ie {
        #[doc = "Reader of register low_ie"]
        pub type R = crate::R<u32, super::LOW_IE>;
        #[doc = "Writer for register low_ie"]
        pub type W = crate::W<u32, super::LOW_IE>;
        #[doc = "Register low_ie `reset()`'s with value 0"]
        impl crate::ResetValue for super::LOW_IE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Low Interrupt Pending Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [low_ip](low_ip) module"]
    pub type LOW_IP = crate::Reg<u32, _LOW_IP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LOW_IP;
    #[doc = "`read()` method returns [low_ip::R](low_ip::R) reader structure"]
    impl crate::Readable for LOW_IP {}
    #[doc = "`write(|w| ..)` method takes [low_ip::W](low_ip::W) writer structure"]
    impl crate::Writable for LOW_IP {}
    #[doc = "Low Interrupt Pending Register"]
    pub mod low_ip {
        #[doc = "Reader of register low_ip"]
        pub type R = crate::R<u32, super::LOW_IP>;
        #[doc = "Writer for register low_ip"]
        pub type W = crate::W<u32, super::LOW_IP>;
        #[doc = "Register low_ip `reset()`'s with value 0"]
        impl crate::ResetValue for super::LOW_IP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "HW I/O Function Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iof_en](iof_en) module"]
    pub type IOF_EN = crate::Reg<u32, _IOF_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IOF_EN;
    #[doc = "`read()` method returns [iof_en::R](iof_en::R) reader structure"]
    impl crate::Readable for IOF_EN {}
    #[doc = "`write(|w| ..)` method takes [iof_en::W](iof_en::W) writer structure"]
    impl crate::Writable for IOF_EN {}
    #[doc = "HW I/O Function Enable Register"]
    pub mod iof_en {
        #[doc = "Reader of register iof_en"]
        pub type R = crate::R<u32, super::IOF_EN>;
        #[doc = "Writer for register iof_en"]
        pub type W = crate::W<u32, super::IOF_EN>;
        #[doc = "Register iof_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::IOF_EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "HW I/O Function Select Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iof_sel](iof_sel) module"]
    pub type IOF_SEL = crate::Reg<u32, _IOF_SEL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IOF_SEL;
    #[doc = "`read()` method returns [iof_sel::R](iof_sel::R) reader structure"]
    impl crate::Readable for IOF_SEL {}
    #[doc = "`write(|w| ..)` method takes [iof_sel::W](iof_sel::W) writer structure"]
    impl crate::Writable for IOF_SEL {}
    #[doc = "HW I/O Function Select Register"]
    pub mod iof_sel {
        #[doc = "Reader of register iof_sel"]
        pub type R = crate::R<u32, super::IOF_SEL>;
        #[doc = "Writer for register iof_sel"]
        pub type W = crate::W<u32, super::IOF_SEL>;
        #[doc = "Register iof_sel `reset()`'s with value 0"]
        impl crate::ResetValue for super::IOF_SEL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
    #[doc = "Output XOR (invert) Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [output_xor](output_xor) module"]
    pub type OUTPUT_XOR = crate::Reg<u32, _OUTPUT_XOR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OUTPUT_XOR;
    #[doc = "`read()` method returns [output_xor::R](output_xor::R) reader structure"]
    impl crate::Readable for OUTPUT_XOR {}
    #[doc = "`write(|w| ..)` method takes [output_xor::W](output_xor::W) writer structure"]
    impl crate::Writable for OUTPUT_XOR {}
    #[doc = "Output XOR (invert) Register"]
    pub mod output_xor {
        #[doc = "Reader of register output_xor"]
        pub type R = crate::R<u32, super::OUTPUT_XOR>;
        #[doc = "Writer for register output_xor"]
        pub type W = crate::W<u32, super::OUTPUT_XOR>;
        #[doc = "Register output_xor `reset()`'s with value 0"]
        impl crate::ResetValue for super::OUTPUT_XOR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-31)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-31)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn pin8(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn pin9(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pin10(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn pin11(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn pin12(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn pin13(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn pin14(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 14,
                }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn pin15(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 15,
                }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn pin16(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn pin17(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pin18(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn pin19(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn pin20(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pin21(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn pin22(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 22,
                }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn pin23(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 23,
                }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn pin24(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn pin25(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn pin26(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn pin27(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28"]
            #[inline(always)]
            pub fn pin28(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn pin29(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Bit 30"]
            #[inline(always)]
            pub fn pin30(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 30,
                }
            }
            #[doc = "Bit 31"]
            #[inline(always)]
            pub fn pin31(&mut self) -> PIN_W {
                PIN_W {
                    w: self,
                    offset: 31,
                }
            }
        }
    }
}
#[doc = "Neural Network Accelerator"]
pub struct KPU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for KPU {}
impl KPU {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const kpu::RegisterBlock {
        0x4080_0000 as *const _
    }
}
impl Deref for KPU {
    type Target = kpu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*KPU::ptr() }
    }
}
#[doc = "Neural Network Accelerator"]
pub mod kpu {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Layer arguments FIFO: each layer is defined by writing 12 successive argument values to this register"]
        pub layer_argument_fifo: LAYER_ARGUMENT_FIFO,
        #[doc = "0x08 - Interrupt status"]
        pub interrupt_status: INTERRUPT_STATUS,
        #[doc = "0x10 - Interrupt raw"]
        pub interrupt_raw: INTERRUPT_RAW,
        #[doc = "0x18 - Interrupt mask: 0 enables the interrupt, 1 masks the interrupt"]
        pub interrupt_mask: INTERRUPT_MASK,
        #[doc = "0x20 - Interrupt clear: write 1 to a bit to clear interrupt"]
        pub interrupt_clear: INTERRUPT_CLEAR,
        #[doc = "0x28 - FIFO threshold"]
        pub fifo_threshold: FIFO_THRESHOLD,
        #[doc = "0x30 - FIFO data output"]
        pub fifo_data_out: FIFO_DATA_OUT,
        #[doc = "0x38 - FIFO control"]
        pub fifo_ctrl: FIFO_CTRL,
        #[doc = "0x40 - Eight bit mode"]
        pub eight_bit_mode: EIGHT_BIT_MODE,
    }
    #[doc = "Layer arguments FIFO: each layer is defined by writing 12 successive argument values to this register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [layer_argument_fifo](layer_argument_fifo) module"]
    pub type LAYER_ARGUMENT_FIFO = crate::Reg<u64, _LAYER_ARGUMENT_FIFO>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LAYER_ARGUMENT_FIFO;
    #[doc = "`read()` method returns [layer_argument_fifo::R](layer_argument_fifo::R) reader structure"]
    impl crate::Readable for LAYER_ARGUMENT_FIFO {}
    #[doc = "`write(|w| ..)` method takes [layer_argument_fifo::W](layer_argument_fifo::W) writer structure"]
    impl crate::Writable for LAYER_ARGUMENT_FIFO {}
    #[doc = "Layer arguments FIFO: each layer is defined by writing 12 successive argument values to this register"]
    pub mod layer_argument_fifo {
        #[doc = "Reader of register layer_argument_fifo"]
        pub type R = crate::R<u64, super::LAYER_ARGUMENT_FIFO>;
        #[doc = "Writer for register layer_argument_fifo"]
        pub type W = crate::W<u64, super::LAYER_ARGUMENT_FIFO>;
        #[doc = "Register layer_argument_fifo `reset()`'s with value 0"]
        impl crate::ResetValue for super::LAYER_ARGUMENT_FIFO {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_status](interrupt_status) module"]
    pub type INTERRUPT_STATUS = crate::Reg<u64, _INTERRUPT_STATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_STATUS;
    #[doc = "`read()` method returns [interrupt_status::R](interrupt_status::R) reader structure"]
    impl crate::Readable for INTERRUPT_STATUS {}
    #[doc = "`write(|w| ..)` method takes [interrupt_status::W](interrupt_status::W) writer structure"]
    impl crate::Writable for INTERRUPT_STATUS {}
    #[doc = "Interrupt status"]
    pub mod interrupt_status {
        #[doc = "Reader of register interrupt_status"]
        pub type R = crate::R<u64, super::INTERRUPT_STATUS>;
        #[doc = "Writer for register interrupt_status"]
        pub type W = crate::W<u64, super::INTERRUPT_STATUS>;
        #[doc = "Register interrupt_status `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_STATUS {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `calc_done`"]
        pub type CALC_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `calc_done`"]
        pub struct CALC_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALC_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_empty`"]
        pub type LAYER_CFG_ALMOST_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_empty`"]
        pub struct LAYER_CFG_ALMOST_EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_full`"]
        pub type LAYER_CFG_ALMOST_FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_full`"]
        pub struct LAYER_CFG_ALMOST_FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&self) -> CALC_DONE_R {
                CALC_DONE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&self) -> LAYER_CFG_ALMOST_EMPTY_R {
                LAYER_CFG_ALMOST_EMPTY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&self) -> LAYER_CFG_ALMOST_FULL_R {
                LAYER_CFG_ALMOST_FULL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&mut self) -> CALC_DONE_W {
                CALC_DONE_W { w: self }
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&mut self) -> LAYER_CFG_ALMOST_EMPTY_W {
                LAYER_CFG_ALMOST_EMPTY_W { w: self }
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&mut self) -> LAYER_CFG_ALMOST_FULL_W {
                LAYER_CFG_ALMOST_FULL_W { w: self }
            }
        }
    }
    #[doc = "Interrupt raw\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_raw](interrupt_raw) module"]
    pub type INTERRUPT_RAW = crate::Reg<u64, _INTERRUPT_RAW>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_RAW;
    #[doc = "`read()` method returns [interrupt_raw::R](interrupt_raw::R) reader structure"]
    impl crate::Readable for INTERRUPT_RAW {}
    #[doc = "`write(|w| ..)` method takes [interrupt_raw::W](interrupt_raw::W) writer structure"]
    impl crate::Writable for INTERRUPT_RAW {}
    #[doc = "Interrupt raw"]
    pub mod interrupt_raw {
        #[doc = "Reader of register interrupt_raw"]
        pub type R = crate::R<u64, super::INTERRUPT_RAW>;
        #[doc = "Writer for register interrupt_raw"]
        pub type W = crate::W<u64, super::INTERRUPT_RAW>;
        #[doc = "Register interrupt_raw `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_RAW {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `calc_done`"]
        pub type CALC_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `calc_done`"]
        pub struct CALC_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALC_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_empty`"]
        pub type LAYER_CFG_ALMOST_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_empty`"]
        pub struct LAYER_CFG_ALMOST_EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_full`"]
        pub type LAYER_CFG_ALMOST_FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_full`"]
        pub struct LAYER_CFG_ALMOST_FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&self) -> CALC_DONE_R {
                CALC_DONE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&self) -> LAYER_CFG_ALMOST_EMPTY_R {
                LAYER_CFG_ALMOST_EMPTY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&self) -> LAYER_CFG_ALMOST_FULL_R {
                LAYER_CFG_ALMOST_FULL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&mut self) -> CALC_DONE_W {
                CALC_DONE_W { w: self }
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&mut self) -> LAYER_CFG_ALMOST_EMPTY_W {
                LAYER_CFG_ALMOST_EMPTY_W { w: self }
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&mut self) -> LAYER_CFG_ALMOST_FULL_W {
                LAYER_CFG_ALMOST_FULL_W { w: self }
            }
        }
    }
    #[doc = "Interrupt mask: 0 enables the interrupt, 1 masks the interrupt\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_mask](interrupt_mask) module"]
    pub type INTERRUPT_MASK = crate::Reg<u64, _INTERRUPT_MASK>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_MASK;
    #[doc = "`read()` method returns [interrupt_mask::R](interrupt_mask::R) reader structure"]
    impl crate::Readable for INTERRUPT_MASK {}
    #[doc = "`write(|w| ..)` method takes [interrupt_mask::W](interrupt_mask::W) writer structure"]
    impl crate::Writable for INTERRUPT_MASK {}
    #[doc = "Interrupt mask: 0 enables the interrupt, 1 masks the interrupt"]
    pub mod interrupt_mask {
        #[doc = "Reader of register interrupt_mask"]
        pub type R = crate::R<u64, super::INTERRUPT_MASK>;
        #[doc = "Writer for register interrupt_mask"]
        pub type W = crate::W<u64, super::INTERRUPT_MASK>;
        #[doc = "Register interrupt_mask `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_MASK {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `calc_done`"]
        pub type CALC_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `calc_done`"]
        pub struct CALC_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALC_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_empty`"]
        pub type LAYER_CFG_ALMOST_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_empty`"]
        pub struct LAYER_CFG_ALMOST_EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_full`"]
        pub type LAYER_CFG_ALMOST_FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_full`"]
        pub struct LAYER_CFG_ALMOST_FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&self) -> CALC_DONE_R {
                CALC_DONE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&self) -> LAYER_CFG_ALMOST_EMPTY_R {
                LAYER_CFG_ALMOST_EMPTY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&self) -> LAYER_CFG_ALMOST_FULL_R {
                LAYER_CFG_ALMOST_FULL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&mut self) -> CALC_DONE_W {
                CALC_DONE_W { w: self }
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&mut self) -> LAYER_CFG_ALMOST_EMPTY_W {
                LAYER_CFG_ALMOST_EMPTY_W { w: self }
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&mut self) -> LAYER_CFG_ALMOST_FULL_W {
                LAYER_CFG_ALMOST_FULL_W { w: self }
            }
        }
    }
    #[doc = "Interrupt clear: write 1 to a bit to clear interrupt\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_clear](interrupt_clear) module"]
    pub type INTERRUPT_CLEAR = crate::Reg<u64, _INTERRUPT_CLEAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_CLEAR;
    #[doc = "`read()` method returns [interrupt_clear::R](interrupt_clear::R) reader structure"]
    impl crate::Readable for INTERRUPT_CLEAR {}
    #[doc = "`write(|w| ..)` method takes [interrupt_clear::W](interrupt_clear::W) writer structure"]
    impl crate::Writable for INTERRUPT_CLEAR {}
    #[doc = "Interrupt clear: write 1 to a bit to clear interrupt"]
    pub mod interrupt_clear {
        #[doc = "Reader of register interrupt_clear"]
        pub type R = crate::R<u64, super::INTERRUPT_CLEAR>;
        #[doc = "Writer for register interrupt_clear"]
        pub type W = crate::W<u64, super::INTERRUPT_CLEAR>;
        #[doc = "Register interrupt_clear `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_CLEAR {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `calc_done`"]
        pub type CALC_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `calc_done`"]
        pub struct CALC_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALC_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_empty`"]
        pub type LAYER_CFG_ALMOST_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_empty`"]
        pub struct LAYER_CFG_ALMOST_EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `layer_cfg_almost_full`"]
        pub type LAYER_CFG_ALMOST_FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `layer_cfg_almost_full`"]
        pub struct LAYER_CFG_ALMOST_FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAYER_CFG_ALMOST_FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&self) -> CALC_DONE_R {
                CALC_DONE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&self) -> LAYER_CFG_ALMOST_EMPTY_R {
                LAYER_CFG_ALMOST_EMPTY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&self) -> LAYER_CFG_ALMOST_FULL_R {
                LAYER_CFG_ALMOST_FULL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt raised when calculation is done"]
            #[inline(always)]
            pub fn calc_done(&mut self) -> CALC_DONE_W {
                CALC_DONE_W { w: self }
            }
            #[doc = "Bit 1 - Interrupt raised when layer arguments FIFO almost empty"]
            #[inline(always)]
            pub fn layer_cfg_almost_empty(&mut self) -> LAYER_CFG_ALMOST_EMPTY_W {
                LAYER_CFG_ALMOST_EMPTY_W { w: self }
            }
            #[doc = "Bit 2 - Interrupt raised when layer arguments FIFO almost full"]
            #[inline(always)]
            pub fn layer_cfg_almost_full(&mut self) -> LAYER_CFG_ALMOST_FULL_W {
                LAYER_CFG_ALMOST_FULL_W { w: self }
            }
        }
    }
    #[doc = "FIFO threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_threshold](fifo_threshold) module"]
    pub type FIFO_THRESHOLD = crate::Reg<u64, _FIFO_THRESHOLD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FIFO_THRESHOLD;
    #[doc = "`read()` method returns [fifo_threshold::R](fifo_threshold::R) reader structure"]
    impl crate::Readable for FIFO_THRESHOLD {}
    #[doc = "`write(|w| ..)` method takes [fifo_threshold::W](fifo_threshold::W) writer structure"]
    impl crate::Writable for FIFO_THRESHOLD {}
    #[doc = "FIFO threshold"]
    pub mod fifo_threshold {
        #[doc = "Reader of register fifo_threshold"]
        pub type R = crate::R<u64, super::FIFO_THRESHOLD>;
        #[doc = "Writer for register fifo_threshold"]
        pub type W = crate::W<u64, super::FIFO_THRESHOLD>;
        #[doc = "Register fifo_threshold `reset()`'s with value 0"]
        impl crate::ResetValue for super::FIFO_THRESHOLD {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `full_threshold`"]
        pub type FULL_THRESHOLD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `full_threshold`"]
        pub struct FULL_THRESHOLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FULL_THRESHOLD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u64) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `empty_threshold`"]
        pub type EMPTY_THRESHOLD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `empty_threshold`"]
        pub struct EMPTY_THRESHOLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EMPTY_THRESHOLD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u64) & 0x0f) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - FIFO full threshold"]
            #[inline(always)]
            pub fn full_threshold(&self) -> FULL_THRESHOLD_R {
                FULL_THRESHOLD_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - FIFO empty threshold"]
            #[inline(always)]
            pub fn empty_threshold(&self) -> EMPTY_THRESHOLD_R {
                EMPTY_THRESHOLD_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - FIFO full threshold"]
            #[inline(always)]
            pub fn full_threshold(&mut self) -> FULL_THRESHOLD_W {
                FULL_THRESHOLD_W { w: self }
            }
            #[doc = "Bits 4:7 - FIFO empty threshold"]
            #[inline(always)]
            pub fn empty_threshold(&mut self) -> EMPTY_THRESHOLD_W {
                EMPTY_THRESHOLD_W { w: self }
            }
        }
    }
    #[doc = "FIFO data output\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_data_out](fifo_data_out) module"]
    pub type FIFO_DATA_OUT = crate::Reg<u64, _FIFO_DATA_OUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FIFO_DATA_OUT;
    #[doc = "`read()` method returns [fifo_data_out::R](fifo_data_out::R) reader structure"]
    impl crate::Readable for FIFO_DATA_OUT {}
    #[doc = "`write(|w| ..)` method takes [fifo_data_out::W](fifo_data_out::W) writer structure"]
    impl crate::Writable for FIFO_DATA_OUT {}
    #[doc = "FIFO data output"]
    pub mod fifo_data_out {
        #[doc = "Reader of register fifo_data_out"]
        pub type R = crate::R<u64, super::FIFO_DATA_OUT>;
        #[doc = "Writer for register fifo_data_out"]
        pub type W = crate::W<u64, super::FIFO_DATA_OUT>;
        #[doc = "Register fifo_data_out `reset()`'s with value 0"]
        impl crate::ResetValue for super::FIFO_DATA_OUT {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "FIFO control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_ctrl](fifo_ctrl) module"]
    pub type FIFO_CTRL = crate::Reg<u64, _FIFO_CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FIFO_CTRL;
    #[doc = "`read()` method returns [fifo_ctrl::R](fifo_ctrl::R) reader structure"]
    impl crate::Readable for FIFO_CTRL {}
    #[doc = "`write(|w| ..)` method takes [fifo_ctrl::W](fifo_ctrl::W) writer structure"]
    impl crate::Writable for FIFO_CTRL {}
    #[doc = "FIFO control"]
    pub mod fifo_ctrl {
        #[doc = "Reader of register fifo_ctrl"]
        pub type R = crate::R<u64, super::FIFO_CTRL>;
        #[doc = "Writer for register fifo_ctrl"]
        pub type W = crate::W<u64, super::FIFO_CTRL>;
        #[doc = "Register fifo_ctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::FIFO_CTRL {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dma_fifo_flush_n`"]
        pub type DMA_FIFO_FLUSH_N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_fifo_flush_n`"]
        pub struct DMA_FIFO_FLUSH_N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_FIFO_FLUSH_N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `gs_fifo_flush_n`"]
        pub type GS_FIFO_FLUSH_N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gs_fifo_flush_n`"]
        pub struct GS_FIFO_FLUSH_N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GS_FIFO_FLUSH_N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `cfg_fifo_flush_n`"]
        pub type CFG_FIFO_FLUSH_N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `cfg_fifo_flush_n`"]
        pub struct CFG_FIFO_FLUSH_N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CFG_FIFO_FLUSH_N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `cmd_fifo_flush_n`"]
        pub type CMD_FIFO_FLUSH_N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `cmd_fifo_flush_n`"]
        pub struct CMD_FIFO_FLUSH_N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMD_FIFO_FLUSH_N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `resp_fifo_flush_n`"]
        pub type RESP_FIFO_FLUSH_N_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `resp_fifo_flush_n`"]
        pub struct RESP_FIFO_FLUSH_N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESP_FIFO_FLUSH_N_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Flush DMA FIFO"]
            #[inline(always)]
            pub fn dma_fifo_flush_n(&self) -> DMA_FIFO_FLUSH_N_R {
                DMA_FIFO_FLUSH_N_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Flush GS FIFO"]
            #[inline(always)]
            pub fn gs_fifo_flush_n(&self) -> GS_FIFO_FLUSH_N_R {
                GS_FIFO_FLUSH_N_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Flush configuration FIFO"]
            #[inline(always)]
            pub fn cfg_fifo_flush_n(&self) -> CFG_FIFO_FLUSH_N_R {
                CFG_FIFO_FLUSH_N_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Flush command FIFO"]
            #[inline(always)]
            pub fn cmd_fifo_flush_n(&self) -> CMD_FIFO_FLUSH_N_R {
                CMD_FIFO_FLUSH_N_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Flush response FIFO"]
            #[inline(always)]
            pub fn resp_fifo_flush_n(&self) -> RESP_FIFO_FLUSH_N_R {
                RESP_FIFO_FLUSH_N_R::new(((self.bits >> 4) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Flush DMA FIFO"]
            #[inline(always)]
            pub fn dma_fifo_flush_n(&mut self) -> DMA_FIFO_FLUSH_N_W {
                DMA_FIFO_FLUSH_N_W { w: self }
            }
            #[doc = "Bit 1 - Flush GS FIFO"]
            #[inline(always)]
            pub fn gs_fifo_flush_n(&mut self) -> GS_FIFO_FLUSH_N_W {
                GS_FIFO_FLUSH_N_W { w: self }
            }
            #[doc = "Bit 2 - Flush configuration FIFO"]
            #[inline(always)]
            pub fn cfg_fifo_flush_n(&mut self) -> CFG_FIFO_FLUSH_N_W {
                CFG_FIFO_FLUSH_N_W { w: self }
            }
            #[doc = "Bit 3 - Flush command FIFO"]
            #[inline(always)]
            pub fn cmd_fifo_flush_n(&mut self) -> CMD_FIFO_FLUSH_N_W {
                CMD_FIFO_FLUSH_N_W { w: self }
            }
            #[doc = "Bit 4 - Flush response FIFO"]
            #[inline(always)]
            pub fn resp_fifo_flush_n(&mut self) -> RESP_FIFO_FLUSH_N_W {
                RESP_FIFO_FLUSH_N_W { w: self }
            }
        }
    }
    #[doc = "Eight bit mode\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eight_bit_mode](eight_bit_mode) module"]
    pub type EIGHT_BIT_MODE = crate::Reg<u64, _EIGHT_BIT_MODE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EIGHT_BIT_MODE;
    #[doc = "`read()` method returns [eight_bit_mode::R](eight_bit_mode::R) reader structure"]
    impl crate::Readable for EIGHT_BIT_MODE {}
    #[doc = "`write(|w| ..)` method takes [eight_bit_mode::W](eight_bit_mode::W) writer structure"]
    impl crate::Writable for EIGHT_BIT_MODE {}
    #[doc = "Eight bit mode"]
    pub mod eight_bit_mode {
        #[doc = "Reader of register eight_bit_mode"]
        pub type R = crate::R<u64, super::EIGHT_BIT_MODE>;
        #[doc = "Writer for register eight_bit_mode"]
        pub type W = crate::W<u64, super::EIGHT_BIT_MODE>;
        #[doc = "Register eight_bit_mode `reset()`'s with value 0"]
        impl crate::ResetValue for super::EIGHT_BIT_MODE {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `eight_bit_mode`"]
        pub type EIGHT_BIT_MODE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `eight_bit_mode`"]
        pub struct EIGHT_BIT_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EIGHT_BIT_MODE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Use 8-bit instead of 16-bit precision if set"]
            #[inline(always)]
            pub fn eight_bit_mode(&self) -> EIGHT_BIT_MODE_R {
                EIGHT_BIT_MODE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Use 8-bit instead of 16-bit precision if set"]
            #[inline(always)]
            pub fn eight_bit_mode(&mut self) -> EIGHT_BIT_MODE_W {
                EIGHT_BIT_MODE_W { w: self }
            }
        }
    }
}
#[doc = "Fast Fourier Transform Accelerator"]
pub struct FFT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FFT {}
impl FFT {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fft::RegisterBlock {
        0x4200_0000 as *const _
    }
}
impl Deref for FFT {
    type Target = fft::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*FFT::ptr() }
    }
}
#[doc = "Fast Fourier Transform Accelerator"]
pub mod fft {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - FFT input data fifo"]
        pub input_fifo: INPUT_FIFO,
        #[doc = "0x08 - FFT control register"]
        pub ctrl: CTRL,
        #[doc = "0x10 - FIFO control"]
        pub fifo_ctrl: FIFO_CTRL,
        #[doc = "0x18 - intr_mask"]
        pub interruptmask: INTERRUPTMASK,
        #[doc = "0x20 - Interrupt clear"]
        pub intr_clear: INTR_CLEAR,
        #[doc = "0x28 - FFT status register"]
        pub status: STATUS,
        #[doc = "0x30 - FFT status raw"]
        pub status_raw: STATUS_RAW,
        #[doc = "0x38 - FFT output FIFO"]
        pub output_fifo: OUTPUT_FIFO,
    }
    #[doc = "FFT input data fifo\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [input_fifo](input_fifo) module"]
    pub type INPUT_FIFO = crate::Reg<u64, _INPUT_FIFO>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INPUT_FIFO;
    #[doc = "`read()` method returns [input_fifo::R](input_fifo::R) reader structure"]
    impl crate::Readable for INPUT_FIFO {}
    #[doc = "`write(|w| ..)` method takes [input_fifo::W](input_fifo::W) writer structure"]
    impl crate::Writable for INPUT_FIFO {}
    #[doc = "FFT input data fifo"]
    pub mod input_fifo {
        #[doc = "Reader of register input_fifo"]
        pub type R = crate::R<u64, super::INPUT_FIFO>;
        #[doc = "Writer for register input_fifo"]
        pub type W = crate::W<u64, super::INPUT_FIFO>;
        #[doc = "Register input_fifo `reset()`'s with value 0"]
        impl crate::ResetValue for super::INPUT_FIFO {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "FFT control register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrl](ctrl) module"]
    pub type CTRL = crate::Reg<u64, _CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTRL;
    #[doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure"]
    impl crate::Readable for CTRL {}
    #[doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure"]
    impl crate::Writable for CTRL {}
    #[doc = "FFT control register"]
    pub mod ctrl {
        #[doc = "Reader of register ctrl"]
        pub type R = crate::R<u64, super::CTRL>;
        #[doc = "Writer for register ctrl"]
        pub type W = crate::W<u64, super::CTRL>;
        #[doc = "Register ctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTRL {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "FFT calculation data length\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum POINT_A {
            #[doc = "0: 512 point"]
            P512 = 0,
            #[doc = "1: 256 point"]
            P256 = 1,
            #[doc = "2: 128 point"]
            P128 = 2,
            #[doc = "3: 64 point"]
            P64 = 3,
        }
        impl From<POINT_A> for u8 {
            #[inline(always)]
            fn from(variant: POINT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `point`"]
        pub type POINT_R = crate::R<u8, POINT_A>;
        impl POINT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, POINT_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(POINT_A::P512),
                    1 => Val(POINT_A::P256),
                    2 => Val(POINT_A::P128),
                    3 => Val(POINT_A::P64),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `P512`"]
            #[inline(always)]
            pub fn is_p512(&self) -> bool {
                *self == POINT_A::P512
            }
            #[doc = "Checks if the value of the field is `P256`"]
            #[inline(always)]
            pub fn is_p256(&self) -> bool {
                *self == POINT_A::P256
            }
            #[doc = "Checks if the value of the field is `P128`"]
            #[inline(always)]
            pub fn is_p128(&self) -> bool {
                *self == POINT_A::P128
            }
            #[doc = "Checks if the value of the field is `P64`"]
            #[inline(always)]
            pub fn is_p64(&self) -> bool {
                *self == POINT_A::P64
            }
        }
        #[doc = "Write proxy for field `point`"]
        pub struct POINT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POINT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: POINT_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "512 point"]
            #[inline(always)]
            pub fn p512(self) -> &'a mut W {
                self.variant(POINT_A::P512)
            }
            #[doc = "256 point"]
            #[inline(always)]
            pub fn p256(self) -> &'a mut W {
                self.variant(POINT_A::P256)
            }
            #[doc = "128 point"]
            #[inline(always)]
            pub fn p128(self) -> &'a mut W {
                self.variant(POINT_A::P128)
            }
            #[doc = "64 point"]
            #[inline(always)]
            pub fn p64(self) -> &'a mut W {
                self.variant(POINT_A::P64)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u64) & 0x07);
                self.w
            }
        }
        #[doc = "FFT mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODE_A {
            #[doc = "0: FFT mode"]
            FFT = 0,
            #[doc = "1: Inverse FFT mode"]
            IFFT = 1,
        }
        impl From<MODE_A> for bool {
            #[inline(always)]
            fn from(variant: MODE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `mode`"]
        pub type MODE_R = crate::R<bool, MODE_A>;
        impl MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> MODE_A {
                match self.bits {
                    false => MODE_A::FFT,
                    true => MODE_A::IFFT,
                }
            }
            #[doc = "Checks if the value of the field is `FFT`"]
            #[inline(always)]
            pub fn is_fft(&self) -> bool {
                *self == MODE_A::FFT
            }
            #[doc = "Checks if the value of the field is `IFFT`"]
            #[inline(always)]
            pub fn is_ifft(&self) -> bool {
                *self == MODE_A::IFFT
            }
        }
        #[doc = "Write proxy for field `mode`"]
        pub struct MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "FFT mode"]
            #[inline(always)]
            pub fn fft(self) -> &'a mut W {
                self.variant(MODE_A::FFT)
            }
            #[doc = "Inverse FFT mode"]
            #[inline(always)]
            pub fn ifft(self) -> &'a mut W {
                self.variant(MODE_A::IFFT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `shift`"]
        pub type SHIFT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `shift`"]
        pub struct SHIFT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SHIFT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01ff << 4)) | (((value as u64) & 0x01ff) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `enable`"]
        pub type ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `enable`"]
        pub struct ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u64) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `dma_send`"]
        pub type DMA_SEND_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_send`"]
        pub struct DMA_SEND_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEND_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u64) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Input data arrangement\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum INPUT_MODE_A {
            #[doc = "0: RIRI (real imaginary interleaved)"]
            RIRI = 0,
            #[doc = "1: RRRR (only real part)"]
            RRRR = 1,
            #[doc = "2: First input the real part and then input the imaginary part"]
            RRII = 2,
        }
        impl From<INPUT_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: INPUT_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `input_mode`"]
        pub type INPUT_MODE_R = crate::R<u8, INPUT_MODE_A>;
        impl INPUT_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, INPUT_MODE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(INPUT_MODE_A::RIRI),
                    1 => Val(INPUT_MODE_A::RRRR),
                    2 => Val(INPUT_MODE_A::RRII),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RIRI`"]
            #[inline(always)]
            pub fn is_riri(&self) -> bool {
                *self == INPUT_MODE_A::RIRI
            }
            #[doc = "Checks if the value of the field is `RRRR`"]
            #[inline(always)]
            pub fn is_rrrr(&self) -> bool {
                *self == INPUT_MODE_A::RRRR
            }
            #[doc = "Checks if the value of the field is `RRII`"]
            #[inline(always)]
            pub fn is_rrii(&self) -> bool {
                *self == INPUT_MODE_A::RRII
            }
        }
        #[doc = "Write proxy for field `input_mode`"]
        pub struct INPUT_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INPUT_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INPUT_MODE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "RIRI (real imaginary interleaved)"]
            #[inline(always)]
            pub fn riri(self) -> &'a mut W {
                self.variant(INPUT_MODE_A::RIRI)
            }
            #[doc = "RRRR (only real part)"]
            #[inline(always)]
            pub fn rrrr(self) -> &'a mut W {
                self.variant(INPUT_MODE_A::RRRR)
            }
            #[doc = "First input the real part and then input the imaginary part"]
            #[inline(always)]
            pub fn rrii(self) -> &'a mut W {
                self.variant(INPUT_MODE_A::RRII)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 15)) | (((value as u64) & 0x03) << 15);
                self.w
            }
        }
        #[doc = "Effective width of input data\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_MODE_A {
            #[doc = "0: 64 bit effective"]
            WIDTH_64 = 0,
            #[doc = "1: 128 bit effective"]
            WIDTH_128 = 1,
        }
        impl From<DATA_MODE_A> for bool {
            #[inline(always)]
            fn from(variant: DATA_MODE_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `data_mode`"]
        pub type DATA_MODE_R = crate::R<bool, DATA_MODE_A>;
        impl DATA_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DATA_MODE_A {
                match self.bits {
                    false => DATA_MODE_A::WIDTH_64,
                    true => DATA_MODE_A::WIDTH_128,
                }
            }
            #[doc = "Checks if the value of the field is `WIDTH_64`"]
            #[inline(always)]
            pub fn is_width_64(&self) -> bool {
                *self == DATA_MODE_A::WIDTH_64
            }
            #[doc = "Checks if the value of the field is `WIDTH_128`"]
            #[inline(always)]
            pub fn is_width_128(&self) -> bool {
                *self == DATA_MODE_A::WIDTH_128
            }
        }
        #[doc = "Write proxy for field `data_mode`"]
        pub struct DATA_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATA_MODE_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "64 bit effective"]
            #[inline(always)]
            pub fn width_64(self) -> &'a mut W {
                self.variant(DATA_MODE_A::WIDTH_64)
            }
            #[doc = "128 bit effective"]
            #[inline(always)]
            pub fn width_128(self) -> &'a mut W {
                self.variant(DATA_MODE_A::WIDTH_128)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u64) & 0x01) << 17);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - FFT calculation data length"]
            #[inline(always)]
            pub fn point(&self) -> POINT_R {
                POINT_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bit 3 - FFT mode"]
            #[inline(always)]
            pub fn mode(&self) -> MODE_R {
                MODE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bits 4:12 - Corresponding to the nine layer butterfly shift operation, 0x0: does not shift; 0x1: shift 1st layer. ..."]
            #[inline(always)]
            pub fn shift(&self) -> SHIFT_R {
                SHIFT_R::new(((self.bits >> 4) & 0x01ff) as u16)
            }
            #[doc = "Bit 13 - FFT enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - FFT DMA enable"]
            #[inline(always)]
            pub fn dma_send(&self) -> DMA_SEND_R {
                DMA_SEND_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bits 15:16 - Input data arrangement"]
            #[inline(always)]
            pub fn input_mode(&self) -> INPUT_MODE_R {
                INPUT_MODE_R::new(((self.bits >> 15) & 0x03) as u8)
            }
            #[doc = "Bit 17 - Effective width of input data"]
            #[inline(always)]
            pub fn data_mode(&self) -> DATA_MODE_R {
                DATA_MODE_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - FFT calculation data length"]
            #[inline(always)]
            pub fn point(&mut self) -> POINT_W {
                POINT_W { w: self }
            }
            #[doc = "Bit 3 - FFT mode"]
            #[inline(always)]
            pub fn mode(&mut self) -> MODE_W {
                MODE_W { w: self }
            }
            #[doc = "Bits 4:12 - Corresponding to the nine layer butterfly shift operation, 0x0: does not shift; 0x1: shift 1st layer. ..."]
            #[inline(always)]
            pub fn shift(&mut self) -> SHIFT_W {
                SHIFT_W { w: self }
            }
            #[doc = "Bit 13 - FFT enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W {
                ENABLE_W { w: self }
            }
            #[doc = "Bit 14 - FFT DMA enable"]
            #[inline(always)]
            pub fn dma_send(&mut self) -> DMA_SEND_W {
                DMA_SEND_W { w: self }
            }
            #[doc = "Bits 15:16 - Input data arrangement"]
            #[inline(always)]
            pub fn input_mode(&mut self) -> INPUT_MODE_W {
                INPUT_MODE_W { w: self }
            }
            #[doc = "Bit 17 - Effective width of input data"]
            #[inline(always)]
            pub fn data_mode(&mut self) -> DATA_MODE_W {
                DATA_MODE_W { w: self }
            }
        }
    }
    #[doc = "FIFO control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fifo_ctrl](fifo_ctrl) module"]
    pub type FIFO_CTRL = crate::Reg<u64, _FIFO_CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FIFO_CTRL;
    #[doc = "`read()` method returns [fifo_ctrl::R](fifo_ctrl::R) reader structure"]
    impl crate::Readable for FIFO_CTRL {}
    #[doc = "`write(|w| ..)` method takes [fifo_ctrl::W](fifo_ctrl::W) writer structure"]
    impl crate::Writable for FIFO_CTRL {}
    #[doc = "FIFO control"]
    pub mod fifo_ctrl {
        #[doc = "Reader of register fifo_ctrl"]
        pub type R = crate::R<u64, super::FIFO_CTRL>;
        #[doc = "Writer for register fifo_ctrl"]
        pub type W = crate::W<u64, super::FIFO_CTRL>;
        #[doc = "Register fifo_ctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::FIFO_CTRL {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `resp_fifo_flush`"]
        pub type RESP_FIFO_FLUSH_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `resp_fifo_flush`"]
        pub struct RESP_FIFO_FLUSH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESP_FIFO_FLUSH_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `cmd_fifo_flush`"]
        pub type CMD_FIFO_FLUSH_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `cmd_fifo_flush`"]
        pub struct CMD_FIFO_FLUSH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMD_FIFO_FLUSH_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `gs_fifo_flush`"]
        pub type GS_FIFO_FLUSH_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gs_fifo_flush`"]
        pub struct GS_FIFO_FLUSH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GS_FIFO_FLUSH_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Response memory initialization flag"]
            #[inline(always)]
            pub fn resp_fifo_flush(&self) -> RESP_FIFO_FLUSH_R {
                RESP_FIFO_FLUSH_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Command memory initialization flag"]
            #[inline(always)]
            pub fn cmd_fifo_flush(&self) -> CMD_FIFO_FLUSH_R {
                CMD_FIFO_FLUSH_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Output interface memory initialization flag"]
            #[inline(always)]
            pub fn gs_fifo_flush(&self) -> GS_FIFO_FLUSH_R {
                GS_FIFO_FLUSH_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Response memory initialization flag"]
            #[inline(always)]
            pub fn resp_fifo_flush(&mut self) -> RESP_FIFO_FLUSH_W {
                RESP_FIFO_FLUSH_W { w: self }
            }
            #[doc = "Bit 1 - Command memory initialization flag"]
            #[inline(always)]
            pub fn cmd_fifo_flush(&mut self) -> CMD_FIFO_FLUSH_W {
                CMD_FIFO_FLUSH_W { w: self }
            }
            #[doc = "Bit 2 - Output interface memory initialization flag"]
            #[inline(always)]
            pub fn gs_fifo_flush(&mut self) -> GS_FIFO_FLUSH_W {
                GS_FIFO_FLUSH_W { w: self }
            }
        }
    }
    #[doc = "intr_mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interruptmask](interruptmask) module"]
    pub type INTERRUPTMASK = crate::Reg<u64, _INTERRUPTMASK>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPTMASK;
    #[doc = "`read()` method returns [interruptmask::R](interruptmask::R) reader structure"]
    impl crate::Readable for INTERRUPTMASK {}
    #[doc = "`write(|w| ..)` method takes [interruptmask::W](interruptmask::W) writer structure"]
    impl crate::Writable for INTERRUPTMASK {}
    #[doc = "intr_mask"]
    pub mod interruptmask {
        #[doc = "Reader of register interrupt mask"]
        pub type R = crate::R<u64, super::INTERRUPTMASK>;
        #[doc = "Writer for register interrupt mask"]
        pub type W = crate::W<u64, super::INTERRUPTMASK>;
        #[doc = "Register interrupt mask `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPTMASK {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `fft_done`"]
        pub type FFT_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fft_done`"]
        pub struct FFT_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FFT_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&self) -> FFT_DONE_R {
                FFT_DONE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&mut self) -> FFT_DONE_W {
                FFT_DONE_W { w: self }
            }
        }
    }
    #[doc = "Interrupt clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_clear](intr_clear) module"]
    pub type INTR_CLEAR = crate::Reg<u64, _INTR_CLEAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTR_CLEAR;
    #[doc = "`read()` method returns [intr_clear::R](intr_clear::R) reader structure"]
    impl crate::Readable for INTR_CLEAR {}
    #[doc = "`write(|w| ..)` method takes [intr_clear::W](intr_clear::W) writer structure"]
    impl crate::Writable for INTR_CLEAR {}
    #[doc = "Interrupt clear"]
    pub mod intr_clear {
        #[doc = "Reader of register intr_clear"]
        pub type R = crate::R<u64, super::INTR_CLEAR>;
        #[doc = "Writer for register intr_clear"]
        pub type W = crate::W<u64, super::INTR_CLEAR>;
        #[doc = "Register intr_clear `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTR_CLEAR {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `fft_done`"]
        pub type FFT_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fft_done`"]
        pub struct FFT_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FFT_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&self) -> FFT_DONE_R {
                FFT_DONE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&mut self) -> FFT_DONE_W {
                FFT_DONE_W { w: self }
            }
        }
    }
    #[doc = "FFT status register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module"]
    pub type STATUS = crate::Reg<u64, _STATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _STATUS;
    #[doc = "`read()` method returns [status::R](status::R) reader structure"]
    impl crate::Readable for STATUS {}
    #[doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure"]
    impl crate::Writable for STATUS {}
    #[doc = "FFT status register"]
    pub mod status {
        #[doc = "Reader of register status"]
        pub type R = crate::R<u64, super::STATUS>;
        #[doc = "Writer for register status"]
        pub type W = crate::W<u64, super::STATUS>;
        #[doc = "Register status `reset()`'s with value 0"]
        impl crate::ResetValue for super::STATUS {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `fft_done`"]
        pub type FFT_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fft_done`"]
        pub struct FFT_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FFT_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&self) -> FFT_DONE_R {
                FFT_DONE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&mut self) -> FFT_DONE_W {
                FFT_DONE_W { w: self }
            }
        }
    }
    #[doc = "FFT status raw\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status_raw](status_raw) module"]
    pub type STATUS_RAW = crate::Reg<u64, _STATUS_RAW>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _STATUS_RAW;
    #[doc = "`read()` method returns [status_raw::R](status_raw::R) reader structure"]
    impl crate::Readable for STATUS_RAW {}
    #[doc = "`write(|w| ..)` method takes [status_raw::W](status_raw::W) writer structure"]
    impl crate::Writable for STATUS_RAW {}
    #[doc = "FFT status raw"]
    pub mod status_raw {
        #[doc = "Reader of register status_raw"]
        pub type R = crate::R<u64, super::STATUS_RAW>;
        #[doc = "Writer for register status_raw"]
        pub type W = crate::W<u64, super::STATUS_RAW>;
        #[doc = "Register status_raw `reset()`'s with value 0"]
        impl crate::ResetValue for super::STATUS_RAW {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `fft_done`"]
        pub type FFT_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fft_done`"]
        pub struct FFT_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FFT_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `fft_work`"]
        pub type FFT_WORK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fft_work`"]
        pub struct FFT_WORK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FFT_WORK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&self) -> FFT_DONE_R {
                FFT_DONE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - FFT work"]
            #[inline(always)]
            pub fn fft_work(&self) -> FFT_WORK_R {
                FFT_WORK_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - FFT done"]
            #[inline(always)]
            pub fn fft_done(&mut self) -> FFT_DONE_W {
                FFT_DONE_W { w: self }
            }
            #[doc = "Bit 1 - FFT work"]
            #[inline(always)]
            pub fn fft_work(&mut self) -> FFT_WORK_W {
                FFT_WORK_W { w: self }
            }
        }
    }
    #[doc = "FFT output FIFO\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [output_fifo](output_fifo) module"]
    pub type OUTPUT_FIFO = crate::Reg<u64, _OUTPUT_FIFO>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OUTPUT_FIFO;
    #[doc = "`read()` method returns [output_fifo::R](output_fifo::R) reader structure"]
    impl crate::Readable for OUTPUT_FIFO {}
    #[doc = "`write(|w| ..)` method takes [output_fifo::W](output_fifo::W) writer structure"]
    impl crate::Writable for OUTPUT_FIFO {}
    #[doc = "FFT output FIFO"]
    pub mod output_fifo {
        #[doc = "Reader of register output_fifo"]
        pub type R = crate::R<u64, super::OUTPUT_FIFO>;
        #[doc = "Writer for register output_fifo"]
        pub type W = crate::W<u64, super::OUTPUT_FIFO>;
        #[doc = "Register output_fifo `reset()`'s with value 0"]
        impl crate::ResetValue for super::OUTPUT_FIFO {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Direct Memory Access Controller"]
pub struct DMAC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMAC {}
impl DMAC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmac::RegisterBlock {
        0x5000_0000 as *const _
    }
}
impl Deref for DMAC {
    type Target = dmac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DMAC::ptr() }
    }
}
#[doc = "Direct Memory Access Controller"]
pub mod dmac {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - ID Register"]
        pub id: ID,
        #[doc = "0x08 - COMPVER Register"]
        pub compver: COMPVER,
        #[doc = "0x10 - Configure Register"]
        pub cfg: CFG,
        #[doc = "0x18 - Channel Enable Register"]
        pub chen: CHEN,
        _reserved4: [u8; 16usize],
        #[doc = "0x30 - Interrupt Status Register"]
        pub intstatus: INTSTATUS,
        #[doc = "0x38 - Common Interrupt Clear Register"]
        pub com_intclear: COM_INTCLEAR,
        #[doc = "0x40 - Common Interrupt Status Enable Register"]
        pub com_intstatus_en: COM_INTSTATUS_EN,
        #[doc = "0x48 - Common Interrupt Signal Enable Register"]
        pub com_intsignal_en: COM_INTSIGNAL_EN,
        #[doc = "0x50 - Common Interrupt Status"]
        pub com_intstatus: COM_INTSTATUS,
        #[doc = "0x58 - Reset register"]
        pub reset: RESET,
        _reserved10: [u8; 160usize],
        #[doc = "0x100 - Channel configuration"]
        pub channel: [CHANNEL; 6],
    }
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct CHANNEL {
        #[doc = "0x00 - SAR Address Register"]
        pub sar: self::channel::SAR,
        #[doc = "0x08 - DAR Address Register"]
        pub dar: self::channel::DAR,
        #[doc = "0x10 - Block Transfer Size Register"]
        pub block_ts: self::channel::BLOCK_TS,
        #[doc = "0x18 - Control Register"]
        pub ctl: self::channel::CTL,
        #[doc = "0x20 - Configure Register"]
        pub cfg: self::channel::CFG,
        #[doc = "0x28 - Linked List Pointer register"]
        pub llp: self::channel::LLP,
        #[doc = "0x30 - Channel Status Register"]
        pub status: self::channel::STATUS,
        #[doc = "0x38 - Channel Software handshake Source Register"]
        pub swhssrc: self::channel::SWHSSRC,
        #[doc = "0x40 - Channel Software handshake Destination Register"]
        pub swhsdst: self::channel::SWHSDST,
        #[doc = "0x48 - Channel Block Transfer Resume Request Register"]
        pub blk_tfr: self::channel::BLK_TFR,
        #[doc = "0x50 - Channel AXI ID Register"]
        pub axi_id: self::channel::AXI_ID,
        #[doc = "0x58 - AXI QOS Register"]
        pub axi_qos: self::channel::AXI_QOS,
        _reserved12: [u8; 32usize],
        #[doc = "0x80 - Interrupt Status Enable Register"]
        pub intstatus_en: self::channel::INTSTATUS_EN,
        #[doc = "0x88 - Channel Interrupt Status Register"]
        pub intstatus: self::channel::INTSTATUS,
        #[doc = "0x90 - Interrupt Signal Enable Register"]
        pub intsignal_en: self::channel::INTSIGNAL_EN,
        #[doc = "0x98 - Interrupt Clear Register"]
        pub intclear: self::channel::INTCLEAR,
        _reserved16: [u8; 88usize],
        #[doc = "0xf8 - Padding to make structure size 256 bytes so that channels\\[\\]
is an array"]
        pub _reserved: self::channel::_RESERVED,
    }
    #[doc = r"Register block"]
    #[doc = "Channel configuration"]
    pub mod channel {
        #[doc = "SAR Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sar](sar) module"]
        pub type SAR = crate::Reg<u64, _SAR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _SAR;
        #[doc = "`read()` method returns [sar::R](sar::R) reader structure"]
        impl crate::Readable for SAR {}
        #[doc = "`write(|w| ..)` method takes [sar::W](sar::W) writer structure"]
        impl crate::Writable for SAR {}
        #[doc = "SAR Address Register"]
        pub mod sar {
            #[doc = "Reader of register sar"]
            pub type R = crate::R<u64, super::SAR>;
            #[doc = "Writer for register sar"]
            pub type W = crate::W<u64, super::SAR>;
            #[doc = "Register sar `reset()`'s with value 0"]
            impl crate::ResetValue for super::SAR {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "DAR Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dar](dar) module"]
        pub type DAR = crate::Reg<u64, _DAR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _DAR;
        #[doc = "`read()` method returns [dar::R](dar::R) reader structure"]
        impl crate::Readable for DAR {}
        #[doc = "`write(|w| ..)` method takes [dar::W](dar::W) writer structure"]
        impl crate::Writable for DAR {}
        #[doc = "DAR Address Register"]
        pub mod dar {
            #[doc = "Reader of register dar"]
            pub type R = crate::R<u64, super::DAR>;
            #[doc = "Writer for register dar"]
            pub type W = crate::W<u64, super::DAR>;
            #[doc = "Register dar `reset()`'s with value 0"]
            impl crate::ResetValue for super::DAR {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Block Transfer Size Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [block_ts](block_ts) module"]
        pub type BLOCK_TS = crate::Reg<u64, _BLOCK_TS>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _BLOCK_TS;
        #[doc = "`read()` method returns [block_ts::R](block_ts::R) reader structure"]
        impl crate::Readable for BLOCK_TS {}
        #[doc = "`write(|w| ..)` method takes [block_ts::W](block_ts::W) writer structure"]
        impl crate::Writable for BLOCK_TS {}
        #[doc = "Block Transfer Size Register"]
        pub mod block_ts {
            #[doc = "Reader of register block_ts"]
            pub type R = crate::R<u64, super::BLOCK_TS>;
            #[doc = "Writer for register block_ts"]
            pub type W = crate::W<u64, super::BLOCK_TS>;
            #[doc = "Register block_ts `reset()`'s with value 0"]
            impl crate::ResetValue for super::BLOCK_TS {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `block_ts`"]
            pub type BLOCK_TS_R = crate::R<u32, u32>;
            #[doc = "Write proxy for field `block_ts`"]
            pub struct BLOCK_TS_W<'a> {
                w: &'a mut W,
            }
            impl<'a> BLOCK_TS_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x003f_ffff) | ((value as u64) & 0x003f_ffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:21 - Block transfer size"]
                #[inline(always)]
                pub fn block_ts(&self) -> BLOCK_TS_R {
                    BLOCK_TS_R::new((self.bits & 0x003f_ffff) as u32)
                }
            }
            impl W {
                #[doc = "Bits 0:21 - Block transfer size"]
                #[inline(always)]
                pub fn block_ts(&mut self) -> BLOCK_TS_W {
                    BLOCK_TS_W { w: self }
                }
            }
        }
        #[doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctl](ctl) module"]
        pub type CTL = crate::Reg<u64, _CTL>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _CTL;
        #[doc = "`read()` method returns [ctl::R](ctl::R) reader structure"]
        impl crate::Readable for CTL {}
        #[doc = "`write(|w| ..)` method takes [ctl::W](ctl::W) writer structure"]
        impl crate::Writable for CTL {}
        #[doc = "Control Register"]
        pub mod ctl {
            #[doc = "Reader of register ctl"]
            pub type R = crate::R<u64, super::CTL>;
            #[doc = "Writer for register ctl"]
            pub type W = crate::W<u64, super::CTL>;
            #[doc = "Register ctl `reset()`'s with value 0"]
            impl crate::ResetValue for super::CTL {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Source master select\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SMS_A {
                #[doc = "0: AXI master 1"]
                AXI_MASTER_1 = 0,
                #[doc = "1: AXI master 2"]
                AXI_MASTER_2 = 1,
            }
            impl From<SMS_A> for bool {
                #[inline(always)]
                fn from(variant: SMS_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `sms`"]
            pub type SMS_R = crate::R<bool, SMS_A>;
            impl SMS_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> SMS_A {
                    match self.bits {
                        false => SMS_A::AXI_MASTER_1,
                        true => SMS_A::AXI_MASTER_2,
                    }
                }
                #[doc = "Checks if the value of the field is `AXI_MASTER_1`"]
                #[inline(always)]
                pub fn is_axi_master_1(&self) -> bool {
                    *self == SMS_A::AXI_MASTER_1
                }
                #[doc = "Checks if the value of the field is `AXI_MASTER_2`"]
                #[inline(always)]
                pub fn is_axi_master_2(&self) -> bool {
                    *self == SMS_A::AXI_MASTER_2
                }
            }
            #[doc = "Write proxy for field `sms`"]
            pub struct SMS_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SMS_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: SMS_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "AXI master 1"]
                #[inline(always)]
                pub fn axi_master_1(self) -> &'a mut W {
                    self.variant(SMS_A::AXI_MASTER_1)
                }
                #[doc = "AXI master 2"]
                #[inline(always)]
                pub fn axi_master_2(self) -> &'a mut W {
                    self.variant(SMS_A::AXI_MASTER_2)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Destination master select"]
            pub type DMS_A = SMS_A;
            #[doc = "Reader of field `dms`"]
            pub type DMS_R = crate::R<bool, DMS_A>;
            #[doc = "Write proxy for field `dms`"]
            pub struct DMS_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DMS_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DMS_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "AXI master 1"]
                #[inline(always)]
                pub fn axi_master_1(self) -> &'a mut W {
                    self.variant(DMS_A::AXI_MASTER_1)
                }
                #[doc = "AXI master 2"]
                #[inline(always)]
                pub fn axi_master_2(self) -> &'a mut W {
                    self.variant(DMS_A::AXI_MASTER_2)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                    self.w
                }
            }
            #[doc = "Source address increment\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SINC_A {
                #[doc = "0: Increment address"]
                INCREMENT = 0,
                #[doc = "1: Don't increment address"]
                NOCHANGE = 1,
            }
            impl From<SINC_A> for bool {
                #[inline(always)]
                fn from(variant: SINC_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `sinc`"]
            pub type SINC_R = crate::R<bool, SINC_A>;
            impl SINC_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> SINC_A {
                    match self.bits {
                        false => SINC_A::INCREMENT,
                        true => SINC_A::NOCHANGE,
                    }
                }
                #[doc = "Checks if the value of the field is `INCREMENT`"]
                #[inline(always)]
                pub fn is_increment(&self) -> bool {
                    *self == SINC_A::INCREMENT
                }
                #[doc = "Checks if the value of the field is `NOCHANGE`"]
                #[inline(always)]
                pub fn is_nochange(&self) -> bool {
                    *self == SINC_A::NOCHANGE
                }
            }
            #[doc = "Write proxy for field `sinc`"]
            pub struct SINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SINC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: SINC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Increment address"]
                #[inline(always)]
                pub fn increment(self) -> &'a mut W {
                    self.variant(SINC_A::INCREMENT)
                }
                #[doc = "Don't increment address"]
                #[inline(always)]
                pub fn nochange(self) -> &'a mut W {
                    self.variant(SINC_A::NOCHANGE)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Destination address increment"]
            pub type DINC_A = SINC_A;
            #[doc = "Reader of field `dinc`"]
            pub type DINC_R = crate::R<bool, DINC_A>;
            #[doc = "Write proxy for field `dinc`"]
            pub struct DINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DINC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DINC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Increment address"]
                #[inline(always)]
                pub fn increment(self) -> &'a mut W {
                    self.variant(DINC_A::INCREMENT)
                }
                #[doc = "Don't increment address"]
                #[inline(always)]
                pub fn nochange(self) -> &'a mut W {
                    self.variant(DINC_A::NOCHANGE)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u64) & 0x01) << 6);
                    self.w
                }
            }
            #[doc = "Source transfer width\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum SRC_TR_WIDTH_A {
                #[doc = "0: 8 bits"]
                WIDTH_8 = 0,
                #[doc = "1: 16 bits"]
                WIDTH_16 = 1,
                #[doc = "2: 32 bits"]
                WIDTH_32 = 2,
                #[doc = "3: 64 bits"]
                WIDTH_64 = 3,
                #[doc = "4: 128 bits"]
                WIDTH_128 = 4,
                #[doc = "5: 256 bits"]
                WIDTH_256 = 5,
                #[doc = "6: 512 bits"]
                WIDTH_512 = 6,
            }
            impl From<SRC_TR_WIDTH_A> for u8 {
                #[inline(always)]
                fn from(variant: SRC_TR_WIDTH_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `src_tr_width`"]
            pub type SRC_TR_WIDTH_R = crate::R<u8, SRC_TR_WIDTH_A>;
            impl SRC_TR_WIDTH_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> crate::Variant<u8, SRC_TR_WIDTH_A> {
                    use crate::Variant::*;
                    match self.bits {
                        0 => Val(SRC_TR_WIDTH_A::WIDTH_8),
                        1 => Val(SRC_TR_WIDTH_A::WIDTH_16),
                        2 => Val(SRC_TR_WIDTH_A::WIDTH_32),
                        3 => Val(SRC_TR_WIDTH_A::WIDTH_64),
                        4 => Val(SRC_TR_WIDTH_A::WIDTH_128),
                        5 => Val(SRC_TR_WIDTH_A::WIDTH_256),
                        6 => Val(SRC_TR_WIDTH_A::WIDTH_512),
                        i => Res(i),
                    }
                }
                #[doc = "Checks if the value of the field is `WIDTH_8`"]
                #[inline(always)]
                pub fn is_width_8(&self) -> bool {
                    *self == SRC_TR_WIDTH_A::WIDTH_8
                }
                #[doc = "Checks if the value of the field is `WIDTH_16`"]
                #[inline(always)]
                pub fn is_width_16(&self) -> bool {
                    *self == SRC_TR_WIDTH_A::WIDTH_16
                }
                #[doc = "Checks if the value of the field is `WIDTH_32`"]
                #[inline(always)]
                pub fn is_width_32(&self) -> bool {
                    *self == SRC_TR_WIDTH_A::WIDTH_32
                }
                #[doc = "Checks if the value of the field is `WIDTH_64`"]
                #[inline(always)]
                pub fn is_width_64(&self) -> bool {
                    *self == SRC_TR_WIDTH_A::WIDTH_64
                }
                #[doc = "Checks if the value of the field is `WIDTH_128`"]
                #[inline(always)]
                pub fn is_width_128(&self) -> bool {
                    *self == SRC_TR_WIDTH_A::WIDTH_128
                }
                #[doc = "Checks if the value of the field is `WIDTH_256`"]
                #[inline(always)]
                pub fn is_width_256(&self) -> bool {
                    *self == SRC_TR_WIDTH_A::WIDTH_256
                }
                #[doc = "Checks if the value of the field is `WIDTH_512`"]
                #[inline(always)]
                pub fn is_width_512(&self) -> bool {
                    *self == SRC_TR_WIDTH_A::WIDTH_512
                }
            }
            #[doc = "Write proxy for field `src_tr_width`"]
            pub struct SRC_TR_WIDTH_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_TR_WIDTH_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: SRC_TR_WIDTH_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "8 bits"]
                #[inline(always)]
                pub fn width_8(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTH_A::WIDTH_8)
                }
                #[doc = "16 bits"]
                #[inline(always)]
                pub fn width_16(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTH_A::WIDTH_16)
                }
                #[doc = "32 bits"]
                #[inline(always)]
                pub fn width_32(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTH_A::WIDTH_32)
                }
                #[doc = "64 bits"]
                #[inline(always)]
                pub fn width_64(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTH_A::WIDTH_64)
                }
                #[doc = "128 bits"]
                #[inline(always)]
                pub fn width_128(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTH_A::WIDTH_128)
                }
                #[doc = "256 bits"]
                #[inline(always)]
                pub fn width_256(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTH_A::WIDTH_256)
                }
                #[doc = "512 bits"]
                #[inline(always)]
                pub fn width_512(self) -> &'a mut W {
                    self.variant(SRC_TR_WIDTH_A::WIDTH_512)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x07 << 8)) | (((value as u64) & 0x07) << 8);
                    self.w
                }
            }
            #[doc = "Destination transfer width"]
            pub type DST_TR_WIDTH_A = SRC_TR_WIDTH_A;
            #[doc = "Reader of field `dst_tr_width`"]
            pub type DST_TR_WIDTH_R = crate::R<u8, DST_TR_WIDTH_A>;
            #[doc = "Write proxy for field `dst_tr_width`"]
            pub struct DST_TR_WIDTH_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_TR_WIDTH_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DST_TR_WIDTH_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "8 bits"]
                #[inline(always)]
                pub fn width_8(self) -> &'a mut W {
                    self.variant(DST_TR_WIDTH_A::WIDTH_8)
                }
                #[doc = "16 bits"]
                #[inline(always)]
                pub fn width_16(self) -> &'a mut W {
                    self.variant(DST_TR_WIDTH_A::WIDTH_16)
                }
                #[doc = "32 bits"]
                #[inline(always)]
                pub fn width_32(self) -> &'a mut W {
                    self.variant(DST_TR_WIDTH_A::WIDTH_32)
                }
                #[doc = "64 bits"]
                #[inline(always)]
                pub fn width_64(self) -> &'a mut W {
                    self.variant(DST_TR_WIDTH_A::WIDTH_64)
                }
                #[doc = "128 bits"]
                #[inline(always)]
                pub fn width_128(self) -> &'a mut W {
                    self.variant(DST_TR_WIDTH_A::WIDTH_128)
                }
                #[doc = "256 bits"]
                #[inline(always)]
                pub fn width_256(self) -> &'a mut W {
                    self.variant(DST_TR_WIDTH_A::WIDTH_256)
                }
                #[doc = "512 bits"]
                #[inline(always)]
                pub fn width_512(self) -> &'a mut W {
                    self.variant(DST_TR_WIDTH_A::WIDTH_512)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x07 << 11)) | (((value as u64) & 0x07) << 11);
                    self.w
                }
            }
            #[doc = "Source burst transaction length\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum SRC_MSIZE_A {
                #[doc = "0: 1 data item"]
                LENGTH_1 = 0,
                #[doc = "1: 4 data items"]
                LENGTH_4 = 1,
                #[doc = "2: 8 data items"]
                LENGTH_8 = 2,
                #[doc = "3: 16 data items"]
                LENGTH_16 = 3,
                #[doc = "4: 32 data items"]
                LENGTH_32 = 4,
                #[doc = "5: 64 data items"]
                LENGTH_64 = 5,
                #[doc = "6: 128 data items"]
                LENGTH_128 = 6,
                #[doc = "7: 256 data items"]
                LENGTH_256 = 7,
                #[doc = "8: 512 data items"]
                LENGTH_512 = 8,
                #[doc = "9: 1024 data items"]
                LENGTH_1024 = 9,
            }
            impl From<SRC_MSIZE_A> for u8 {
                #[inline(always)]
                fn from(variant: SRC_MSIZE_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `src_msize`"]
            pub type SRC_MSIZE_R = crate::R<u8, SRC_MSIZE_A>;
            impl SRC_MSIZE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> crate::Variant<u8, SRC_MSIZE_A> {
                    use crate::Variant::*;
                    match self.bits {
                        0 => Val(SRC_MSIZE_A::LENGTH_1),
                        1 => Val(SRC_MSIZE_A::LENGTH_4),
                        2 => Val(SRC_MSIZE_A::LENGTH_8),
                        3 => Val(SRC_MSIZE_A::LENGTH_16),
                        4 => Val(SRC_MSIZE_A::LENGTH_32),
                        5 => Val(SRC_MSIZE_A::LENGTH_64),
                        6 => Val(SRC_MSIZE_A::LENGTH_128),
                        7 => Val(SRC_MSIZE_A::LENGTH_256),
                        8 => Val(SRC_MSIZE_A::LENGTH_512),
                        9 => Val(SRC_MSIZE_A::LENGTH_1024),
                        i => Res(i),
                    }
                }
                #[doc = "Checks if the value of the field is `LENGTH_1`"]
                #[inline(always)]
                pub fn is_length_1(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_1
                }
                #[doc = "Checks if the value of the field is `LENGTH_4`"]
                #[inline(always)]
                pub fn is_length_4(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_4
                }
                #[doc = "Checks if the value of the field is `LENGTH_8`"]
                #[inline(always)]
                pub fn is_length_8(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_8
                }
                #[doc = "Checks if the value of the field is `LENGTH_16`"]
                #[inline(always)]
                pub fn is_length_16(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_16
                }
                #[doc = "Checks if the value of the field is `LENGTH_32`"]
                #[inline(always)]
                pub fn is_length_32(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_32
                }
                #[doc = "Checks if the value of the field is `LENGTH_64`"]
                #[inline(always)]
                pub fn is_length_64(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_64
                }
                #[doc = "Checks if the value of the field is `LENGTH_128`"]
                #[inline(always)]
                pub fn is_length_128(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_128
                }
                #[doc = "Checks if the value of the field is `LENGTH_256`"]
                #[inline(always)]
                pub fn is_length_256(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_256
                }
                #[doc = "Checks if the value of the field is `LENGTH_512`"]
                #[inline(always)]
                pub fn is_length_512(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_512
                }
                #[doc = "Checks if the value of the field is `LENGTH_1024`"]
                #[inline(always)]
                pub fn is_length_1024(&self) -> bool {
                    *self == SRC_MSIZE_A::LENGTH_1024
                }
            }
            #[doc = "Write proxy for field `src_msize`"]
            pub struct SRC_MSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_MSIZE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: SRC_MSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "1 data item"]
                #[inline(always)]
                pub fn length_1(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_1)
                }
                #[doc = "4 data items"]
                #[inline(always)]
                pub fn length_4(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_4)
                }
                #[doc = "8 data items"]
                #[inline(always)]
                pub fn length_8(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_8)
                }
                #[doc = "16 data items"]
                #[inline(always)]
                pub fn length_16(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_16)
                }
                #[doc = "32 data items"]
                #[inline(always)]
                pub fn length_32(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_32)
                }
                #[doc = "64 data items"]
                #[inline(always)]
                pub fn length_64(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_64)
                }
                #[doc = "128 data items"]
                #[inline(always)]
                pub fn length_128(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_128)
                }
                #[doc = "256 data items"]
                #[inline(always)]
                pub fn length_256(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_256)
                }
                #[doc = "512 data items"]
                #[inline(always)]
                pub fn length_512(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_512)
                }
                #[doc = "1024 data items"]
                #[inline(always)]
                pub fn length_1024(self) -> &'a mut W {
                    self.variant(SRC_MSIZE_A::LENGTH_1024)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x0f << 14)) | (((value as u64) & 0x0f) << 14);
                    self.w
                }
            }
            #[doc = "Destination burst transaction length"]
            pub type DST_MSIZE_A = SRC_MSIZE_A;
            #[doc = "Reader of field `dst_msize`"]
            pub type DST_MSIZE_R = crate::R<u8, DST_MSIZE_A>;
            #[doc = "Write proxy for field `dst_msize`"]
            pub struct DST_MSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_MSIZE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DST_MSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "1 data item"]
                #[inline(always)]
                pub fn length_1(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_1)
                }
                #[doc = "4 data items"]
                #[inline(always)]
                pub fn length_4(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_4)
                }
                #[doc = "8 data items"]
                #[inline(always)]
                pub fn length_8(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_8)
                }
                #[doc = "16 data items"]
                #[inline(always)]
                pub fn length_16(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_16)
                }
                #[doc = "32 data items"]
                #[inline(always)]
                pub fn length_32(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_32)
                }
                #[doc = "64 data items"]
                #[inline(always)]
                pub fn length_64(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_64)
                }
                #[doc = "128 data items"]
                #[inline(always)]
                pub fn length_128(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_128)
                }
                #[doc = "256 data items"]
                #[inline(always)]
                pub fn length_256(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_256)
                }
                #[doc = "512 data items"]
                #[inline(always)]
                pub fn length_512(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_512)
                }
                #[doc = "1024 data items"]
                #[inline(always)]
                pub fn length_1024(self) -> &'a mut W {
                    self.variant(DST_MSIZE_A::LENGTH_1024)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x0f << 18)) | (((value as u64) & 0x0f) << 18);
                    self.w
                }
            }
            #[doc = "Reader of field `nonposted_lastwrite_en`"]
            pub type NONPOSTED_LASTWRITE_EN_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `nonposted_lastwrite_en`"]
            pub struct NONPOSTED_LASTWRITE_EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> NONPOSTED_LASTWRITE_EN_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u64) & 0x01) << 30);
                    self.w
                }
            }
            #[doc = "Reader of field `arlen_en`"]
            pub type ARLEN_EN_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `arlen_en`"]
            pub struct ARLEN_EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> ARLEN_EN_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 38)) | (((value as u64) & 0x01) << 38);
                    self.w
                }
            }
            #[doc = "Reader of field `arlen`"]
            pub type ARLEN_R = crate::R<u8, u8>;
            #[doc = "Write proxy for field `arlen`"]
            pub struct ARLEN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> ARLEN_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0xff << 39)) | (((value as u64) & 0xff) << 39);
                    self.w
                }
            }
            #[doc = "Reader of field `awlen_en`"]
            pub type AWLEN_EN_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `awlen_en`"]
            pub struct AWLEN_EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> AWLEN_EN_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 47)) | (((value as u64) & 0x01) << 47);
                    self.w
                }
            }
            #[doc = "Reader of field `awlen`"]
            pub type AWLEN_R = crate::R<u8, u8>;
            #[doc = "Write proxy for field `awlen`"]
            pub struct AWLEN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> AWLEN_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0xff << 48)) | (((value as u64) & 0xff) << 48);
                    self.w
                }
            }
            #[doc = "Reader of field `src_stat_en`"]
            pub type SRC_STAT_EN_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_stat_en`"]
            pub struct SRC_STAT_EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_STAT_EN_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 56)) | (((value as u64) & 0x01) << 56);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_stat_en`"]
            pub type DST_STAT_EN_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_stat_en`"]
            pub struct DST_STAT_EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_STAT_EN_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 57)) | (((value as u64) & 0x01) << 57);
                    self.w
                }
            }
            #[doc = "Reader of field `ioc_blktfr`"]
            pub type IOC_BLKTFR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `ioc_blktfr`"]
            pub struct IOC_BLKTFR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> IOC_BLKTFR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 58)) | (((value as u64) & 0x01) << 58);
                    self.w
                }
            }
            #[doc = "Reader of field `shadowreg_or_lli_last`"]
            pub type SHADOWREG_OR_LLI_LAST_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `shadowreg_or_lli_last`"]
            pub struct SHADOWREG_OR_LLI_LAST_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SHADOWREG_OR_LLI_LAST_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 62)) | (((value as u64) & 0x01) << 62);
                    self.w
                }
            }
            #[doc = "Reader of field `shadowreg_or_lli_valid`"]
            pub type SHADOWREG_OR_LLI_VALID_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `shadowreg_or_lli_valid`"]
            pub struct SHADOWREG_OR_LLI_VALID_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SHADOWREG_OR_LLI_VALID_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 63)) | (((value as u64) & 0x01) << 63);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Source master select"]
                #[inline(always)]
                pub fn sms(&self) -> SMS_R {
                    SMS_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 2 - Destination master select"]
                #[inline(always)]
                pub fn dms(&self) -> DMS_R {
                    DMS_R::new(((self.bits >> 2) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Source address increment"]
                #[inline(always)]
                pub fn sinc(&self) -> SINC_R {
                    SINC_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 6 - Destination address increment"]
                #[inline(always)]
                pub fn dinc(&self) -> DINC_R {
                    DINC_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                #[doc = "Bits 8:10 - Source transfer width"]
                #[inline(always)]
                pub fn src_tr_width(&self) -> SRC_TR_WIDTH_R {
                    SRC_TR_WIDTH_R::new(((self.bits >> 8) & 0x07) as u8)
                }
                #[doc = "Bits 11:13 - Destination transfer width"]
                #[inline(always)]
                pub fn dst_tr_width(&self) -> DST_TR_WIDTH_R {
                    DST_TR_WIDTH_R::new(((self.bits >> 11) & 0x07) as u8)
                }
                #[doc = "Bits 14:17 - Source burst transaction length"]
                #[inline(always)]
                pub fn src_msize(&self) -> SRC_MSIZE_R {
                    SRC_MSIZE_R::new(((self.bits >> 14) & 0x0f) as u8)
                }
                #[doc = "Bits 18:21 - Destination burst transaction length"]
                #[inline(always)]
                pub fn dst_msize(&self) -> DST_MSIZE_R {
                    DST_MSIZE_R::new(((self.bits >> 18) & 0x0f) as u8)
                }
                #[doc = "Bit 30 - Non Posted Last Write Enable (posted writes may be used till the end of the block)"]
                #[inline(always)]
                pub fn nonposted_lastwrite_en(&self) -> NONPOSTED_LASTWRITE_EN_R {
                    NONPOSTED_LASTWRITE_EN_R::new(((self.bits >> 30) & 0x01) != 0)
                }
                #[doc = "Bit 38 - Source burst length enable"]
                #[inline(always)]
                pub fn arlen_en(&self) -> ARLEN_EN_R {
                    ARLEN_EN_R::new(((self.bits >> 38) & 0x01) != 0)
                }
                #[doc = "Bits 39:46 - Source burst length"]
                #[inline(always)]
                pub fn arlen(&self) -> ARLEN_R {
                    ARLEN_R::new(((self.bits >> 39) & 0xff) as u8)
                }
                #[doc = "Bit 47 - Destination burst length enable"]
                #[inline(always)]
                pub fn awlen_en(&self) -> AWLEN_EN_R {
                    AWLEN_EN_R::new(((self.bits >> 47) & 0x01) != 0)
                }
                #[doc = "Bits 48:55 - Destination burst length"]
                #[inline(always)]
                pub fn awlen(&self) -> AWLEN_R {
                    AWLEN_R::new(((self.bits >> 48) & 0xff) as u8)
                }
                #[doc = "Bit 56 - Source status enable"]
                #[inline(always)]
                pub fn src_stat_en(&self) -> SRC_STAT_EN_R {
                    SRC_STAT_EN_R::new(((self.bits >> 56) & 0x01) != 0)
                }
                #[doc = "Bit 57 - Destination status enable"]
                #[inline(always)]
                pub fn dst_stat_en(&self) -> DST_STAT_EN_R {
                    DST_STAT_EN_R::new(((self.bits >> 57) & 0x01) != 0)
                }
                #[doc = "Bit 58 - Interrupt completion of block transfer"]
                #[inline(always)]
                pub fn ioc_blktfr(&self) -> IOC_BLKTFR_R {
                    IOC_BLKTFR_R::new(((self.bits >> 58) & 0x01) != 0)
                }
                #[doc = "Bit 62 - Last shadow linked list item (indicates shadowreg/LLI content is the last one)"]
                #[inline(always)]
                pub fn shadowreg_or_lli_last(&self) -> SHADOWREG_OR_LLI_LAST_R {
                    SHADOWREG_OR_LLI_LAST_R::new(((self.bits >> 62) & 0x01) != 0)
                }
                #[doc = "Bit 63 - last shadow linked list item valid (indicate shadowreg/LLI content is valid)"]
                #[inline(always)]
                pub fn shadowreg_or_lli_valid(&self) -> SHADOWREG_OR_LLI_VALID_R {
                    SHADOWREG_OR_LLI_VALID_R::new(((self.bits >> 63) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Source master select"]
                #[inline(always)]
                pub fn sms(&mut self) -> SMS_W {
                    SMS_W { w: self }
                }
                #[doc = "Bit 2 - Destination master select"]
                #[inline(always)]
                pub fn dms(&mut self) -> DMS_W {
                    DMS_W { w: self }
                }
                #[doc = "Bit 4 - Source address increment"]
                #[inline(always)]
                pub fn sinc(&mut self) -> SINC_W {
                    SINC_W { w: self }
                }
                #[doc = "Bit 6 - Destination address increment"]
                #[inline(always)]
                pub fn dinc(&mut self) -> DINC_W {
                    DINC_W { w: self }
                }
                #[doc = "Bits 8:10 - Source transfer width"]
                #[inline(always)]
                pub fn src_tr_width(&mut self) -> SRC_TR_WIDTH_W {
                    SRC_TR_WIDTH_W { w: self }
                }
                #[doc = "Bits 11:13 - Destination transfer width"]
                #[inline(always)]
                pub fn dst_tr_width(&mut self) -> DST_TR_WIDTH_W {
                    DST_TR_WIDTH_W { w: self }
                }
                #[doc = "Bits 14:17 - Source burst transaction length"]
                #[inline(always)]
                pub fn src_msize(&mut self) -> SRC_MSIZE_W {
                    SRC_MSIZE_W { w: self }
                }
                #[doc = "Bits 18:21 - Destination burst transaction length"]
                #[inline(always)]
                pub fn dst_msize(&mut self) -> DST_MSIZE_W {
                    DST_MSIZE_W { w: self }
                }
                #[doc = "Bit 30 - Non Posted Last Write Enable (posted writes may be used till the end of the block)"]
                #[inline(always)]
                pub fn nonposted_lastwrite_en(&mut self) -> NONPOSTED_LASTWRITE_EN_W {
                    NONPOSTED_LASTWRITE_EN_W { w: self }
                }
                #[doc = "Bit 38 - Source burst length enable"]
                #[inline(always)]
                pub fn arlen_en(&mut self) -> ARLEN_EN_W {
                    ARLEN_EN_W { w: self }
                }
                #[doc = "Bits 39:46 - Source burst length"]
                #[inline(always)]
                pub fn arlen(&mut self) -> ARLEN_W {
                    ARLEN_W { w: self }
                }
                #[doc = "Bit 47 - Destination burst length enable"]
                #[inline(always)]
                pub fn awlen_en(&mut self) -> AWLEN_EN_W {
                    AWLEN_EN_W { w: self }
                }
                #[doc = "Bits 48:55 - Destination burst length"]
                #[inline(always)]
                pub fn awlen(&mut self) -> AWLEN_W {
                    AWLEN_W { w: self }
                }
                #[doc = "Bit 56 - Source status enable"]
                #[inline(always)]
                pub fn src_stat_en(&mut self) -> SRC_STAT_EN_W {
                    SRC_STAT_EN_W { w: self }
                }
                #[doc = "Bit 57 - Destination status enable"]
                #[inline(always)]
                pub fn dst_stat_en(&mut self) -> DST_STAT_EN_W {
                    DST_STAT_EN_W { w: self }
                }
                #[doc = "Bit 58 - Interrupt completion of block transfer"]
                #[inline(always)]
                pub fn ioc_blktfr(&mut self) -> IOC_BLKTFR_W {
                    IOC_BLKTFR_W { w: self }
                }
                #[doc = "Bit 62 - Last shadow linked list item (indicates shadowreg/LLI content is the last one)"]
                #[inline(always)]
                pub fn shadowreg_or_lli_last(&mut self) -> SHADOWREG_OR_LLI_LAST_W {
                    SHADOWREG_OR_LLI_LAST_W { w: self }
                }
                #[doc = "Bit 63 - last shadow linked list item valid (indicate shadowreg/LLI content is valid)"]
                #[inline(always)]
                pub fn shadowreg_or_lli_valid(&mut self) -> SHADOWREG_OR_LLI_VALID_W {
                    SHADOWREG_OR_LLI_VALID_W { w: self }
                }
            }
        }
        #[doc = "Configure Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub type CFG = crate::Reg<u64, _CFG>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _CFG;
        #[doc = "`read()` method returns [cfg::R](cfg::R) reader structure"]
        impl crate::Readable for CFG {}
        #[doc = "`write(|w| ..)` method takes [cfg::W](cfg::W) writer structure"]
        impl crate::Writable for CFG {}
        #[doc = "Configure Register"]
        pub mod cfg {
            #[doc = "Reader of register cfg"]
            pub type R = crate::R<u64, super::CFG>;
            #[doc = "Writer for register cfg"]
            pub type W = crate::W<u64, super::CFG>;
            #[doc = "Register cfg `reset()`'s with value 0"]
            impl crate::ResetValue for super::CFG {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Source multi-block transfer type\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum SRC_MULTBLK_TYPE_A {
                #[doc = "0: Continuous multi-block type"]
                CONTIGUOUS = 0,
                #[doc = "1: Reload multi-block type"]
                RELOAD = 1,
                #[doc = "2: Shadow register based multi-block type"]
                SHADOW_REGISTER = 2,
                #[doc = "3: Linked list based multi-block type"]
                LINKED_LIST = 3,
            }
            impl From<SRC_MULTBLK_TYPE_A> for u8 {
                #[inline(always)]
                fn from(variant: SRC_MULTBLK_TYPE_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `src_multblk_type`"]
            pub type SRC_MULTBLK_TYPE_R = crate::R<u8, SRC_MULTBLK_TYPE_A>;
            impl SRC_MULTBLK_TYPE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> SRC_MULTBLK_TYPE_A {
                    match self.bits {
                        0 => SRC_MULTBLK_TYPE_A::CONTIGUOUS,
                        1 => SRC_MULTBLK_TYPE_A::RELOAD,
                        2 => SRC_MULTBLK_TYPE_A::SHADOW_REGISTER,
                        3 => SRC_MULTBLK_TYPE_A::LINKED_LIST,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `CONTIGUOUS`"]
                #[inline(always)]
                pub fn is_contiguous(&self) -> bool {
                    *self == SRC_MULTBLK_TYPE_A::CONTIGUOUS
                }
                #[doc = "Checks if the value of the field is `RELOAD`"]
                #[inline(always)]
                pub fn is_reload(&self) -> bool {
                    *self == SRC_MULTBLK_TYPE_A::RELOAD
                }
                #[doc = "Checks if the value of the field is `SHADOW_REGISTER`"]
                #[inline(always)]
                pub fn is_shadow_register(&self) -> bool {
                    *self == SRC_MULTBLK_TYPE_A::SHADOW_REGISTER
                }
                #[doc = "Checks if the value of the field is `LINKED_LIST`"]
                #[inline(always)]
                pub fn is_linked_list(&self) -> bool {
                    *self == SRC_MULTBLK_TYPE_A::LINKED_LIST
                }
            }
            #[doc = "Write proxy for field `src_multblk_type`"]
            pub struct SRC_MULTBLK_TYPE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_MULTBLK_TYPE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: SRC_MULTBLK_TYPE_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Continuous multi-block type"]
                #[inline(always)]
                pub fn contiguous(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPE_A::CONTIGUOUS)
                }
                #[doc = "Reload multi-block type"]
                #[inline(always)]
                pub fn reload(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPE_A::RELOAD)
                }
                #[doc = "Shadow register based multi-block type"]
                #[inline(always)]
                pub fn shadow_register(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPE_A::SHADOW_REGISTER)
                }
                #[doc = "Linked list based multi-block type"]
                #[inline(always)]
                pub fn linked_list(self) -> &'a mut W {
                    self.variant(SRC_MULTBLK_TYPE_A::LINKED_LIST)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x03) | ((value as u64) & 0x03);
                    self.w
                }
            }
            #[doc = "Destination multi-block transfer type"]
            pub type DST_MULTBLK_TYPE_A = SRC_MULTBLK_TYPE_A;
            #[doc = "Reader of field `dst_multblk_type`"]
            pub type DST_MULTBLK_TYPE_R = crate::R<u8, DST_MULTBLK_TYPE_A>;
            #[doc = "Write proxy for field `dst_multblk_type`"]
            pub struct DST_MULTBLK_TYPE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_MULTBLK_TYPE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DST_MULTBLK_TYPE_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Continuous multi-block type"]
                #[inline(always)]
                pub fn contiguous(self) -> &'a mut W {
                    self.variant(DST_MULTBLK_TYPE_A::CONTIGUOUS)
                }
                #[doc = "Reload multi-block type"]
                #[inline(always)]
                pub fn reload(self) -> &'a mut W {
                    self.variant(DST_MULTBLK_TYPE_A::RELOAD)
                }
                #[doc = "Shadow register based multi-block type"]
                #[inline(always)]
                pub fn shadow_register(self) -> &'a mut W {
                    self.variant(DST_MULTBLK_TYPE_A::SHADOW_REGISTER)
                }
                #[doc = "Linked list based multi-block type"]
                #[inline(always)]
                pub fn linked_list(self) -> &'a mut W {
                    self.variant(DST_MULTBLK_TYPE_A::LINKED_LIST)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u64) & 0x03) << 2);
                    self.w
                }
            }
            #[doc = "Transfer type and flow control\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum TT_FC_A {
                #[doc = "0: Transfer memory to memory and flow controller is DMAC"]
                MEM2MEM_DMA = 0,
                #[doc = "1: Transfer memory to peripheral and flow controller is DMAC"]
                MEM2PRF_DMA = 1,
                #[doc = "2: Transfer peripheral to memory and flow controller is DMAC"]
                PRF2MEM_DMA = 2,
                #[doc = "3: Transfer peripheral to peripheral and flow controller is DMAC"]
                PRF2PRF_DMA = 3,
                #[doc = "4: Transfer peripheral to memory and flow controller is source peripheral"]
                PRF2MEM_PRF = 4,
                #[doc = "5: Transfer peripheral to peripheral and flow controller is source peripheral"]
                PRF2PRF_SRCPRF = 5,
                #[doc = "6: Transfer memory to peripheral and flow controller is destination peripheral"]
                MEM2PRF_PRF = 6,
                #[doc = "7: Transfer peripheral to peripheral and flow controller is destination peripheral"]
                PRF2PRF_DSTPRF = 7,
            }
            impl From<TT_FC_A> for u8 {
                #[inline(always)]
                fn from(variant: TT_FC_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `tt_fc`"]
            pub type TT_FC_R = crate::R<u8, TT_FC_A>;
            impl TT_FC_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> TT_FC_A {
                    match self.bits {
                        0 => TT_FC_A::MEM2MEM_DMA,
                        1 => TT_FC_A::MEM2PRF_DMA,
                        2 => TT_FC_A::PRF2MEM_DMA,
                        3 => TT_FC_A::PRF2PRF_DMA,
                        4 => TT_FC_A::PRF2MEM_PRF,
                        5 => TT_FC_A::PRF2PRF_SRCPRF,
                        6 => TT_FC_A::MEM2PRF_PRF,
                        7 => TT_FC_A::PRF2PRF_DSTPRF,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `MEM2MEM_DMA`"]
                #[inline(always)]
                pub fn is_mem2mem_dma(&self) -> bool {
                    *self == TT_FC_A::MEM2MEM_DMA
                }
                #[doc = "Checks if the value of the field is `MEM2PRF_DMA`"]
                #[inline(always)]
                pub fn is_mem2prf_dma(&self) -> bool {
                    *self == TT_FC_A::MEM2PRF_DMA
                }
                #[doc = "Checks if the value of the field is `PRF2MEM_DMA`"]
                #[inline(always)]
                pub fn is_prf2mem_dma(&self) -> bool {
                    *self == TT_FC_A::PRF2MEM_DMA
                }
                #[doc = "Checks if the value of the field is `PRF2PRF_DMA`"]
                #[inline(always)]
                pub fn is_prf2prf_dma(&self) -> bool {
                    *self == TT_FC_A::PRF2PRF_DMA
                }
                #[doc = "Checks if the value of the field is `PRF2MEM_PRF`"]
                #[inline(always)]
                pub fn is_prf2mem_prf(&self) -> bool {
                    *self == TT_FC_A::PRF2MEM_PRF
                }
                #[doc = "Checks if the value of the field is `PRF2PRF_SRCPRF`"]
                #[inline(always)]
                pub fn is_prf2prf_srcprf(&self) -> bool {
                    *self == TT_FC_A::PRF2PRF_SRCPRF
                }
                #[doc = "Checks if the value of the field is `MEM2PRF_PRF`"]
                #[inline(always)]
                pub fn is_mem2prf_prf(&self) -> bool {
                    *self == TT_FC_A::MEM2PRF_PRF
                }
                #[doc = "Checks if the value of the field is `PRF2PRF_DSTPRF`"]
                #[inline(always)]
                pub fn is_prf2prf_dstprf(&self) -> bool {
                    *self == TT_FC_A::PRF2PRF_DSTPRF
                }
            }
            #[doc = "Write proxy for field `tt_fc`"]
            pub struct TT_FC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TT_FC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: TT_FC_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Transfer memory to memory and flow controller is DMAC"]
                #[inline(always)]
                pub fn mem2mem_dma(self) -> &'a mut W {
                    self.variant(TT_FC_A::MEM2MEM_DMA)
                }
                #[doc = "Transfer memory to peripheral and flow controller is DMAC"]
                #[inline(always)]
                pub fn mem2prf_dma(self) -> &'a mut W {
                    self.variant(TT_FC_A::MEM2PRF_DMA)
                }
                #[doc = "Transfer peripheral to memory and flow controller is DMAC"]
                #[inline(always)]
                pub fn prf2mem_dma(self) -> &'a mut W {
                    self.variant(TT_FC_A::PRF2MEM_DMA)
                }
                #[doc = "Transfer peripheral to peripheral and flow controller is DMAC"]
                #[inline(always)]
                pub fn prf2prf_dma(self) -> &'a mut W {
                    self.variant(TT_FC_A::PRF2PRF_DMA)
                }
                #[doc = "Transfer peripheral to memory and flow controller is source peripheral"]
                #[inline(always)]
                pub fn prf2mem_prf(self) -> &'a mut W {
                    self.variant(TT_FC_A::PRF2MEM_PRF)
                }
                #[doc = "Transfer peripheral to peripheral and flow controller is source peripheral"]
                #[inline(always)]
                pub fn prf2prf_srcprf(self) -> &'a mut W {
                    self.variant(TT_FC_A::PRF2PRF_SRCPRF)
                }
                #[doc = "Transfer memory to peripheral and flow controller is destination peripheral"]
                #[inline(always)]
                pub fn mem2prf_prf(self) -> &'a mut W {
                    self.variant(TT_FC_A::MEM2PRF_PRF)
                }
                #[doc = "Transfer peripheral to peripheral and flow controller is destination peripheral"]
                #[inline(always)]
                pub fn prf2prf_dstprf(self) -> &'a mut W {
                    self.variant(TT_FC_A::PRF2PRF_DSTPRF)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x07 << 32)) | (((value as u64) & 0x07) << 32);
                    self.w
                }
            }
            #[doc = "Source software or hardware handshaking select\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum HS_SEL_SRC_A {
                #[doc = "0: Hardware handshaking is used"]
                HARDWARE = 0,
                #[doc = "1: Software handshaking is used"]
                SOFTWARE = 1,
            }
            impl From<HS_SEL_SRC_A> for bool {
                #[inline(always)]
                fn from(variant: HS_SEL_SRC_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `hs_sel_src`"]
            pub type HS_SEL_SRC_R = crate::R<bool, HS_SEL_SRC_A>;
            impl HS_SEL_SRC_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> HS_SEL_SRC_A {
                    match self.bits {
                        false => HS_SEL_SRC_A::HARDWARE,
                        true => HS_SEL_SRC_A::SOFTWARE,
                    }
                }
                #[doc = "Checks if the value of the field is `HARDWARE`"]
                #[inline(always)]
                pub fn is_hardware(&self) -> bool {
                    *self == HS_SEL_SRC_A::HARDWARE
                }
                #[doc = "Checks if the value of the field is `SOFTWARE`"]
                #[inline(always)]
                pub fn is_software(&self) -> bool {
                    *self == HS_SEL_SRC_A::SOFTWARE
                }
            }
            #[doc = "Write proxy for field `hs_sel_src`"]
            pub struct HS_SEL_SRC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> HS_SEL_SRC_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: HS_SEL_SRC_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Hardware handshaking is used"]
                #[inline(always)]
                pub fn hardware(self) -> &'a mut W {
                    self.variant(HS_SEL_SRC_A::HARDWARE)
                }
                #[doc = "Software handshaking is used"]
                #[inline(always)]
                pub fn software(self) -> &'a mut W {
                    self.variant(HS_SEL_SRC_A::SOFTWARE)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 35)) | (((value as u64) & 0x01) << 35);
                    self.w
                }
            }
            #[doc = "Destination software or hardware handshaking select"]
            pub type HS_SEL_DST_A = HS_SEL_SRC_A;
            #[doc = "Reader of field `hs_sel_dst`"]
            pub type HS_SEL_DST_R = crate::R<bool, HS_SEL_DST_A>;
            #[doc = "Write proxy for field `hs_sel_dst`"]
            pub struct HS_SEL_DST_W<'a> {
                w: &'a mut W,
            }
            impl<'a> HS_SEL_DST_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: HS_SEL_DST_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Hardware handshaking is used"]
                #[inline(always)]
                pub fn hardware(self) -> &'a mut W {
                    self.variant(HS_SEL_DST_A::HARDWARE)
                }
                #[doc = "Software handshaking is used"]
                #[inline(always)]
                pub fn software(self) -> &'a mut W {
                    self.variant(HS_SEL_DST_A::SOFTWARE)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 36)) | (((value as u64) & 0x01) << 36);
                    self.w
                }
            }
            #[doc = "Source hardware handshaking interface polarity\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum SRC_HWHS_POL_A {
                #[doc = "0: Active high"]
                ACTIVE_HIGH = 0,
                #[doc = "1: Active low"]
                ACTIVE_LOW = 1,
            }
            impl From<SRC_HWHS_POL_A> for bool {
                #[inline(always)]
                fn from(variant: SRC_HWHS_POL_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `src_hwhs_pol`"]
            pub type SRC_HWHS_POL_R = crate::R<bool, SRC_HWHS_POL_A>;
            impl SRC_HWHS_POL_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> SRC_HWHS_POL_A {
                    match self.bits {
                        false => SRC_HWHS_POL_A::ACTIVE_HIGH,
                        true => SRC_HWHS_POL_A::ACTIVE_LOW,
                    }
                }
                #[doc = "Checks if the value of the field is `ACTIVE_HIGH`"]
                #[inline(always)]
                pub fn is_active_high(&self) -> bool {
                    *self == SRC_HWHS_POL_A::ACTIVE_HIGH
                }
                #[doc = "Checks if the value of the field is `ACTIVE_LOW`"]
                #[inline(always)]
                pub fn is_active_low(&self) -> bool {
                    *self == SRC_HWHS_POL_A::ACTIVE_LOW
                }
            }
            #[doc = "Write proxy for field `src_hwhs_pol`"]
            pub struct SRC_HWHS_POL_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_HWHS_POL_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: SRC_HWHS_POL_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Active high"]
                #[inline(always)]
                pub fn active_high(self) -> &'a mut W {
                    self.variant(SRC_HWHS_POL_A::ACTIVE_HIGH)
                }
                #[doc = "Active low"]
                #[inline(always)]
                pub fn active_low(self) -> &'a mut W {
                    self.variant(SRC_HWHS_POL_A::ACTIVE_LOW)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 37)) | (((value as u64) & 0x01) << 37);
                    self.w
                }
            }
            #[doc = "Destination hardware handshaking interface polarity"]
            pub type DST_HWHS_POL_A = SRC_HWHS_POL_A;
            #[doc = "Reader of field `dst_hwhs_pol`"]
            pub type DST_HWHS_POL_R = crate::R<bool, DST_HWHS_POL_A>;
            #[doc = "Write proxy for field `dst_hwhs_pol`"]
            pub struct DST_HWHS_POL_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_HWHS_POL_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: DST_HWHS_POL_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Active high"]
                #[inline(always)]
                pub fn active_high(self) -> &'a mut W {
                    self.variant(DST_HWHS_POL_A::ACTIVE_HIGH)
                }
                #[doc = "Active low"]
                #[inline(always)]
                pub fn active_low(self) -> &'a mut W {
                    self.variant(DST_HWHS_POL_A::ACTIVE_LOW)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 38)) | (((value as u64) & 0x01) << 38);
                    self.w
                }
            }
            #[doc = "Reader of field `src_per`"]
            pub type SRC_PER_R = crate::R<u8, u8>;
            #[doc = "Write proxy for field `src_per`"]
            pub struct SRC_PER_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_PER_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x0f << 39)) | (((value as u64) & 0x0f) << 39);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_per`"]
            pub type DST_PER_R = crate::R<u8, u8>;
            #[doc = "Write proxy for field `dst_per`"]
            pub struct DST_PER_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_PER_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x0f << 44)) | (((value as u64) & 0x0f) << 44);
                    self.w
                }
            }
            #[doc = "Reader of field `ch_prior`"]
            pub type CH_PRIOR_R = crate::R<u8, u8>;
            #[doc = "Write proxy for field `ch_prior`"]
            pub struct CH_PRIOR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> CH_PRIOR_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x07 << 49)) | (((value as u64) & 0x07) << 49);
                    self.w
                }
            }
            #[doc = "Reader of field `lock_ch`"]
            pub type LOCK_CH_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lock_ch`"]
            pub struct LOCK_CH_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LOCK_CH_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 52)) | (((value as u64) & 0x01) << 52);
                    self.w
                }
            }
            #[doc = "Channel lock level\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum LOCK_CH_L_A {
                #[doc = "0: Duration of channel is locked for entire DMA transfer"]
                DMA_TRANSFER = 0,
                #[doc = "1: Duration of channel is locked for current block transfer"]
                BLOCK_TRANSFER = 1,
                #[doc = "2: Duration of channel is locked for current transaction"]
                TRANSACTION = 2,
            }
            impl From<LOCK_CH_L_A> for u8 {
                #[inline(always)]
                fn from(variant: LOCK_CH_L_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `lock_ch_l`"]
            pub type LOCK_CH_L_R = crate::R<u8, LOCK_CH_L_A>;
            impl LOCK_CH_L_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> crate::Variant<u8, LOCK_CH_L_A> {
                    use crate::Variant::*;
                    match self.bits {
                        0 => Val(LOCK_CH_L_A::DMA_TRANSFER),
                        1 => Val(LOCK_CH_L_A::BLOCK_TRANSFER),
                        2 => Val(LOCK_CH_L_A::TRANSACTION),
                        i => Res(i),
                    }
                }
                #[doc = "Checks if the value of the field is `DMA_TRANSFER`"]
                #[inline(always)]
                pub fn is_dma_transfer(&self) -> bool {
                    *self == LOCK_CH_L_A::DMA_TRANSFER
                }
                #[doc = "Checks if the value of the field is `BLOCK_TRANSFER`"]
                #[inline(always)]
                pub fn is_block_transfer(&self) -> bool {
                    *self == LOCK_CH_L_A::BLOCK_TRANSFER
                }
                #[doc = "Checks if the value of the field is `TRANSACTION`"]
                #[inline(always)]
                pub fn is_transaction(&self) -> bool {
                    *self == LOCK_CH_L_A::TRANSACTION
                }
            }
            #[doc = "Write proxy for field `lock_ch_l`"]
            pub struct LOCK_CH_L_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LOCK_CH_L_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: LOCK_CH_L_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "Duration of channel is locked for entire DMA transfer"]
                #[inline(always)]
                pub fn dma_transfer(self) -> &'a mut W {
                    self.variant(LOCK_CH_L_A::DMA_TRANSFER)
                }
                #[doc = "Duration of channel is locked for current block transfer"]
                #[inline(always)]
                pub fn block_transfer(self) -> &'a mut W {
                    self.variant(LOCK_CH_L_A::BLOCK_TRANSFER)
                }
                #[doc = "Duration of channel is locked for current transaction"]
                #[inline(always)]
                pub fn transaction(self) -> &'a mut W {
                    self.variant(LOCK_CH_L_A::TRANSACTION)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 53)) | (((value as u64) & 0x03) << 53);
                    self.w
                }
            }
            #[doc = "Reader of field `src_osr_lmt`"]
            pub type SRC_OSR_LMT_R = crate::R<u8, u8>;
            #[doc = "Write proxy for field `src_osr_lmt`"]
            pub struct SRC_OSR_LMT_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_OSR_LMT_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x0f << 55)) | (((value as u64) & 0x0f) << 55);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_osr_lmt`"]
            pub type DST_OSR_LMT_R = crate::R<u8, u8>;
            #[doc = "Write proxy for field `dst_osr_lmt`"]
            pub struct DST_OSR_LMT_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_OSR_LMT_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x0f << 59)) | (((value as u64) & 0x0f) << 59);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:1 - Source multi-block transfer type"]
                #[inline(always)]
                pub fn src_multblk_type(&self) -> SRC_MULTBLK_TYPE_R {
                    SRC_MULTBLK_TYPE_R::new((self.bits & 0x03) as u8)
                }
                #[doc = "Bits 2:3 - Destination multi-block transfer type"]
                #[inline(always)]
                pub fn dst_multblk_type(&self) -> DST_MULTBLK_TYPE_R {
                    DST_MULTBLK_TYPE_R::new(((self.bits >> 2) & 0x03) as u8)
                }
                #[doc = "Bits 32:34 - Transfer type and flow control"]
                #[inline(always)]
                pub fn tt_fc(&self) -> TT_FC_R {
                    TT_FC_R::new(((self.bits >> 32) & 0x07) as u8)
                }
                #[doc = "Bit 35 - Source software or hardware handshaking select"]
                #[inline(always)]
                pub fn hs_sel_src(&self) -> HS_SEL_SRC_R {
                    HS_SEL_SRC_R::new(((self.bits >> 35) & 0x01) != 0)
                }
                #[doc = "Bit 36 - Destination software or hardware handshaking select"]
                #[inline(always)]
                pub fn hs_sel_dst(&self) -> HS_SEL_DST_R {
                    HS_SEL_DST_R::new(((self.bits >> 36) & 0x01) != 0)
                }
                #[doc = "Bit 37 - Source hardware handshaking interface polarity"]
                #[inline(always)]
                pub fn src_hwhs_pol(&self) -> SRC_HWHS_POL_R {
                    SRC_HWHS_POL_R::new(((self.bits >> 37) & 0x01) != 0)
                }
                #[doc = "Bit 38 - Destination hardware handshaking interface polarity"]
                #[inline(always)]
                pub fn dst_hwhs_pol(&self) -> DST_HWHS_POL_R {
                    DST_HWHS_POL_R::new(((self.bits >> 38) & 0x01) != 0)
                }
                #[doc = "Bits 39:42 - Assign a hardware handshaking interface to source of channel"]
                #[inline(always)]
                pub fn src_per(&self) -> SRC_PER_R {
                    SRC_PER_R::new(((self.bits >> 39) & 0x0f) as u8)
                }
                #[doc = "Bits 44:47 - Assign a hardware handshaking interface to destination of channel"]
                #[inline(always)]
                pub fn dst_per(&self) -> DST_PER_R {
                    DST_PER_R::new(((self.bits >> 44) & 0x0f) as u8)
                }
                #[doc = "Bits 49:51 - Channel priority (7 is highest, 0 is lowest)"]
                #[inline(always)]
                pub fn ch_prior(&self) -> CH_PRIOR_R {
                    CH_PRIOR_R::new(((self.bits >> 49) & 0x07) as u8)
                }
                #[doc = "Bit 52 - Channel lock bit"]
                #[inline(always)]
                pub fn lock_ch(&self) -> LOCK_CH_R {
                    LOCK_CH_R::new(((self.bits >> 52) & 0x01) != 0)
                }
                #[doc = "Bits 53:54 - Channel lock level"]
                #[inline(always)]
                pub fn lock_ch_l(&self) -> LOCK_CH_L_R {
                    LOCK_CH_L_R::new(((self.bits >> 53) & 0x03) as u8)
                }
                #[doc = "Bits 55:58 - Source outstanding request limit"]
                #[inline(always)]
                pub fn src_osr_lmt(&self) -> SRC_OSR_LMT_R {
                    SRC_OSR_LMT_R::new(((self.bits >> 55) & 0x0f) as u8)
                }
                #[doc = "Bits 59:62 - Destination outstanding request limit"]
                #[inline(always)]
                pub fn dst_osr_lmt(&self) -> DST_OSR_LMT_R {
                    DST_OSR_LMT_R::new(((self.bits >> 59) & 0x0f) as u8)
                }
            }
            impl W {
                #[doc = "Bits 0:1 - Source multi-block transfer type"]
                #[inline(always)]
                pub fn src_multblk_type(&mut self) -> SRC_MULTBLK_TYPE_W {
                    SRC_MULTBLK_TYPE_W { w: self }
                }
                #[doc = "Bits 2:3 - Destination multi-block transfer type"]
                #[inline(always)]
                pub fn dst_multblk_type(&mut self) -> DST_MULTBLK_TYPE_W {
                    DST_MULTBLK_TYPE_W { w: self }
                }
                #[doc = "Bits 32:34 - Transfer type and flow control"]
                #[inline(always)]
                pub fn tt_fc(&mut self) -> TT_FC_W {
                    TT_FC_W { w: self }
                }
                #[doc = "Bit 35 - Source software or hardware handshaking select"]
                #[inline(always)]
                pub fn hs_sel_src(&mut self) -> HS_SEL_SRC_W {
                    HS_SEL_SRC_W { w: self }
                }
                #[doc = "Bit 36 - Destination software or hardware handshaking select"]
                #[inline(always)]
                pub fn hs_sel_dst(&mut self) -> HS_SEL_DST_W {
                    HS_SEL_DST_W { w: self }
                }
                #[doc = "Bit 37 - Source hardware handshaking interface polarity"]
                #[inline(always)]
                pub fn src_hwhs_pol(&mut self) -> SRC_HWHS_POL_W {
                    SRC_HWHS_POL_W { w: self }
                }
                #[doc = "Bit 38 - Destination hardware handshaking interface polarity"]
                #[inline(always)]
                pub fn dst_hwhs_pol(&mut self) -> DST_HWHS_POL_W {
                    DST_HWHS_POL_W { w: self }
                }
                #[doc = "Bits 39:42 - Assign a hardware handshaking interface to source of channel"]
                #[inline(always)]
                pub fn src_per(&mut self) -> SRC_PER_W {
                    SRC_PER_W { w: self }
                }
                #[doc = "Bits 44:47 - Assign a hardware handshaking interface to destination of channel"]
                #[inline(always)]
                pub fn dst_per(&mut self) -> DST_PER_W {
                    DST_PER_W { w: self }
                }
                #[doc = "Bits 49:51 - Channel priority (7 is highest, 0 is lowest)"]
                #[inline(always)]
                pub fn ch_prior(&mut self) -> CH_PRIOR_W {
                    CH_PRIOR_W { w: self }
                }
                #[doc = "Bit 52 - Channel lock bit"]
                #[inline(always)]
                pub fn lock_ch(&mut self) -> LOCK_CH_W {
                    LOCK_CH_W { w: self }
                }
                #[doc = "Bits 53:54 - Channel lock level"]
                #[inline(always)]
                pub fn lock_ch_l(&mut self) -> LOCK_CH_L_W {
                    LOCK_CH_L_W { w: self }
                }
                #[doc = "Bits 55:58 - Source outstanding request limit"]
                #[inline(always)]
                pub fn src_osr_lmt(&mut self) -> SRC_OSR_LMT_W {
                    SRC_OSR_LMT_W { w: self }
                }
                #[doc = "Bits 59:62 - Destination outstanding request limit"]
                #[inline(always)]
                pub fn dst_osr_lmt(&mut self) -> DST_OSR_LMT_W {
                    DST_OSR_LMT_W { w: self }
                }
            }
        }
        #[doc = "Linked List Pointer register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [llp](llp) module"]
        pub type LLP = crate::Reg<u64, _LLP>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _LLP;
        #[doc = "`read()` method returns [llp::R](llp::R) reader structure"]
        impl crate::Readable for LLP {}
        #[doc = "`write(|w| ..)` method takes [llp::W](llp::W) writer structure"]
        impl crate::Writable for LLP {}
        #[doc = "Linked List Pointer register"]
        pub mod llp {
            #[doc = "Reader of register llp"]
            pub type R = crate::R<u64, super::LLP>;
            #[doc = "Writer for register llp"]
            pub type W = crate::W<u64, super::LLP>;
            #[doc = "Register llp `reset()`'s with value 0"]
            impl crate::ResetValue for super::LLP {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "LLI master select"]
            pub type LMS_A = super::ctl::SMS_A;
            #[doc = "Reader of field `lms`"]
            pub type LMS_R = crate::R<bool, LMS_A>;
            #[doc = "Write proxy for field `lms`"]
            pub struct LMS_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LMS_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: LMS_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "AXI master 1"]
                #[inline(always)]
                pub fn axi_master_1(self) -> &'a mut W {
                    self.variant(LMS_A::AXI_MASTER_1)
                }
                #[doc = "AXI master 2"]
                #[inline(always)]
                pub fn axi_master_2(self) -> &'a mut W {
                    self.variant(LMS_A::AXI_MASTER_2)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `loc`"]
            pub type LOC_R = crate::R<u64, u64>;
            #[doc = "Write proxy for field `loc`"]
            pub struct LOC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LOC_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u64) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03ff_ffff_ffff_ffff << 6))
                        | (((value as u64) & 0x03ff_ffff_ffff_ffff) << 6);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - LLI master select"]
                #[inline(always)]
                pub fn lms(&self) -> LMS_R {
                    LMS_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bits 6:63 - Starting address memeory of LLI block"]
                #[inline(always)]
                pub fn loc(&self) -> LOC_R {
                    LOC_R::new(((self.bits >> 6) & 0x03ff_ffff_ffff_ffff) as u64)
                }
            }
            impl W {
                #[doc = "Bit 0 - LLI master select"]
                #[inline(always)]
                pub fn lms(&mut self) -> LMS_W {
                    LMS_W { w: self }
                }
                #[doc = "Bits 6:63 - Starting address memeory of LLI block"]
                #[inline(always)]
                pub fn loc(&mut self) -> LOC_W {
                    LOC_W { w: self }
                }
            }
        }
        #[doc = "Channel Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module"]
        pub type STATUS = crate::Reg<u64, _STATUS>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _STATUS;
        #[doc = "`read()` method returns [status::R](status::R) reader structure"]
        impl crate::Readable for STATUS {}
        #[doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure"]
        impl crate::Writable for STATUS {}
        #[doc = "Channel Status Register"]
        pub mod status {
            #[doc = "Reader of register status"]
            pub type R = crate::R<u64, super::STATUS>;
            #[doc = "Writer for register status"]
            pub type W = crate::W<u64, super::STATUS>;
            #[doc = "Register status `reset()`'s with value 0"]
            impl crate::ResetValue for super::STATUS {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `cmpltd_blk_size`"]
            pub type CMPLTD_BLK_SIZE_R = crate::R<u32, u32>;
            #[doc = "Write proxy for field `cmpltd_blk_size`"]
            pub struct CMPLTD_BLK_SIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> CMPLTD_BLK_SIZE_W<'a> {
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x003f_ffff) | ((value as u64) & 0x003f_ffff);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:21 - Completed block transfer size"]
                #[inline(always)]
                pub fn cmpltd_blk_size(&self) -> CMPLTD_BLK_SIZE_R {
                    CMPLTD_BLK_SIZE_R::new((self.bits & 0x003f_ffff) as u32)
                }
            }
            impl W {
                #[doc = "Bits 0:21 - Completed block transfer size"]
                #[inline(always)]
                pub fn cmpltd_blk_size(&mut self) -> CMPLTD_BLK_SIZE_W {
                    CMPLTD_BLK_SIZE_W { w: self }
                }
            }
        }
        #[doc = "Channel Software handshake Source Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swhssrc](swhssrc) module"]
        pub type SWHSSRC = crate::Reg<u64, _SWHSSRC>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _SWHSSRC;
        #[doc = "`read()` method returns [swhssrc::R](swhssrc::R) reader structure"]
        impl crate::Readable for SWHSSRC {}
        #[doc = "`write(|w| ..)` method takes [swhssrc::W](swhssrc::W) writer structure"]
        impl crate::Writable for SWHSSRC {}
        #[doc = "Channel Software handshake Source Register"]
        pub mod swhssrc {
            #[doc = "Reader of register swhssrc"]
            pub type R = crate::R<u64, super::SWHSSRC>;
            #[doc = "Writer for register swhssrc"]
            pub type W = crate::W<u64, super::SWHSSRC>;
            #[doc = "Register swhssrc `reset()`'s with value 0"]
            impl crate::ResetValue for super::SWHSSRC {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `req`"]
            pub type REQ_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `req`"]
            pub struct REQ_W<'a> {
                w: &'a mut W,
            }
            impl<'a> REQ_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `req_we`"]
            pub type REQ_WE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `req_we`"]
            pub struct REQ_WE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> REQ_WE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `sglreq`"]
            pub type SGLREQ_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `sglreq`"]
            pub struct SGLREQ_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SGLREQ_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                    self.w
                }
            }
            #[doc = "Reader of field `sglreq_we`"]
            pub type SGLREQ_WE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `sglreq_we`"]
            pub struct SGLREQ_WE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SGLREQ_WE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Reader of field `lst`"]
            pub type LST_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lst`"]
            pub struct LST_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LST_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Reader of field `lst_we`"]
            pub type LST_WE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lst_we`"]
            pub struct LST_WE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LST_WE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u64) & 0x01) << 5);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Software handshake request for channel source"]
                #[inline(always)]
                pub fn req(&self) -> REQ_R {
                    REQ_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline(always)]
                pub fn req_we(&self) -> REQ_WE_R {
                    REQ_WE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 2 - Software handshake single request for channel source"]
                #[inline(always)]
                pub fn sglreq(&self) -> SGLREQ_R {
                    SGLREQ_R::new(((self.bits >> 2) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline(always)]
                pub fn sglreq_we(&self) -> SGLREQ_WE_R {
                    SGLREQ_WE_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Software handshake last request for channel source"]
                #[inline(always)]
                pub fn lst(&self) -> LST_R {
                    LST_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline(always)]
                pub fn lst_we(&self) -> LST_WE_R {
                    LST_WE_R::new(((self.bits >> 5) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Software handshake request for channel source"]
                #[inline(always)]
                pub fn req(&mut self) -> REQ_W {
                    REQ_W { w: self }
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline(always)]
                pub fn req_we(&mut self) -> REQ_WE_W {
                    REQ_WE_W { w: self }
                }
                #[doc = "Bit 2 - Software handshake single request for channel source"]
                #[inline(always)]
                pub fn sglreq(&mut self) -> SGLREQ_W {
                    SGLREQ_W { w: self }
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline(always)]
                pub fn sglreq_we(&mut self) -> SGLREQ_WE_W {
                    SGLREQ_WE_W { w: self }
                }
                #[doc = "Bit 4 - Software handshake last request for channel source"]
                #[inline(always)]
                pub fn lst(&mut self) -> LST_W {
                    LST_W { w: self }
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline(always)]
                pub fn lst_we(&mut self) -> LST_WE_W {
                    LST_WE_W { w: self }
                }
            }
        }
        #[doc = "Channel Software handshake Destination Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [swhsdst](swhsdst) module"]
        pub type SWHSDST = crate::Reg<u64, _SWHSDST>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _SWHSDST;
        #[doc = "`read()` method returns [swhsdst::R](swhsdst::R) reader structure"]
        impl crate::Readable for SWHSDST {}
        #[doc = "`write(|w| ..)` method takes [swhsdst::W](swhsdst::W) writer structure"]
        impl crate::Writable for SWHSDST {}
        #[doc = "Channel Software handshake Destination Register"]
        pub mod swhsdst {
            #[doc = "Reader of register swhsdst"]
            pub type R = crate::R<u64, super::SWHSDST>;
            #[doc = "Writer for register swhsdst"]
            pub type W = crate::W<u64, super::SWHSDST>;
            #[doc = "Register swhsdst `reset()`'s with value 0"]
            impl crate::ResetValue for super::SWHSDST {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `req`"]
            pub type REQ_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `req`"]
            pub struct REQ_W<'a> {
                w: &'a mut W,
            }
            impl<'a> REQ_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `req_we`"]
            pub type REQ_WE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `req_we`"]
            pub struct REQ_WE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> REQ_WE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `sglreq`"]
            pub type SGLREQ_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `sglreq`"]
            pub struct SGLREQ_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SGLREQ_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                    self.w
                }
            }
            #[doc = "Reader of field `sglreq_we`"]
            pub type SGLREQ_WE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `sglreq_we`"]
            pub struct SGLREQ_WE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SGLREQ_WE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Reader of field `lst`"]
            pub type LST_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lst`"]
            pub struct LST_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LST_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Reader of field `lst_we`"]
            pub type LST_WE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lst_we`"]
            pub struct LST_WE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LST_WE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u64) & 0x01) << 5);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Software handshake request for channel destination"]
                #[inline(always)]
                pub fn req(&self) -> REQ_R {
                    REQ_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline(always)]
                pub fn req_we(&self) -> REQ_WE_R {
                    REQ_WE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 2 - Software handshake single request for channel destination"]
                #[inline(always)]
                pub fn sglreq(&self) -> SGLREQ_R {
                    SGLREQ_R::new(((self.bits >> 2) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline(always)]
                pub fn sglreq_we(&self) -> SGLREQ_WE_R {
                    SGLREQ_WE_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Software handshake last request for channel destination"]
                #[inline(always)]
                pub fn lst(&self) -> LST_R {
                    LST_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline(always)]
                pub fn lst_we(&self) -> LST_WE_R {
                    LST_WE_R::new(((self.bits >> 5) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Software handshake request for channel destination"]
                #[inline(always)]
                pub fn req(&mut self) -> REQ_W {
                    REQ_W { w: self }
                }
                #[doc = "Bit 1 - Write enable bit for software handshake request"]
                #[inline(always)]
                pub fn req_we(&mut self) -> REQ_WE_W {
                    REQ_WE_W { w: self }
                }
                #[doc = "Bit 2 - Software handshake single request for channel destination"]
                #[inline(always)]
                pub fn sglreq(&mut self) -> SGLREQ_W {
                    SGLREQ_W { w: self }
                }
                #[doc = "Bit 3 - Write enable bit for software handshake"]
                #[inline(always)]
                pub fn sglreq_we(&mut self) -> SGLREQ_WE_W {
                    SGLREQ_WE_W { w: self }
                }
                #[doc = "Bit 4 - Software handshake last request for channel destination"]
                #[inline(always)]
                pub fn lst(&mut self) -> LST_W {
                    LST_W { w: self }
                }
                #[doc = "Bit 5 - Write enable bit for software handshake last request"]
                #[inline(always)]
                pub fn lst_we(&mut self) -> LST_WE_W {
                    LST_WE_W { w: self }
                }
            }
        }
        #[doc = "Channel Block Transfer Resume Request Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [blk_tfr](blk_tfr) module"]
        pub type BLK_TFR = crate::Reg<u64, _BLK_TFR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _BLK_TFR;
        #[doc = "`read()` method returns [blk_tfr::R](blk_tfr::R) reader structure"]
        impl crate::Readable for BLK_TFR {}
        #[doc = "`write(|w| ..)` method takes [blk_tfr::W](blk_tfr::W) writer structure"]
        impl crate::Writable for BLK_TFR {}
        #[doc = "Channel Block Transfer Resume Request Register"]
        pub mod blk_tfr {
            #[doc = "Reader of register blk_tfr"]
            pub type R = crate::R<u64, super::BLK_TFR>;
            #[doc = "Writer for register blk_tfr"]
            pub type W = crate::W<u64, super::BLK_TFR>;
            #[doc = "Register blk_tfr `reset()`'s with value 0"]
            impl crate::ResetValue for super::BLK_TFR {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `resumereq`"]
            pub type RESUMEREQ_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `resumereq`"]
            pub struct RESUMEREQ_W<'a> {
                w: &'a mut W,
            }
            impl<'a> RESUMEREQ_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Block transfer resume request"]
                #[inline(always)]
                pub fn resumereq(&self) -> RESUMEREQ_R {
                    RESUMEREQ_R::new((self.bits & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Block transfer resume request"]
                #[inline(always)]
                pub fn resumereq(&mut self) -> RESUMEREQ_W {
                    RESUMEREQ_W { w: self }
                }
            }
        }
        #[doc = "Channel AXI ID Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [axi_id](axi_id) module"]
        pub type AXI_ID = crate::Reg<u64, _AXI_ID>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _AXI_ID;
        #[doc = "`read()` method returns [axi_id::R](axi_id::R) reader structure"]
        impl crate::Readable for AXI_ID {}
        #[doc = "`write(|w| ..)` method takes [axi_id::W](axi_id::W) writer structure"]
        impl crate::Writable for AXI_ID {}
        #[doc = "Channel AXI ID Register"]
        pub mod axi_id {
            #[doc = "Reader of register axi_id"]
            pub type R = crate::R<u64, super::AXI_ID>;
            #[doc = "Writer for register axi_id"]
            pub type W = crate::W<u64, super::AXI_ID>;
            #[doc = "Register axi_id `reset()`'s with value 0"]
            impl crate::ResetValue for super::AXI_ID {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "AXI QOS Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [axi_qos](axi_qos) module"]
        pub type AXI_QOS = crate::Reg<u64, _AXI_QOS>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _AXI_QOS;
        #[doc = "`read()` method returns [axi_qos::R](axi_qos::R) reader structure"]
        impl crate::Readable for AXI_QOS {}
        #[doc = "`write(|w| ..)` method takes [axi_qos::W](axi_qos::W) writer structure"]
        impl crate::Writable for AXI_QOS {}
        #[doc = "AXI QOS Register"]
        pub mod axi_qos {
            #[doc = "Reader of register axi_qos"]
            pub type R = crate::R<u64, super::AXI_QOS>;
            #[doc = "Writer for register axi_qos"]
            pub type W = crate::W<u64, super::AXI_QOS>;
            #[doc = "Register axi_qos `reset()`'s with value 0"]
            impl crate::ResetValue for super::AXI_QOS {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Interrupt Status Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intstatus_en](intstatus_en) module"]
        pub type INTSTATUS_EN = crate::Reg<u64, _INTSTATUS_EN>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _INTSTATUS_EN;
        #[doc = "`read()` method returns [intstatus_en::R](intstatus_en::R) reader structure"]
        impl crate::Readable for INTSTATUS_EN {}
        #[doc = "`write(|w| ..)` method takes [intstatus_en::W](intstatus_en::W) writer structure"]
        impl crate::Writable for INTSTATUS_EN {}
        #[doc = "Interrupt Status Enable Register"]
        pub mod intstatus_en {
            #[doc = "Reader of register intstatus_en"]
            pub type R = crate::R<u64, super::INTSTATUS_EN>;
            #[doc = "Writer for register intstatus_en"]
            pub type W = crate::W<u64, super::INTSTATUS_EN>;
            #[doc = "Register intstatus_en `reset()`'s with value 0"]
            impl crate::ResetValue for super::INTSTATUS_EN {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `block_tfr_done`"]
            pub type BLOCK_TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `block_tfr_done`"]
            pub struct BLOCK_TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> BLOCK_TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `tfr_done`"]
            pub type TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `tfr_done`"]
            pub struct TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `src_transcomp`"]
            pub type SRC_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_transcomp`"]
            pub struct SRC_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_transcomp`"]
            pub type DST_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_transcomp`"]
            pub struct DST_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Reader of field `src_dec_err`"]
            pub type SRC_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_dec_err`"]
            pub struct SRC_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u64) & 0x01) << 5);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_dec_err`"]
            pub type DST_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_dec_err`"]
            pub struct DST_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u64) & 0x01) << 6);
                    self.w
                }
            }
            #[doc = "Reader of field `src_slv_err`"]
            pub type SRC_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_slv_err`"]
            pub struct SRC_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u64) & 0x01) << 7);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_slv_err`"]
            pub type DST_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_slv_err`"]
            pub struct DST_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_dec_err`"]
            pub type LLI_RD_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_dec_err`"]
            pub struct LLI_RD_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u64) & 0x01) << 9);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_dec_err`"]
            pub type LLI_WR_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_dec_err`"]
            pub struct LLI_WR_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u64) & 0x01) << 10);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_slv_err`"]
            pub type LLI_RD_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_slv_err`"]
            pub struct LLI_RD_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u64) & 0x01) << 11);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_slv_err`"]
            pub type LLI_WR_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_slv_err`"]
            pub struct LLI_WR_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u64) & 0x01) << 12);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONE_R {
                    BLOCK_TFR_DONE_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&self) -> TFR_DONE_R {
                    TFR_DONE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMP_R {
                    SRC_TRANSCOMP_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMP_R {
                    DST_TRANSCOMP_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&self) -> SRC_DEC_ERR_R {
                    SRC_DEC_ERR_R::new(((self.bits >> 5) & 0x01) != 0)
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&self) -> DST_DEC_ERR_R {
                    DST_DEC_ERR_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&self) -> SRC_SLV_ERR_R {
                    SRC_SLV_ERR_R::new(((self.bits >> 7) & 0x01) != 0)
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&self) -> DST_SLV_ERR_R {
                    DST_SLV_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERR_R {
                    LLI_RD_DEC_ERR_R::new(((self.bits >> 9) & 0x01) != 0)
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERR_R {
                    LLI_WR_DEC_ERR_R::new(((self.bits >> 10) & 0x01) != 0)
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERR_R {
                    LLI_RD_SLV_ERR_R::new(((self.bits >> 11) & 0x01) != 0)
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERR_R {
                    LLI_WR_SLV_ERR_R::new(((self.bits >> 12) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&mut self) -> BLOCK_TFR_DONE_W {
                    BLOCK_TFR_DONE_W { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&mut self) -> TFR_DONE_W {
                    TFR_DONE_W { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&mut self) -> SRC_TRANSCOMP_W {
                    SRC_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&mut self) -> DST_TRANSCOMP_W {
                    DST_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&mut self) -> SRC_DEC_ERR_W {
                    SRC_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&mut self) -> DST_DEC_ERR_W {
                    DST_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&mut self) -> SRC_SLV_ERR_W {
                    SRC_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&mut self) -> DST_SLV_ERR_W {
                    DST_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&mut self) -> LLI_RD_DEC_ERR_W {
                    LLI_RD_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&mut self) -> LLI_WR_DEC_ERR_W {
                    LLI_WR_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&mut self) -> LLI_RD_SLV_ERR_W {
                    LLI_RD_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&mut self) -> LLI_WR_SLV_ERR_W {
                    LLI_WR_SLV_ERR_W { w: self }
                }
            }
        }
        #[doc = "Channel Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intstatus](intstatus) module"]
        pub type INTSTATUS = crate::Reg<u64, _INTSTATUS>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _INTSTATUS;
        #[doc = "`read()` method returns [intstatus::R](intstatus::R) reader structure"]
        impl crate::Readable for INTSTATUS {}
        #[doc = "`write(|w| ..)` method takes [intstatus::W](intstatus::W) writer structure"]
        impl crate::Writable for INTSTATUS {}
        #[doc = "Channel Interrupt Status Register"]
        pub mod intstatus {
            #[doc = "Reader of register intstatus"]
            pub type R = crate::R<u64, super::INTSTATUS>;
            #[doc = "Writer for register intstatus"]
            pub type W = crate::W<u64, super::INTSTATUS>;
            #[doc = "Register intstatus `reset()`'s with value 0"]
            impl crate::ResetValue for super::INTSTATUS {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `block_tfr_done`"]
            pub type BLOCK_TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `block_tfr_done`"]
            pub struct BLOCK_TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> BLOCK_TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `tfr_done`"]
            pub type TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `tfr_done`"]
            pub struct TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `src_transcomp`"]
            pub type SRC_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_transcomp`"]
            pub struct SRC_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_transcomp`"]
            pub type DST_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_transcomp`"]
            pub struct DST_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Reader of field `src_dec_err`"]
            pub type SRC_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_dec_err`"]
            pub struct SRC_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u64) & 0x01) << 5);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_dec_err`"]
            pub type DST_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_dec_err`"]
            pub struct DST_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u64) & 0x01) << 6);
                    self.w
                }
            }
            #[doc = "Reader of field `src_slv_err`"]
            pub type SRC_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_slv_err`"]
            pub struct SRC_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u64) & 0x01) << 7);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_slv_err`"]
            pub type DST_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_slv_err`"]
            pub struct DST_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_dec_err`"]
            pub type LLI_RD_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_dec_err`"]
            pub struct LLI_RD_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u64) & 0x01) << 9);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_dec_err`"]
            pub type LLI_WR_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_dec_err`"]
            pub struct LLI_WR_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u64) & 0x01) << 10);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_slv_err`"]
            pub type LLI_RD_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_slv_err`"]
            pub struct LLI_RD_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u64) & 0x01) << 11);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_slv_err`"]
            pub type LLI_WR_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_slv_err`"]
            pub struct LLI_WR_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u64) & 0x01) << 12);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONE_R {
                    BLOCK_TFR_DONE_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&self) -> TFR_DONE_R {
                    TFR_DONE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMP_R {
                    SRC_TRANSCOMP_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMP_R {
                    DST_TRANSCOMP_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&self) -> SRC_DEC_ERR_R {
                    SRC_DEC_ERR_R::new(((self.bits >> 5) & 0x01) != 0)
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&self) -> DST_DEC_ERR_R {
                    DST_DEC_ERR_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&self) -> SRC_SLV_ERR_R {
                    SRC_SLV_ERR_R::new(((self.bits >> 7) & 0x01) != 0)
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&self) -> DST_SLV_ERR_R {
                    DST_SLV_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERR_R {
                    LLI_RD_DEC_ERR_R::new(((self.bits >> 9) & 0x01) != 0)
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERR_R {
                    LLI_WR_DEC_ERR_R::new(((self.bits >> 10) & 0x01) != 0)
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERR_R {
                    LLI_RD_SLV_ERR_R::new(((self.bits >> 11) & 0x01) != 0)
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERR_R {
                    LLI_WR_SLV_ERR_R::new(((self.bits >> 12) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&mut self) -> BLOCK_TFR_DONE_W {
                    BLOCK_TFR_DONE_W { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&mut self) -> TFR_DONE_W {
                    TFR_DONE_W { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&mut self) -> SRC_TRANSCOMP_W {
                    SRC_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&mut self) -> DST_TRANSCOMP_W {
                    DST_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&mut self) -> SRC_DEC_ERR_W {
                    SRC_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&mut self) -> DST_DEC_ERR_W {
                    DST_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&mut self) -> SRC_SLV_ERR_W {
                    SRC_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&mut self) -> DST_SLV_ERR_W {
                    DST_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&mut self) -> LLI_RD_DEC_ERR_W {
                    LLI_RD_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&mut self) -> LLI_WR_DEC_ERR_W {
                    LLI_WR_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&mut self) -> LLI_RD_SLV_ERR_W {
                    LLI_RD_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&mut self) -> LLI_WR_SLV_ERR_W {
                    LLI_WR_SLV_ERR_W { w: self }
                }
            }
        }
        #[doc = "Interrupt Signal Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intsignal_en](intsignal_en) module"]
        pub type INTSIGNAL_EN = crate::Reg<u64, _INTSIGNAL_EN>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _INTSIGNAL_EN;
        #[doc = "`read()` method returns [intsignal_en::R](intsignal_en::R) reader structure"]
        impl crate::Readable for INTSIGNAL_EN {}
        #[doc = "`write(|w| ..)` method takes [intsignal_en::W](intsignal_en::W) writer structure"]
        impl crate::Writable for INTSIGNAL_EN {}
        #[doc = "Interrupt Signal Enable Register"]
        pub mod intsignal_en {
            #[doc = "Reader of register intsignal_en"]
            pub type R = crate::R<u64, super::INTSIGNAL_EN>;
            #[doc = "Writer for register intsignal_en"]
            pub type W = crate::W<u64, super::INTSIGNAL_EN>;
            #[doc = "Register intsignal_en `reset()`'s with value 0"]
            impl crate::ResetValue for super::INTSIGNAL_EN {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `block_tfr_done`"]
            pub type BLOCK_TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `block_tfr_done`"]
            pub struct BLOCK_TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> BLOCK_TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `tfr_done`"]
            pub type TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `tfr_done`"]
            pub struct TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `src_transcomp`"]
            pub type SRC_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_transcomp`"]
            pub struct SRC_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_transcomp`"]
            pub type DST_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_transcomp`"]
            pub struct DST_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Reader of field `src_dec_err`"]
            pub type SRC_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_dec_err`"]
            pub struct SRC_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u64) & 0x01) << 5);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_dec_err`"]
            pub type DST_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_dec_err`"]
            pub struct DST_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u64) & 0x01) << 6);
                    self.w
                }
            }
            #[doc = "Reader of field `src_slv_err`"]
            pub type SRC_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_slv_err`"]
            pub struct SRC_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u64) & 0x01) << 7);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_slv_err`"]
            pub type DST_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_slv_err`"]
            pub struct DST_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_dec_err`"]
            pub type LLI_RD_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_dec_err`"]
            pub struct LLI_RD_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u64) & 0x01) << 9);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_dec_err`"]
            pub type LLI_WR_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_dec_err`"]
            pub struct LLI_WR_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u64) & 0x01) << 10);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_slv_err`"]
            pub type LLI_RD_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_slv_err`"]
            pub struct LLI_RD_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u64) & 0x01) << 11);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_slv_err`"]
            pub type LLI_WR_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_slv_err`"]
            pub struct LLI_WR_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u64) & 0x01) << 12);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONE_R {
                    BLOCK_TFR_DONE_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&self) -> TFR_DONE_R {
                    TFR_DONE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMP_R {
                    SRC_TRANSCOMP_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMP_R {
                    DST_TRANSCOMP_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&self) -> SRC_DEC_ERR_R {
                    SRC_DEC_ERR_R::new(((self.bits >> 5) & 0x01) != 0)
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&self) -> DST_DEC_ERR_R {
                    DST_DEC_ERR_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&self) -> SRC_SLV_ERR_R {
                    SRC_SLV_ERR_R::new(((self.bits >> 7) & 0x01) != 0)
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&self) -> DST_SLV_ERR_R {
                    DST_SLV_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERR_R {
                    LLI_RD_DEC_ERR_R::new(((self.bits >> 9) & 0x01) != 0)
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERR_R {
                    LLI_WR_DEC_ERR_R::new(((self.bits >> 10) & 0x01) != 0)
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERR_R {
                    LLI_RD_SLV_ERR_R::new(((self.bits >> 11) & 0x01) != 0)
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERR_R {
                    LLI_WR_SLV_ERR_R::new(((self.bits >> 12) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&mut self) -> BLOCK_TFR_DONE_W {
                    BLOCK_TFR_DONE_W { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&mut self) -> TFR_DONE_W {
                    TFR_DONE_W { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&mut self) -> SRC_TRANSCOMP_W {
                    SRC_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&mut self) -> DST_TRANSCOMP_W {
                    DST_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&mut self) -> SRC_DEC_ERR_W {
                    SRC_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&mut self) -> DST_DEC_ERR_W {
                    DST_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&mut self) -> SRC_SLV_ERR_W {
                    SRC_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&mut self) -> DST_SLV_ERR_W {
                    DST_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&mut self) -> LLI_RD_DEC_ERR_W {
                    LLI_RD_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&mut self) -> LLI_WR_DEC_ERR_W {
                    LLI_WR_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&mut self) -> LLI_RD_SLV_ERR_W {
                    LLI_RD_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&mut self) -> LLI_WR_SLV_ERR_W {
                    LLI_WR_SLV_ERR_W { w: self }
                }
            }
        }
        #[doc = "Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intclear](intclear) module"]
        pub type INTCLEAR = crate::Reg<u64, _INTCLEAR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _INTCLEAR;
        #[doc = "`read()` method returns [intclear::R](intclear::R) reader structure"]
        impl crate::Readable for INTCLEAR {}
        #[doc = "`write(|w| ..)` method takes [intclear::W](intclear::W) writer structure"]
        impl crate::Writable for INTCLEAR {}
        #[doc = "Interrupt Clear Register"]
        pub mod intclear {
            #[doc = "Reader of register intclear"]
            pub type R = crate::R<u64, super::INTCLEAR>;
            #[doc = "Writer for register intclear"]
            pub type W = crate::W<u64, super::INTCLEAR>;
            #[doc = "Register intclear `reset()`'s with value 0"]
            impl crate::ResetValue for super::INTCLEAR {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `block_tfr_done`"]
            pub type BLOCK_TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `block_tfr_done`"]
            pub struct BLOCK_TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> BLOCK_TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `tfr_done`"]
            pub type TFR_DONE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `tfr_done`"]
            pub struct TFR_DONE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TFR_DONE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `src_transcomp`"]
            pub type SRC_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_transcomp`"]
            pub struct SRC_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_transcomp`"]
            pub type DST_TRANSCOMP_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_transcomp`"]
            pub struct DST_TRANSCOMP_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_TRANSCOMP_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u64) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Reader of field `src_dec_err`"]
            pub type SRC_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_dec_err`"]
            pub struct SRC_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u64) & 0x01) << 5);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_dec_err`"]
            pub type DST_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_dec_err`"]
            pub struct DST_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u64) & 0x01) << 6);
                    self.w
                }
            }
            #[doc = "Reader of field `src_slv_err`"]
            pub type SRC_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `src_slv_err`"]
            pub struct SRC_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> SRC_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u64) & 0x01) << 7);
                    self.w
                }
            }
            #[doc = "Reader of field `dst_slv_err`"]
            pub type DST_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `dst_slv_err`"]
            pub struct DST_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DST_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_dec_err`"]
            pub type LLI_RD_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_dec_err`"]
            pub struct LLI_RD_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u64) & 0x01) << 9);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_dec_err`"]
            pub type LLI_WR_DEC_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_dec_err`"]
            pub struct LLI_WR_DEC_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_DEC_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u64) & 0x01) << 10);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_rd_slv_err`"]
            pub type LLI_RD_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_rd_slv_err`"]
            pub struct LLI_RD_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_RD_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u64) & 0x01) << 11);
                    self.w
                }
            }
            #[doc = "Reader of field `lli_wr_slv_err`"]
            pub type LLI_WR_SLV_ERR_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `lli_wr_slv_err`"]
            pub struct LLI_WR_SLV_ERR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> LLI_WR_SLV_ERR_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u64) & 0x01) << 12);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&self) -> BLOCK_TFR_DONE_R {
                    BLOCK_TFR_DONE_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&self) -> TFR_DONE_R {
                    TFR_DONE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&self) -> SRC_TRANSCOMP_R {
                    SRC_TRANSCOMP_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&self) -> DST_TRANSCOMP_R {
                    DST_TRANSCOMP_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&self) -> SRC_DEC_ERR_R {
                    SRC_DEC_ERR_R::new(((self.bits >> 5) & 0x01) != 0)
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&self) -> DST_DEC_ERR_R {
                    DST_DEC_ERR_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&self) -> SRC_SLV_ERR_R {
                    SRC_SLV_ERR_R::new(((self.bits >> 7) & 0x01) != 0)
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&self) -> DST_SLV_ERR_R {
                    DST_SLV_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&self) -> LLI_RD_DEC_ERR_R {
                    LLI_RD_DEC_ERR_R::new(((self.bits >> 9) & 0x01) != 0)
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&self) -> LLI_WR_DEC_ERR_R {
                    LLI_WR_DEC_ERR_R::new(((self.bits >> 10) & 0x01) != 0)
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&self) -> LLI_RD_SLV_ERR_R {
                    LLI_RD_SLV_ERR_R::new(((self.bits >> 11) & 0x01) != 0)
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&self) -> LLI_WR_SLV_ERR_R {
                    LLI_WR_SLV_ERR_R::new(((self.bits >> 12) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Block transfer done"]
                #[inline(always)]
                pub fn block_tfr_done(&mut self) -> BLOCK_TFR_DONE_W {
                    BLOCK_TFR_DONE_W { w: self }
                }
                #[doc = "Bit 1 - Transfer done"]
                #[inline(always)]
                pub fn tfr_done(&mut self) -> TFR_DONE_W {
                    TFR_DONE_W { w: self }
                }
                #[doc = "Bit 3 - Source transaction complete"]
                #[inline(always)]
                pub fn src_transcomp(&mut self) -> SRC_TRANSCOMP_W {
                    SRC_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 4 - Destination transaction complete"]
                #[inline(always)]
                pub fn dst_transcomp(&mut self) -> DST_TRANSCOMP_W {
                    DST_TRANSCOMP_W { w: self }
                }
                #[doc = "Bit 5 - Source Decode Error"]
                #[inline(always)]
                pub fn src_dec_err(&mut self) -> SRC_DEC_ERR_W {
                    SRC_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 6 - Destination Decode Error"]
                #[inline(always)]
                pub fn dst_dec_err(&mut self) -> DST_DEC_ERR_W {
                    DST_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 7 - Source Slave Error"]
                #[inline(always)]
                pub fn src_slv_err(&mut self) -> SRC_SLV_ERR_W {
                    SRC_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 8 - Destination Slave Error"]
                #[inline(always)]
                pub fn dst_slv_err(&mut self) -> DST_SLV_ERR_W {
                    DST_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 9 - LLI Read Decode Error Status Enable"]
                #[inline(always)]
                pub fn lli_rd_dec_err(&mut self) -> LLI_RD_DEC_ERR_W {
                    LLI_RD_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 10 - LLI WRITE Decode Error"]
                #[inline(always)]
                pub fn lli_wr_dec_err(&mut self) -> LLI_WR_DEC_ERR_W {
                    LLI_WR_DEC_ERR_W { w: self }
                }
                #[doc = "Bit 11 - LLI Read Slave Error"]
                #[inline(always)]
                pub fn lli_rd_slv_err(&mut self) -> LLI_RD_SLV_ERR_W {
                    LLI_RD_SLV_ERR_W { w: self }
                }
                #[doc = "Bit 12 - LLI WRITE Slave Error"]
                #[inline(always)]
                pub fn lli_wr_slv_err(&mut self) -> LLI_WR_SLV_ERR_W {
                    LLI_WR_SLV_ERR_W { w: self }
                }
            }
        }
        #[doc = "Padding to make structure size 256 bytes so that channels\\[\\]
is an array\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [_reserved](_reserved) module"]
        pub type _RESERVED = crate::Reg<u64, __RESERVED>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct __RESERVED;
        #[doc = "`read()` method returns [_reserved::R](_reserved::R) reader structure"]
        impl crate::Readable for _RESERVED {}
        #[doc = "`write(|w| ..)` method takes [_reserved::W](_reserved::W) writer structure"]
        impl crate::Writable for _RESERVED {}
        #[doc = "Padding to make structure size 256 bytes so that channels\\[\\]
is an array"]
        pub mod _reserved {
            #[doc = "Reader of register _reserved"]
            pub type R = crate::R<u64, super::_RESERVED>;
            #[doc = "Writer for register _reserved"]
            pub type W = crate::W<u64, super::_RESERVED>;
            #[doc = "Register _reserved `reset()`'s with value 0"]
            impl crate::ResetValue for super::_RESERVED {
                type Type = u64;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
    }
    #[doc = "ID Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [id](id) module"]
    pub type ID = crate::Reg<u64, _ID>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ID;
    #[doc = "`read()` method returns [id::R](id::R) reader structure"]
    impl crate::Readable for ID {}
    #[doc = "`write(|w| ..)` method takes [id::W](id::W) writer structure"]
    impl crate::Writable for ID {}
    #[doc = "ID Register"]
    pub mod id {
        #[doc = "Reader of register id"]
        pub type R = crate::R<u64, super::ID>;
        #[doc = "Writer for register id"]
        pub type W = crate::W<u64, super::ID>;
        #[doc = "Register id `reset()`'s with value 0"]
        impl crate::ResetValue for super::ID {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "COMPVER Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [compver](compver) module"]
    pub type COMPVER = crate::Reg<u64, _COMPVER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMPVER;
    #[doc = "`read()` method returns [compver::R](compver::R) reader structure"]
    impl crate::Readable for COMPVER {}
    #[doc = "`write(|w| ..)` method takes [compver::W](compver::W) writer structure"]
    impl crate::Writable for COMPVER {}
    #[doc = "COMPVER Register"]
    pub mod compver {
        #[doc = "Reader of register compver"]
        pub type R = crate::R<u64, super::COMPVER>;
        #[doc = "Writer for register compver"]
        pub type W = crate::W<u64, super::COMPVER>;
        #[doc = "Register compver `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMPVER {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Configure Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
    pub type CFG = crate::Reg<u64, _CFG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CFG;
    #[doc = "`read()` method returns [cfg::R](cfg::R) reader structure"]
    impl crate::Readable for CFG {}
    #[doc = "`write(|w| ..)` method takes [cfg::W](cfg::W) writer structure"]
    impl crate::Writable for CFG {}
    #[doc = "Configure Register"]
    pub mod cfg {
        #[doc = "Reader of register cfg"]
        pub type R = crate::R<u64, super::CFG>;
        #[doc = "Writer for register cfg"]
        pub type W = crate::W<u64, super::CFG>;
        #[doc = "Register cfg `reset()`'s with value 0"]
        impl crate::ResetValue for super::CFG {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dmac_en`"]
        pub type DMAC_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dmac_en`"]
        pub struct DMAC_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAC_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `int_en`"]
        pub type INT_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `int_en`"]
        pub struct INT_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INT_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Enable DMAC"]
            #[inline(always)]
            pub fn dmac_en(&self) -> DMAC_EN_R {
                DMAC_EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Globally enable interrupt generation"]
            #[inline(always)]
            pub fn int_en(&self) -> INT_EN_R {
                INT_EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable DMAC"]
            #[inline(always)]
            pub fn dmac_en(&mut self) -> DMAC_EN_W {
                DMAC_EN_W { w: self }
            }
            #[doc = "Bit 1 - Globally enable interrupt generation"]
            #[inline(always)]
            pub fn int_en(&mut self) -> INT_EN_W {
                INT_EN_W { w: self }
            }
        }
    }
    #[doc = "Channel Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [chen](chen) module"]
    pub type CHEN = crate::Reg<u64, _CHEN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CHEN;
    #[doc = "`read()` method returns [chen::R](chen::R) reader structure"]
    impl crate::Readable for CHEN {}
    #[doc = "`write(|w| ..)` method takes [chen::W](chen::W) writer structure"]
    impl crate::Writable for CHEN {}
    #[doc = "Channel Enable Register"]
    pub mod chen {
        #[doc = "Reader of register chen"]
        pub type R = crate::R<u64, super::CHEN>;
        #[doc = "Writer for register chen"]
        pub type W = crate::W<u64, super::CHEN>;
        #[doc = "Register chen `reset()`'s with value 0"]
        impl crate::ResetValue for super::CHEN {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `ch(1-6)_en`"]
        pub type CH_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `ch(1-6)_en`"]
        pub struct CH_EN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> CH_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u64) & 0x01) << self.offset);
                self.w
            }
        }
        #[doc = "Reader of fields `ch(1-6)_en_we`"]
        pub type CH_EN_WE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `ch(1-6)_en_we`"]
        pub struct CH_EN_WE_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> CH_EN_WE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u64) & 0x01) << self.offset);
                self.w
            }
        }
        #[doc = "Reader of fields `ch(1-6)_susp`"]
        pub type CH_SUSP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `ch(1-6)_susp`"]
        pub struct CH_SUSP_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> CH_SUSP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u64) & 0x01) << self.offset);
                self.w
            }
        }
        #[doc = "Reader of fields `ch(1-6)_susp_we`"]
        pub type CH_SUSP_WE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `ch(1-6)_susp_we`"]
        pub struct CH_SUSP_WE_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> CH_SUSP_WE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u64) & 0x01) << self.offset);
                self.w
            }
        }
        #[doc = "Reader of fields `ch(1-6)_abort`"]
        pub type CH_ABORT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `ch(1-6)_abort`"]
        pub struct CH_ABORT_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> CH_ABORT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u64) & 0x01) << self.offset);
                self.w
            }
        }
        #[doc = "Reader of fields `ch(1-6)_abort_we`"]
        pub type CH_ABORT_WE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `ch(1-6)_abort_we`"]
        pub struct CH_ABORT_WE_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> CH_ABORT_WE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u64) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = "Enable channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_en(&self, n: usize) -> CH_EN_R {
                CH_EN_R::new(((self.bits >> n - 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Enable channel 1"]
            #[inline(always)]
            pub fn ch1_en(&self) -> CH_EN_R {
                CH_EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Enable channel 2"]
            #[inline(always)]
            pub fn ch2_en(&self) -> CH_EN_R {
                CH_EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Enable channel 3"]
            #[inline(always)]
            pub fn ch3_en(&self) -> CH_EN_R {
                CH_EN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Enable channel 4"]
            #[inline(always)]
            pub fn ch4_en(&self) -> CH_EN_R {
                CH_EN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Enable channel 5"]
            #[inline(always)]
            pub fn ch5_en(&self) -> CH_EN_R {
                CH_EN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Enable channel 6"]
            #[inline(always)]
            pub fn ch6_en(&self) -> CH_EN_R {
                CH_EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Write enable channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_en_we(&self, n: usize) -> CH_EN_WE_R {
                CH_EN_WE_R::new(((self.bits >> n - 1 + 8) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Write enable channel 1"]
            #[inline(always)]
            pub fn ch1_en_we(&self) -> CH_EN_WE_R {
                CH_EN_WE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Write enable channel 2"]
            #[inline(always)]
            pub fn ch2_en_we(&self) -> CH_EN_WE_R {
                CH_EN_WE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Write enable channel 3"]
            #[inline(always)]
            pub fn ch3_en_we(&self) -> CH_EN_WE_R {
                CH_EN_WE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - Write enable channel 4"]
            #[inline(always)]
            pub fn ch4_en_we(&self) -> CH_EN_WE_R {
                CH_EN_WE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Write enable channel 5"]
            #[inline(always)]
            pub fn ch5_en_we(&self) -> CH_EN_WE_R {
                CH_EN_WE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Write enable channel 6"]
            #[inline(always)]
            pub fn ch6_en_we(&self) -> CH_EN_WE_R {
                CH_EN_WE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Suspend request channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_susp(&self, n: usize) -> CH_SUSP_R {
                CH_SUSP_R::new(((self.bits >> n - 1 + 16) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Suspend request channel 1"]
            #[inline(always)]
            pub fn ch1_susp(&self) -> CH_SUSP_R {
                CH_SUSP_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Suspend request channel 2"]
            #[inline(always)]
            pub fn ch2_susp(&self) -> CH_SUSP_R {
                CH_SUSP_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18 - Suspend request channel 3"]
            #[inline(always)]
            pub fn ch3_susp(&self) -> CH_SUSP_R {
                CH_SUSP_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Suspend request channel 4"]
            #[inline(always)]
            pub fn ch4_susp(&self) -> CH_SUSP_R {
                CH_SUSP_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Suspend request channel 5"]
            #[inline(always)]
            pub fn ch5_susp(&self) -> CH_SUSP_R {
                CH_SUSP_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Suspend request channel 6"]
            #[inline(always)]
            pub fn ch6_susp(&self) -> CH_SUSP_R {
                CH_SUSP_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Enable write to ch(1-6)_susp bit"]
            #[inline(always)]
            pub unsafe fn ch_susp_we(&self, n: usize) -> CH_SUSP_WE_R {
                CH_SUSP_WE_R::new(((self.bits >> n - 1 + 24) & 0x01) != 0)
            }
            #[doc = "Bit 24 - Enable write to ch1_susp bit"]
            #[inline(always)]
            pub fn ch1_susp_we(&self) -> CH_SUSP_WE_R {
                CH_SUSP_WE_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - Enable write to ch2_susp bit"]
            #[inline(always)]
            pub fn ch2_susp_we(&self) -> CH_SUSP_WE_R {
                CH_SUSP_WE_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26 - Enable write to ch3_susp bit"]
            #[inline(always)]
            pub fn ch3_susp_we(&self) -> CH_SUSP_WE_R {
                CH_SUSP_WE_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27 - Enable write to ch4_susp bit"]
            #[inline(always)]
            pub fn ch4_susp_we(&self) -> CH_SUSP_WE_R {
                CH_SUSP_WE_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 28 - Enable write to ch5_susp bit"]
            #[inline(always)]
            pub fn ch5_susp_we(&self) -> CH_SUSP_WE_R {
                CH_SUSP_WE_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            #[doc = "Bit 29 - Enable write to ch6_susp bit"]
            #[inline(always)]
            pub fn ch6_susp_we(&self) -> CH_SUSP_WE_R {
                CH_SUSP_WE_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Abort request channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_abort(&self, n: usize) -> CH_ABORT_R {
                CH_ABORT_R::new(((self.bits >> n - 1 + 32) & 0x01) != 0)
            }
            #[doc = "Bit 32 - Abort request channel 1"]
            #[inline(always)]
            pub fn ch1_abort(&self) -> CH_ABORT_R {
                CH_ABORT_R::new(((self.bits >> 32) & 0x01) != 0)
            }
            #[doc = "Bit 33 - Abort request channel 2"]
            #[inline(always)]
            pub fn ch2_abort(&self) -> CH_ABORT_R {
                CH_ABORT_R::new(((self.bits >> 33) & 0x01) != 0)
            }
            #[doc = "Bit 34 - Abort request channel 3"]
            #[inline(always)]
            pub fn ch3_abort(&self) -> CH_ABORT_R {
                CH_ABORT_R::new(((self.bits >> 34) & 0x01) != 0)
            }
            #[doc = "Bit 35 - Abort request channel 4"]
            #[inline(always)]
            pub fn ch4_abort(&self) -> CH_ABORT_R {
                CH_ABORT_R::new(((self.bits >> 35) & 0x01) != 0)
            }
            #[doc = "Bit 36 - Abort request channel 5"]
            #[inline(always)]
            pub fn ch5_abort(&self) -> CH_ABORT_R {
                CH_ABORT_R::new(((self.bits >> 36) & 0x01) != 0)
            }
            #[doc = "Bit 37 - Abort request channel 6"]
            #[inline(always)]
            pub fn ch6_abort(&self) -> CH_ABORT_R {
                CH_ABORT_R::new(((self.bits >> 37) & 0x01) != 0)
            }
            #[doc = "Enable write to ch(1-6)_abort bit"]
            #[inline(always)]
            pub unsafe fn ch_abort_we(&self, n: usize) -> CH_ABORT_WE_R {
                CH_ABORT_WE_R::new(((self.bits >> n - 1 + 40) & 0x01) != 0)
            }
            #[doc = "Bit 40 - Enable write to ch1_abort bit"]
            #[inline(always)]
            pub fn ch1_abort_we(&self) -> CH_ABORT_WE_R {
                CH_ABORT_WE_R::new(((self.bits >> 40) & 0x01) != 0)
            }
            #[doc = "Bit 41 - Enable write to ch2_abort bit"]
            #[inline(always)]
            pub fn ch2_abort_we(&self) -> CH_ABORT_WE_R {
                CH_ABORT_WE_R::new(((self.bits >> 41) & 0x01) != 0)
            }
            #[doc = "Bit 42 - Enable write to ch3_abort bit"]
            #[inline(always)]
            pub fn ch3_abort_we(&self) -> CH_ABORT_WE_R {
                CH_ABORT_WE_R::new(((self.bits >> 42) & 0x01) != 0)
            }
            #[doc = "Bit 43 - Enable write to ch4_abort bit"]
            #[inline(always)]
            pub fn ch4_abort_we(&self) -> CH_ABORT_WE_R {
                CH_ABORT_WE_R::new(((self.bits >> 43) & 0x01) != 0)
            }
            #[doc = "Bit 44 - Enable write to ch5_abort bit"]
            #[inline(always)]
            pub fn ch5_abort_we(&self) -> CH_ABORT_WE_R {
                CH_ABORT_WE_R::new(((self.bits >> 44) & 0x01) != 0)
            }
            #[doc = "Bit 45 - Enable write to ch6_abort bit"]
            #[inline(always)]
            pub fn ch6_abort_we(&self) -> CH_ABORT_WE_R {
                CH_ABORT_WE_R::new(((self.bits >> 45) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Enable channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_en(&mut self, n: usize) -> CH_EN_W {
                CH_EN_W {
                    w: self,
                    offset: n - 1,
                }
            }
            #[doc = "Bit 0 - Enable channel 1"]
            #[inline(always)]
            pub fn ch1_en(&mut self) -> CH_EN_W {
                CH_EN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1 - Enable channel 2"]
            #[inline(always)]
            pub fn ch2_en(&mut self) -> CH_EN_W {
                CH_EN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2 - Enable channel 3"]
            #[inline(always)]
            pub fn ch3_en(&mut self) -> CH_EN_W {
                CH_EN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3 - Enable channel 4"]
            #[inline(always)]
            pub fn ch4_en(&mut self) -> CH_EN_W {
                CH_EN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4 - Enable channel 5"]
            #[inline(always)]
            pub fn ch5_en(&mut self) -> CH_EN_W {
                CH_EN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5 - Enable channel 6"]
            #[inline(always)]
            pub fn ch6_en(&mut self) -> CH_EN_W {
                CH_EN_W { w: self, offset: 5 }
            }
            #[doc = "Write enable channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_en_we(&mut self, n: usize) -> CH_EN_WE_W {
                CH_EN_WE_W {
                    w: self,
                    offset: n - 1 + 8,
                }
            }
            #[doc = "Bit 8 - Write enable channel 1"]
            #[inline(always)]
            pub fn ch1_en_we(&mut self) -> CH_EN_WE_W {
                CH_EN_WE_W { w: self, offset: 8 }
            }
            #[doc = "Bit 9 - Write enable channel 2"]
            #[inline(always)]
            pub fn ch2_en_we(&mut self) -> CH_EN_WE_W {
                CH_EN_WE_W { w: self, offset: 9 }
            }
            #[doc = "Bit 10 - Write enable channel 3"]
            #[inline(always)]
            pub fn ch3_en_we(&mut self) -> CH_EN_WE_W {
                CH_EN_WE_W {
                    w: self,
                    offset: 10,
                }
            }
            #[doc = "Bit 11 - Write enable channel 4"]
            #[inline(always)]
            pub fn ch4_en_we(&mut self) -> CH_EN_WE_W {
                CH_EN_WE_W {
                    w: self,
                    offset: 11,
                }
            }
            #[doc = "Bit 12 - Write enable channel 5"]
            #[inline(always)]
            pub fn ch5_en_we(&mut self) -> CH_EN_WE_W {
                CH_EN_WE_W {
                    w: self,
                    offset: 12,
                }
            }
            #[doc = "Bit 13 - Write enable channel 6"]
            #[inline(always)]
            pub fn ch6_en_we(&mut self) -> CH_EN_WE_W {
                CH_EN_WE_W {
                    w: self,
                    offset: 13,
                }
            }
            #[doc = "Suspend request channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_susp(&mut self, n: usize) -> CH_SUSP_W {
                CH_SUSP_W {
                    w: self,
                    offset: n - 1 + 16,
                }
            }
            #[doc = "Bit 16 - Suspend request channel 1"]
            #[inline(always)]
            pub fn ch1_susp(&mut self) -> CH_SUSP_W {
                CH_SUSP_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bit 17 - Suspend request channel 2"]
            #[inline(always)]
            pub fn ch2_susp(&mut self) -> CH_SUSP_W {
                CH_SUSP_W {
                    w: self,
                    offset: 17,
                }
            }
            #[doc = "Bit 18 - Suspend request channel 3"]
            #[inline(always)]
            pub fn ch3_susp(&mut self) -> CH_SUSP_W {
                CH_SUSP_W {
                    w: self,
                    offset: 18,
                }
            }
            #[doc = "Bit 19 - Suspend request channel 4"]
            #[inline(always)]
            pub fn ch4_susp(&mut self) -> CH_SUSP_W {
                CH_SUSP_W {
                    w: self,
                    offset: 19,
                }
            }
            #[doc = "Bit 20 - Suspend request channel 5"]
            #[inline(always)]
            pub fn ch5_susp(&mut self) -> CH_SUSP_W {
                CH_SUSP_W {
                    w: self,
                    offset: 20,
                }
            }
            #[doc = "Bit 21 - Suspend request channel 6"]
            #[inline(always)]
            pub fn ch6_susp(&mut self) -> CH_SUSP_W {
                CH_SUSP_W {
                    w: self,
                    offset: 21,
                }
            }
            #[doc = "Enable write to ch(1-6)_susp bit"]
            #[inline(always)]
            pub unsafe fn ch_susp_we(&mut self, n: usize) -> CH_SUSP_WE_W {
                CH_SUSP_WE_W {
                    w: self,
                    offset: n - 1 + 24,
                }
            }
            #[doc = "Bit 24 - Enable write to ch1_susp bit"]
            #[inline(always)]
            pub fn ch1_susp_we(&mut self) -> CH_SUSP_WE_W {
                CH_SUSP_WE_W {
                    w: self,
                    offset: 24,
                }
            }
            #[doc = "Bit 25 - Enable write to ch2_susp bit"]
            #[inline(always)]
            pub fn ch2_susp_we(&mut self) -> CH_SUSP_WE_W {
                CH_SUSP_WE_W {
                    w: self,
                    offset: 25,
                }
            }
            #[doc = "Bit 26 - Enable write to ch3_susp bit"]
            #[inline(always)]
            pub fn ch3_susp_we(&mut self) -> CH_SUSP_WE_W {
                CH_SUSP_WE_W {
                    w: self,
                    offset: 26,
                }
            }
            #[doc = "Bit 27 - Enable write to ch4_susp bit"]
            #[inline(always)]
            pub fn ch4_susp_we(&mut self) -> CH_SUSP_WE_W {
                CH_SUSP_WE_W {
                    w: self,
                    offset: 27,
                }
            }
            #[doc = "Bit 28 - Enable write to ch5_susp bit"]
            #[inline(always)]
            pub fn ch5_susp_we(&mut self) -> CH_SUSP_WE_W {
                CH_SUSP_WE_W {
                    w: self,
                    offset: 28,
                }
            }
            #[doc = "Bit 29 - Enable write to ch6_susp bit"]
            #[inline(always)]
            pub fn ch6_susp_we(&mut self) -> CH_SUSP_WE_W {
                CH_SUSP_WE_W {
                    w: self,
                    offset: 29,
                }
            }
            #[doc = "Abort request channel (1-6)"]
            #[inline(always)]
            pub unsafe fn ch_abort(&mut self, n: usize) -> CH_ABORT_W {
                CH_ABORT_W {
                    w: self,
                    offset: n - 1 + 32,
                }
            }
            #[doc = "Bit 32 - Abort request channel 1"]
            #[inline(always)]
            pub fn ch1_abort(&mut self) -> CH_ABORT_W {
                CH_ABORT_W {
                    w: self,
                    offset: 32,
                }
            }
            #[doc = "Bit 33 - Abort request channel 2"]
            #[inline(always)]
            pub fn ch2_abort(&mut self) -> CH_ABORT_W {
                CH_ABORT_W {
                    w: self,
                    offset: 33,
                }
            }
            #[doc = "Bit 34 - Abort request channel 3"]
            #[inline(always)]
            pub fn ch3_abort(&mut self) -> CH_ABORT_W {
                CH_ABORT_W {
                    w: self,
                    offset: 34,
                }
            }
            #[doc = "Bit 35 - Abort request channel 4"]
            #[inline(always)]
            pub fn ch4_abort(&mut self) -> CH_ABORT_W {
                CH_ABORT_W {
                    w: self,
                    offset: 35,
                }
            }
            #[doc = "Bit 36 - Abort request channel 5"]
            #[inline(always)]
            pub fn ch5_abort(&mut self) -> CH_ABORT_W {
                CH_ABORT_W {
                    w: self,
                    offset: 36,
                }
            }
            #[doc = "Bit 37 - Abort request channel 6"]
            #[inline(always)]
            pub fn ch6_abort(&mut self) -> CH_ABORT_W {
                CH_ABORT_W {
                    w: self,
                    offset: 37,
                }
            }
            #[doc = "Enable write to ch(1-6)_abort bit"]
            #[inline(always)]
            pub unsafe fn ch_abort_we(&mut self, n: usize) -> CH_ABORT_WE_W {
                CH_ABORT_WE_W {
                    w: self,
                    offset: n - 1 + 40,
                }
            }
            #[doc = "Bit 40 - Enable write to ch1_abort bit"]
            #[inline(always)]
            pub fn ch1_abort_we(&mut self) -> CH_ABORT_WE_W {
                CH_ABORT_WE_W {
                    w: self,
                    offset: 40,
                }
            }
            #[doc = "Bit 41 - Enable write to ch2_abort bit"]
            #[inline(always)]
            pub fn ch2_abort_we(&mut self) -> CH_ABORT_WE_W {
                CH_ABORT_WE_W {
                    w: self,
                    offset: 41,
                }
            }
            #[doc = "Bit 42 - Enable write to ch3_abort bit"]
            #[inline(always)]
            pub fn ch3_abort_we(&mut self) -> CH_ABORT_WE_W {
                CH_ABORT_WE_W {
                    w: self,
                    offset: 42,
                }
            }
            #[doc = "Bit 43 - Enable write to ch4_abort bit"]
            #[inline(always)]
            pub fn ch4_abort_we(&mut self) -> CH_ABORT_WE_W {
                CH_ABORT_WE_W {
                    w: self,
                    offset: 43,
                }
            }
            #[doc = "Bit 44 - Enable write to ch5_abort bit"]
            #[inline(always)]
            pub fn ch5_abort_we(&mut self) -> CH_ABORT_WE_W {
                CH_ABORT_WE_W {
                    w: self,
                    offset: 44,
                }
            }
            #[doc = "Bit 45 - Enable write to ch6_abort bit"]
            #[inline(always)]
            pub fn ch6_abort_we(&mut self) -> CH_ABORT_WE_W {
                CH_ABORT_WE_W {
                    w: self,
                    offset: 45,
                }
            }
        }
    }
    #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intstatus](intstatus) module"]
    pub type INTSTATUS = crate::Reg<u64, _INTSTATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTSTATUS;
    #[doc = "`read()` method returns [intstatus::R](intstatus::R) reader structure"]
    impl crate::Readable for INTSTATUS {}
    #[doc = "`write(|w| ..)` method takes [intstatus::W](intstatus::W) writer structure"]
    impl crate::Writable for INTSTATUS {}
    #[doc = "Interrupt Status Register"]
    pub mod intstatus {
        #[doc = "Reader of register intstatus"]
        pub type R = crate::R<u64, super::INTSTATUS>;
        #[doc = "Writer for register intstatus"]
        pub type W = crate::W<u64, super::INTSTATUS>;
        #[doc = "Register intstatus `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTSTATUS {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `ch(1-6)_intstat`"]
        pub type CH_INTSTAT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `ch(1-6)_intstat`"]
        pub struct CH_INTSTAT_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> CH_INTSTAT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u64) & 0x01) << self.offset);
                self.w
            }
        }
        #[doc = "Reader of field `commonreg_intstat`"]
        pub type COMMONREG_INTSTAT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `commonreg_intstat`"]
        pub struct COMMONREG_INTSTAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMMONREG_INTSTAT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u64) & 0x01) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Channel (1-6) interrupt bit"]
            #[inline(always)]
            pub unsafe fn ch_intstat(&self, n: usize) -> CH_INTSTAT_R {
                CH_INTSTAT_R::new(((self.bits >> n - 1) & 0x01) != 0)
            }
            #[doc = "Bit 0 - Channel 1 interrupt bit"]
            #[inline(always)]
            pub fn ch1_intstat(&self) -> CH_INTSTAT_R {
                CH_INTSTAT_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Channel 2 interrupt bit"]
            #[inline(always)]
            pub fn ch2_intstat(&self) -> CH_INTSTAT_R {
                CH_INTSTAT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Channel 3 interrupt bit"]
            #[inline(always)]
            pub fn ch3_intstat(&self) -> CH_INTSTAT_R {
                CH_INTSTAT_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Channel 4 interrupt bit"]
            #[inline(always)]
            pub fn ch4_intstat(&self) -> CH_INTSTAT_R {
                CH_INTSTAT_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Channel 5 interrupt bit"]
            #[inline(always)]
            pub fn ch5_intstat(&self) -> CH_INTSTAT_R {
                CH_INTSTAT_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Channel 6 interrupt bit"]
            #[inline(always)]
            pub fn ch6_intstat(&self) -> CH_INTSTAT_R {
                CH_INTSTAT_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Common register status bit"]
            #[inline(always)]
            pub fn commonreg_intstat(&self) -> COMMONREG_INTSTAT_R {
                COMMONREG_INTSTAT_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Channel (1-6) interrupt bit"]
            #[inline(always)]
            pub unsafe fn ch_intstat(&mut self, n: usize) -> CH_INTSTAT_W {
                CH_INTSTAT_W {
                    w: self,
                    offset: n - 1,
                }
            }
            #[doc = "Bit 0 - Channel 1 interrupt bit"]
            #[inline(always)]
            pub fn ch1_intstat(&mut self) -> CH_INTSTAT_W {
                CH_INTSTAT_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1 - Channel 2 interrupt bit"]
            #[inline(always)]
            pub fn ch2_intstat(&mut self) -> CH_INTSTAT_W {
                CH_INTSTAT_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2 - Channel 3 interrupt bit"]
            #[inline(always)]
            pub fn ch3_intstat(&mut self) -> CH_INTSTAT_W {
                CH_INTSTAT_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3 - Channel 4 interrupt bit"]
            #[inline(always)]
            pub fn ch4_intstat(&mut self) -> CH_INTSTAT_W {
                CH_INTSTAT_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4 - Channel 5 interrupt bit"]
            #[inline(always)]
            pub fn ch5_intstat(&mut self) -> CH_INTSTAT_W {
                CH_INTSTAT_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5 - Channel 6 interrupt bit"]
            #[inline(always)]
            pub fn ch6_intstat(&mut self) -> CH_INTSTAT_W {
                CH_INTSTAT_W { w: self, offset: 5 }
            }
            #[doc = "Bit 16 - Common register status bit"]
            #[inline(always)]
            pub fn commonreg_intstat(&mut self) -> COMMONREG_INTSTAT_W {
                COMMONREG_INTSTAT_W { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [com_intclear](com_intclear) module"]
    pub type COM_INTCLEAR = crate::Reg<u64, _COM_INTCLEAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COM_INTCLEAR;
    #[doc = "`read()` method returns [com_intclear::R](com_intclear::R) reader structure"]
    impl crate::Readable for COM_INTCLEAR {}
    #[doc = "`write(|w| ..)` method takes [com_intclear::W](com_intclear::W) writer structure"]
    impl crate::Writable for COM_INTCLEAR {}
    #[doc = "Common Interrupt Clear Register"]
    pub mod com_intclear {
        #[doc = "Reader of register com_intclear"]
        pub type R = crate::R<u64, super::COM_INTCLEAR>;
        #[doc = "Writer for register com_intclear"]
        pub type W = crate::W<u64, super::COM_INTCLEAR>;
        #[doc = "Register com_intclear `reset()`'s with value 0"]
        impl crate::ResetValue for super::COM_INTCLEAR {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `slvif_dec_err`"]
        pub type SLVIF_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_dec_err`"]
        pub struct SLVIF_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wr2ro_err`"]
        pub type SLVIF_WR2RO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wr2ro_err`"]
        pub struct SLVIF_WR2RO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WR2RO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_rd2wo_err`"]
        pub type SLVIF_RD2WO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_rd2wo_err`"]
        pub struct SLVIF_RD2WO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_RD2WO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wronhold_err`"]
        pub type SLVIF_WRONHOLD_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wronhold_err`"]
        pub struct SLVIF_WRONHOLD_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WRONHOLD_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_undefinedreg_dec_err`"]
        pub type SLVIF_UNDEFINEDREG_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_undefinedreg_dec_err`"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Clear slvif_dec_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERR_R {
                SLVIF_DEC_ERR_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Clear slvif_wr2ro_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERR_R {
                SLVIF_WR2RO_ERR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Clear slvif_rd2wo_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERR_R {
                SLVIF_RD2WO_ERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Clear slvif_wronhold_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERR_R {
                SLVIF_WRONHOLD_ERR_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Clear slvif_undefinedreg_dec_err in com_intstatus"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERR_R {
                SLVIF_UNDEFINEDREG_DEC_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Clear slvif_dec_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_dec_err(&mut self) -> SLVIF_DEC_ERR_W {
                SLVIF_DEC_ERR_W { w: self }
            }
            #[doc = "Bit 1 - Clear slvif_wr2ro_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&mut self) -> SLVIF_WR2RO_ERR_W {
                SLVIF_WR2RO_ERR_W { w: self }
            }
            #[doc = "Bit 2 - Clear slvif_rd2wo_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&mut self) -> SLVIF_RD2WO_ERR_W {
                SLVIF_RD2WO_ERR_W { w: self }
            }
            #[doc = "Bit 3 - Clear slvif_wronhold_err interrupt in com_intstatus"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&mut self) -> SLVIF_WRONHOLD_ERR_W {
                SLVIF_WRONHOLD_ERR_W { w: self }
            }
            #[doc = "Bit 8 - Clear slvif_undefinedreg_dec_err in com_intstatus"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> SLVIF_UNDEFINEDREG_DEC_ERR_W {
                SLVIF_UNDEFINEDREG_DEC_ERR_W { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Status Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [com_intstatus_en](com_intstatus_en) module"]
    pub type COM_INTSTATUS_EN = crate::Reg<u64, _COM_INTSTATUS_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COM_INTSTATUS_EN;
    #[doc = "`read()` method returns [com_intstatus_en::R](com_intstatus_en::R) reader structure"]
    impl crate::Readable for COM_INTSTATUS_EN {}
    #[doc = "`write(|w| ..)` method takes [com_intstatus_en::W](com_intstatus_en::W) writer structure"]
    impl crate::Writable for COM_INTSTATUS_EN {}
    #[doc = "Common Interrupt Status Enable Register"]
    pub mod com_intstatus_en {
        #[doc = "Reader of register com_intstatus_en"]
        pub type R = crate::R<u64, super::COM_INTSTATUS_EN>;
        #[doc = "Writer for register com_intstatus_en"]
        pub type W = crate::W<u64, super::COM_INTSTATUS_EN>;
        #[doc = "Register com_intstatus_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::COM_INTSTATUS_EN {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `slvif_dec_err`"]
        pub type SLVIF_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_dec_err`"]
        pub struct SLVIF_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wr2ro_err`"]
        pub type SLVIF_WR2RO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wr2ro_err`"]
        pub struct SLVIF_WR2RO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WR2RO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_rd2wo_err`"]
        pub type SLVIF_RD2WO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_rd2wo_err`"]
        pub struct SLVIF_RD2WO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_RD2WO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wronhold_err`"]
        pub type SLVIF_WRONHOLD_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wronhold_err`"]
        pub struct SLVIF_WRONHOLD_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WRONHOLD_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_undefinedreg_dec_err`"]
        pub type SLVIF_UNDEFINEDREG_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_undefinedreg_dec_err`"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline(always)]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERR_R {
                SLVIF_DEC_ERR_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERR_R {
                SLVIF_WR2RO_ERR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERR_R {
                SLVIF_RD2WO_ERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERR_R {
                SLVIF_WRONHOLD_ERR_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERR_R {
                SLVIF_UNDEFINEDREG_DEC_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline(always)]
            pub fn slvif_dec_err(&mut self) -> SLVIF_DEC_ERR_W {
                SLVIF_DEC_ERR_W { w: self }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&mut self) -> SLVIF_WR2RO_ERR_W {
                SLVIF_WR2RO_ERR_W { w: self }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&mut self) -> SLVIF_RD2WO_ERR_W {
                SLVIF_RD2WO_ERR_W { w: self }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&mut self) -> SLVIF_WRONHOLD_ERR_W {
                SLVIF_WRONHOLD_ERR_W { w: self }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> SLVIF_UNDEFINEDREG_DEC_ERR_W {
                SLVIF_UNDEFINEDREG_DEC_ERR_W { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Signal Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [com_intsignal_en](com_intsignal_en) module"]
    pub type COM_INTSIGNAL_EN = crate::Reg<u64, _COM_INTSIGNAL_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COM_INTSIGNAL_EN;
    #[doc = "`read()` method returns [com_intsignal_en::R](com_intsignal_en::R) reader structure"]
    impl crate::Readable for COM_INTSIGNAL_EN {}
    #[doc = "`write(|w| ..)` method takes [com_intsignal_en::W](com_intsignal_en::W) writer structure"]
    impl crate::Writable for COM_INTSIGNAL_EN {}
    #[doc = "Common Interrupt Signal Enable Register"]
    pub mod com_intsignal_en {
        #[doc = "Reader of register com_intsignal_en"]
        pub type R = crate::R<u64, super::COM_INTSIGNAL_EN>;
        #[doc = "Writer for register com_intsignal_en"]
        pub type W = crate::W<u64, super::COM_INTSIGNAL_EN>;
        #[doc = "Register com_intsignal_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::COM_INTSIGNAL_EN {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `slvif_dec_err`"]
        pub type SLVIF_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_dec_err`"]
        pub struct SLVIF_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wr2ro_err`"]
        pub type SLVIF_WR2RO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wr2ro_err`"]
        pub struct SLVIF_WR2RO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WR2RO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_rd2wo_err`"]
        pub type SLVIF_RD2WO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_rd2wo_err`"]
        pub struct SLVIF_RD2WO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_RD2WO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wronhold_err`"]
        pub type SLVIF_WRONHOLD_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wronhold_err`"]
        pub struct SLVIF_WRONHOLD_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WRONHOLD_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_undefinedreg_dec_err`"]
        pub type SLVIF_UNDEFINEDREG_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_undefinedreg_dec_err`"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline(always)]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERR_R {
                SLVIF_DEC_ERR_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERR_R {
                SLVIF_WR2RO_ERR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERR_R {
                SLVIF_RD2WO_ERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERR_R {
                SLVIF_WRONHOLD_ERR_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERR_R {
                SLVIF_UNDEFINEDREG_DEC_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline(always)]
            pub fn slvif_dec_err(&mut self) -> SLVIF_DEC_ERR_W {
                SLVIF_DEC_ERR_W { w: self }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&mut self) -> SLVIF_WR2RO_ERR_W {
                SLVIF_WR2RO_ERR_W { w: self }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&mut self) -> SLVIF_RD2WO_ERR_W {
                SLVIF_RD2WO_ERR_W { w: self }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&mut self) -> SLVIF_WRONHOLD_ERR_W {
                SLVIF_WRONHOLD_ERR_W { w: self }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> SLVIF_UNDEFINEDREG_DEC_ERR_W {
                SLVIF_UNDEFINEDREG_DEC_ERR_W { w: self }
            }
        }
    }
    #[doc = "Common Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [com_intstatus](com_intstatus) module"]
    pub type COM_INTSTATUS = crate::Reg<u64, _COM_INTSTATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COM_INTSTATUS;
    #[doc = "`read()` method returns [com_intstatus::R](com_intstatus::R) reader structure"]
    impl crate::Readable for COM_INTSTATUS {}
    #[doc = "`write(|w| ..)` method takes [com_intstatus::W](com_intstatus::W) writer structure"]
    impl crate::Writable for COM_INTSTATUS {}
    #[doc = "Common Interrupt Status"]
    pub mod com_intstatus {
        #[doc = "Reader of register com_intstatus"]
        pub type R = crate::R<u64, super::COM_INTSTATUS>;
        #[doc = "Writer for register com_intstatus"]
        pub type W = crate::W<u64, super::COM_INTSTATUS>;
        #[doc = "Register com_intstatus `reset()`'s with value 0"]
        impl crate::ResetValue for super::COM_INTSTATUS {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `slvif_dec_err`"]
        pub type SLVIF_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_dec_err`"]
        pub struct SLVIF_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wr2ro_err`"]
        pub type SLVIF_WR2RO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wr2ro_err`"]
        pub struct SLVIF_WR2RO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WR2RO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u64) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_rd2wo_err`"]
        pub type SLVIF_RD2WO_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_rd2wo_err`"]
        pub struct SLVIF_RD2WO_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_RD2WO_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u64) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_wronhold_err`"]
        pub type SLVIF_WRONHOLD_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_wronhold_err`"]
        pub struct SLVIF_WRONHOLD_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_WRONHOLD_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u64) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `slvif_undefinedreg_dec_err`"]
        pub type SLVIF_UNDEFINEDREG_DEC_ERR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvif_undefinedreg_dec_err`"]
        pub struct SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVIF_UNDEFINEDREG_DEC_ERR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u64) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline(always)]
            pub fn slvif_dec_err(&self) -> SLVIF_DEC_ERR_R {
                SLVIF_DEC_ERR_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&self) -> SLVIF_WR2RO_ERR_R {
                SLVIF_WR2RO_ERR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&self) -> SLVIF_RD2WO_ERR_R {
                SLVIF_RD2WO_ERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&self) -> SLVIF_WRONHOLD_ERR_R {
                SLVIF_WRONHOLD_ERR_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&self) -> SLVIF_UNDEFINEDREG_DEC_ERR_R {
                SLVIF_UNDEFINEDREG_DEC_ERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Slave Interface Common Register Decode Error"]
            #[inline(always)]
            pub fn slvif_dec_err(&mut self) -> SLVIF_DEC_ERR_W {
                SLVIF_DEC_ERR_W { w: self }
            }
            #[doc = "Bit 1 - Slave Interface Common Register Write to Read only Error"]
            #[inline(always)]
            pub fn slvif_wr2ro_err(&mut self) -> SLVIF_WR2RO_ERR_W {
                SLVIF_WR2RO_ERR_W { w: self }
            }
            #[doc = "Bit 2 - Slave Interface Common Register Read to Write-only Error"]
            #[inline(always)]
            pub fn slvif_rd2wo_err(&mut self) -> SLVIF_RD2WO_ERR_W {
                SLVIF_RD2WO_ERR_W { w: self }
            }
            #[doc = "Bit 3 - Slave Interface Common Register Write On Hold Error"]
            #[inline(always)]
            pub fn slvif_wronhold_err(&mut self) -> SLVIF_WRONHOLD_ERR_W {
                SLVIF_WRONHOLD_ERR_W { w: self }
            }
            #[doc = "Bit 8 - Slave Interface Undefined Register Decode Error"]
            #[inline(always)]
            pub fn slvif_undefinedreg_dec_err(&mut self) -> SLVIF_UNDEFINEDREG_DEC_ERR_W {
                SLVIF_UNDEFINEDREG_DEC_ERR_W { w: self }
            }
        }
    }
    #[doc = "Reset register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reset](reset) module"]
    pub type RESET = crate::Reg<u64, _RESET>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RESET;
    #[doc = "`read()` method returns [reset::R](reset::R) reader structure"]
    impl crate::Readable for RESET {}
    #[doc = "`write(|w| ..)` method takes [reset::W](reset::W) writer structure"]
    impl crate::Writable for RESET {}
    #[doc = "Reset register"]
    pub mod reset {
        #[doc = "Reader of register reset"]
        pub type R = crate::R<u64, super::RESET>;
        #[doc = "Writer for register reset"]
        pub type W = crate::W<u64, super::RESET>;
        #[doc = "Register reset `reset()`'s with value 0"]
        impl crate::ResetValue for super::RESET {
            type Type = u64;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rst`"]
        pub type RST_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rst`"]
        pub struct RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u64) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - DMAC reset request bit"]
            #[inline(always)]
            pub fn rst(&self) -> RST_R {
                RST_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMAC reset request bit"]
            #[inline(always)]
            pub fn rst(&mut self) -> RST_W {
                RST_W { w: self }
            }
        }
    }
}
#[doc = "General Purpose Input/Output Interface"]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        0x5020_0000 as *const _
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*GPIO::ptr() }
    }
}
#[doc = "General Purpose Input/Output Interface"]
pub mod gpio {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data (output) registers"]
        pub data_output: DATA_OUTPUT,
        #[doc = "0x04 - Data direction registers"]
        pub direction: DIRECTION,
        #[doc = "0x08 - Data source registers"]
        pub source: SOURCE,
        _reserved3: [u8; 36usize],
        #[doc = "0x30 - Interrupt enable/disable registers"]
        pub interrupt_enable: INTERRUPT_ENABLE,
        #[doc = "0x34 - Interrupt mask registers"]
        pub interrupt_mask: INTERRUPT_MASK,
        #[doc = "0x38 - Interrupt level registers"]
        pub interrupt_level: INTERRUPT_LEVEL,
        #[doc = "0x3c - Interrupt polarity registers"]
        pub interrupt_polarity: INTERRUPT_POLARITY,
        #[doc = "0x40 - Interrupt status registers"]
        pub interrupt_status: INTERRUPT_STATUS,
        #[doc = "0x44 - Raw interrupt status registers"]
        pub interrupt_status_raw: INTERRUPT_STATUS_RAW,
        #[doc = "0x48 - Interrupt debounce registers"]
        pub interrupt_debounce: INTERRUPT_DEBOUNCE,
        #[doc = "0x4c - Registers for clearing interrupts"]
        pub interrupt_clear: INTERRUPT_CLEAR,
        #[doc = "0x50 - External port (data input) registers"]
        pub data_input: DATA_INPUT,
        _reserved12: [u8; 12usize],
        #[doc = "0x60 - Sync level registers"]
        pub sync_level: SYNC_LEVEL,
        #[doc = "0x64 - ID code"]
        pub id_code: ID_CODE,
        #[doc = "0x68 - Interrupt both edge type"]
        pub interrupt_bothedge: INTERRUPT_BOTHEDGE,
    }
    #[doc = "Data (output) registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_output](data_output) module"]
    pub type DATA_OUTPUT = crate::Reg<u32, _DATA_OUTPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DATA_OUTPUT;
    #[doc = "`read()` method returns [data_output::R](data_output::R) reader structure"]
    impl crate::Readable for DATA_OUTPUT {}
    #[doc = "`write(|w| ..)` method takes [data_output::W](data_output::W) writer structure"]
    impl crate::Writable for DATA_OUTPUT {}
    #[doc = "Data (output) registers"]
    pub mod data_output {
        #[doc = "Reader of register data_output"]
        pub type R = crate::R<u32, super::DATA_OUTPUT>;
        #[doc = "Writer for register data_output"]
        pub type W = crate::W<u32, super::DATA_OUTPUT>;
        #[doc = "Register data_output `reset()`'s with value 0"]
        impl crate::ResetValue for super::DATA_OUTPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-7)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-7)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
        }
    }
    #[doc = "Data direction registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [direction](direction) module"]
    pub type DIRECTION = crate::Reg<u32, _DIRECTION>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIRECTION;
    #[doc = "`read()` method returns [direction::R](direction::R) reader structure"]
    impl crate::Readable for DIRECTION {}
    #[doc = "`write(|w| ..)` method takes [direction::W](direction::W) writer structure"]
    impl crate::Writable for DIRECTION {}
    #[doc = "Data direction registers"]
    pub mod direction {
        #[doc = "Reader of register direction"]
        pub type R = crate::R<u32, super::DIRECTION>;
        #[doc = "Writer for register direction"]
        pub type W = crate::W<u32, super::DIRECTION>;
        #[doc = "Register direction `reset()`'s with value 0"]
        impl crate::ResetValue for super::DIRECTION {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN_A {
            #[doc = "0: Pin is input"]
            INPUT = 0,
            #[doc = "1: Pin is output"]
            OUTPUT = 1,
        }
        impl From<PIN_A> for bool {
            #[inline(always)]
            fn from(variant: PIN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of fields `pin(0-7)`"]
        pub type PIN_R = crate::R<bool, PIN_A>;
        impl PIN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> PIN_A {
                match self.bits {
                    false => PIN_A::INPUT,
                    true => PIN_A::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                *self == PIN_A::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                *self == PIN_A::OUTPUT
            }
        }
        #[doc = "Write proxy for fields `pin(0-7)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PIN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Pin is input"]
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN_A::INPUT)
            }
            #[doc = "Pin is output"]
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN_A::OUTPUT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
        }
    }
    #[doc = "Data source registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [source](source) module"]
    pub type SOURCE = crate::Reg<u32, _SOURCE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SOURCE;
    #[doc = "`read()` method returns [source::R](source::R) reader structure"]
    impl crate::Readable for SOURCE {}
    #[doc = "`write(|w| ..)` method takes [source::W](source::W) writer structure"]
    impl crate::Writable for SOURCE {}
    #[doc = "Data source registers"]
    pub mod source {
        #[doc = "Reader of register source"]
        pub type R = crate::R<u32, super::SOURCE>;
        #[doc = "Writer for register source"]
        pub type W = crate::W<u32, super::SOURCE>;
        #[doc = "Register source `reset()`'s with value 0"]
        impl crate::ResetValue for super::SOURCE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt enable/disable registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_enable](interrupt_enable) module"]
    pub type INTERRUPT_ENABLE = crate::Reg<u32, _INTERRUPT_ENABLE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_ENABLE;
    #[doc = "`read()` method returns [interrupt_enable::R](interrupt_enable::R) reader structure"]
    impl crate::Readable for INTERRUPT_ENABLE {}
    #[doc = "`write(|w| ..)` method takes [interrupt_enable::W](interrupt_enable::W) writer structure"]
    impl crate::Writable for INTERRUPT_ENABLE {}
    #[doc = "Interrupt enable/disable registers"]
    pub mod interrupt_enable {
        #[doc = "Reader of register interrupt_enable"]
        pub type R = crate::R<u32, super::INTERRUPT_ENABLE>;
        #[doc = "Writer for register interrupt_enable"]
        pub type W = crate::W<u32, super::INTERRUPT_ENABLE>;
        #[doc = "Register interrupt_enable `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_ENABLE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt mask registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_mask](interrupt_mask) module"]
    pub type INTERRUPT_MASK = crate::Reg<u32, _INTERRUPT_MASK>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_MASK;
    #[doc = "`read()` method returns [interrupt_mask::R](interrupt_mask::R) reader structure"]
    impl crate::Readable for INTERRUPT_MASK {}
    #[doc = "`write(|w| ..)` method takes [interrupt_mask::W](interrupt_mask::W) writer structure"]
    impl crate::Writable for INTERRUPT_MASK {}
    #[doc = "Interrupt mask registers"]
    pub mod interrupt_mask {
        #[doc = "Reader of register interrupt_mask"]
        pub type R = crate::R<u32, super::INTERRUPT_MASK>;
        #[doc = "Writer for register interrupt_mask"]
        pub type W = crate::W<u32, super::INTERRUPT_MASK>;
        #[doc = "Register interrupt_mask `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_MASK {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt level registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_level](interrupt_level) module"]
    pub type INTERRUPT_LEVEL = crate::Reg<u32, _INTERRUPT_LEVEL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_LEVEL;
    #[doc = "`read()` method returns [interrupt_level::R](interrupt_level::R) reader structure"]
    impl crate::Readable for INTERRUPT_LEVEL {}
    #[doc = "`write(|w| ..)` method takes [interrupt_level::W](interrupt_level::W) writer structure"]
    impl crate::Writable for INTERRUPT_LEVEL {}
    #[doc = "Interrupt level registers"]
    pub mod interrupt_level {
        #[doc = "Reader of register interrupt_level"]
        pub type R = crate::R<u32, super::INTERRUPT_LEVEL>;
        #[doc = "Writer for register interrupt_level"]
        pub type W = crate::W<u32, super::INTERRUPT_LEVEL>;
        #[doc = "Register interrupt_level `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_LEVEL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt polarity registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_polarity](interrupt_polarity) module"]
    pub type INTERRUPT_POLARITY = crate::Reg<u32, _INTERRUPT_POLARITY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_POLARITY;
    #[doc = "`read()` method returns [interrupt_polarity::R](interrupt_polarity::R) reader structure"]
    impl crate::Readable for INTERRUPT_POLARITY {}
    #[doc = "`write(|w| ..)` method takes [interrupt_polarity::W](interrupt_polarity::W) writer structure"]
    impl crate::Writable for INTERRUPT_POLARITY {}
    #[doc = "Interrupt polarity registers"]
    pub mod interrupt_polarity {
        #[doc = "Reader of register interrupt_polarity"]
        pub type R = crate::R<u32, super::INTERRUPT_POLARITY>;
        #[doc = "Writer for register interrupt_polarity"]
        pub type W = crate::W<u32, super::INTERRUPT_POLARITY>;
        #[doc = "Register interrupt_polarity `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_POLARITY {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt status registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_status](interrupt_status) module"]
    pub type INTERRUPT_STATUS = crate::Reg<u32, _INTERRUPT_STATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_STATUS;
    #[doc = "`read()` method returns [interrupt_status::R](interrupt_status::R) reader structure"]
    impl crate::Readable for INTERRUPT_STATUS {}
    #[doc = "`write(|w| ..)` method takes [interrupt_status::W](interrupt_status::W) writer structure"]
    impl crate::Writable for INTERRUPT_STATUS {}
    #[doc = "Interrupt status registers"]
    pub mod interrupt_status {
        #[doc = "Reader of register interrupt_status"]
        pub type R = crate::R<u32, super::INTERRUPT_STATUS>;
        #[doc = "Writer for register interrupt_status"]
        pub type W = crate::W<u32, super::INTERRUPT_STATUS>;
        #[doc = "Register interrupt_status `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_STATUS {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Raw interrupt status registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_status_raw](interrupt_status_raw) module"]
    pub type INTERRUPT_STATUS_RAW = crate::Reg<u32, _INTERRUPT_STATUS_RAW>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_STATUS_RAW;
    #[doc = "`read()` method returns [interrupt_status_raw::R](interrupt_status_raw::R) reader structure"]
    impl crate::Readable for INTERRUPT_STATUS_RAW {}
    #[doc = "`write(|w| ..)` method takes [interrupt_status_raw::W](interrupt_status_raw::W) writer structure"]
    impl crate::Writable for INTERRUPT_STATUS_RAW {}
    #[doc = "Raw interrupt status registers"]
    pub mod interrupt_status_raw {
        #[doc = "Reader of register interrupt_status_raw"]
        pub type R = crate::R<u32, super::INTERRUPT_STATUS_RAW>;
        #[doc = "Writer for register interrupt_status_raw"]
        pub type W = crate::W<u32, super::INTERRUPT_STATUS_RAW>;
        #[doc = "Register interrupt_status_raw `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_STATUS_RAW {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt debounce registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_debounce](interrupt_debounce) module"]
    pub type INTERRUPT_DEBOUNCE = crate::Reg<u32, _INTERRUPT_DEBOUNCE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_DEBOUNCE;
    #[doc = "`read()` method returns [interrupt_debounce::R](interrupt_debounce::R) reader structure"]
    impl crate::Readable for INTERRUPT_DEBOUNCE {}
    #[doc = "`write(|w| ..)` method takes [interrupt_debounce::W](interrupt_debounce::W) writer structure"]
    impl crate::Writable for INTERRUPT_DEBOUNCE {}
    #[doc = "Interrupt debounce registers"]
    pub mod interrupt_debounce {
        #[doc = "Reader of register interrupt_debounce"]
        pub type R = crate::R<u32, super::INTERRUPT_DEBOUNCE>;
        #[doc = "Writer for register interrupt_debounce"]
        pub type W = crate::W<u32, super::INTERRUPT_DEBOUNCE>;
        #[doc = "Register interrupt_debounce `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_DEBOUNCE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Registers for clearing interrupts\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_clear](interrupt_clear) module"]
    pub type INTERRUPT_CLEAR = crate::Reg<u32, _INTERRUPT_CLEAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_CLEAR;
    #[doc = "`read()` method returns [interrupt_clear::R](interrupt_clear::R) reader structure"]
    impl crate::Readable for INTERRUPT_CLEAR {}
    #[doc = "`write(|w| ..)` method takes [interrupt_clear::W](interrupt_clear::W) writer structure"]
    impl crate::Writable for INTERRUPT_CLEAR {}
    #[doc = "Registers for clearing interrupts"]
    pub mod interrupt_clear {
        #[doc = "Reader of register interrupt_clear"]
        pub type R = crate::R<u32, super::INTERRUPT_CLEAR>;
        #[doc = "Writer for register interrupt_clear"]
        pub type W = crate::W<u32, super::INTERRUPT_CLEAR>;
        #[doc = "Register interrupt_clear `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_CLEAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "External port (data input) registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_input](data_input) module"]
    pub type DATA_INPUT = crate::Reg<u32, _DATA_INPUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DATA_INPUT;
    #[doc = "`read()` method returns [data_input::R](data_input::R) reader structure"]
    impl crate::Readable for DATA_INPUT {}
    #[doc = "`write(|w| ..)` method takes [data_input::W](data_input::W) writer structure"]
    impl crate::Writable for DATA_INPUT {}
    #[doc = "External port (data input) registers"]
    pub mod data_input {
        #[doc = "Reader of register data_input"]
        pub type R = crate::R<u32, super::DATA_INPUT>;
        #[doc = "Writer for register data_input"]
        pub type W = crate::W<u32, super::DATA_INPUT>;
        #[doc = "Register data_input `reset()`'s with value 0"]
        impl crate::ResetValue for super::DATA_INPUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `pin(0-7)`"]
        pub type PIN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for fields `pin(0-7)`"]
        pub struct PIN_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> PIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << self.offset))
                    | (((value as u32) & 0x01) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&self, n: usize) -> PIN_R {
                PIN_R::new(((self.bits >> n) & 0x01) != 0)
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&self) -> PIN_R {
                PIN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = ""]
            #[inline(always)]
            pub unsafe fn pin(&mut self, n: usize) -> PIN_W {
                PIN_W { w: self, offset: n }
            }
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn pin0(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 0 }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin1(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 1 }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pin2(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 2 }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn pin3(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 3 }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn pin4(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 4 }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn pin5(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 5 }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn pin6(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 6 }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn pin7(&mut self) -> PIN_W {
                PIN_W { w: self, offset: 7 }
            }
        }
    }
    #[doc = "Sync level registers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sync_level](sync_level) module"]
    pub type SYNC_LEVEL = crate::Reg<u32, _SYNC_LEVEL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SYNC_LEVEL;
    #[doc = "`read()` method returns [sync_level::R](sync_level::R) reader structure"]
    impl crate::Readable for SYNC_LEVEL {}
    #[doc = "`write(|w| ..)` method takes [sync_level::W](sync_level::W) writer structure"]
    impl crate::Writable for SYNC_LEVEL {}
    #[doc = "Sync level registers"]
    pub mod sync_level {
        #[doc = "Reader of register sync_level"]
        pub type R = crate::R<u32, super::SYNC_LEVEL>;
        #[doc = "Writer for register sync_level"]
        pub type W = crate::W<u32, super::SYNC_LEVEL>;
        #[doc = "Register sync_level `reset()`'s with value 0"]
        impl crate::ResetValue for super::SYNC_LEVEL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "ID code\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [id_code](id_code) module"]
    pub type ID_CODE = crate::Reg<u32, _ID_CODE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ID_CODE;
    #[doc = "`read()` method returns [id_code::R](id_code::R) reader structure"]
    impl crate::Readable for ID_CODE {}
    #[doc = "`write(|w| ..)` method takes [id_code::W](id_code::W) writer structure"]
    impl crate::Writable for ID_CODE {}
    #[doc = "ID code"]
    pub mod id_code {
        #[doc = "Reader of register id_code"]
        pub type R = crate::R<u32, super::ID_CODE>;
        #[doc = "Writer for register id_code"]
        pub type W = crate::W<u32, super::ID_CODE>;
        #[doc = "Register id_code `reset()`'s with value 0"]
        impl crate::ResetValue for super::ID_CODE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt both edge type\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_bothedge](interrupt_bothedge) module"]
    pub type INTERRUPT_BOTHEDGE = crate::Reg<u32, _INTERRUPT_BOTHEDGE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_BOTHEDGE;
    #[doc = "`read()` method returns [interrupt_bothedge::R](interrupt_bothedge::R) reader structure"]
    impl crate::Readable for INTERRUPT_BOTHEDGE {}
    #[doc = "`write(|w| ..)` method takes [interrupt_bothedge::W](interrupt_bothedge::W) writer structure"]
    impl crate::Writable for INTERRUPT_BOTHEDGE {}
    #[doc = "Interrupt both edge type"]
    pub mod interrupt_bothedge {
        #[doc = "Reader of register interrupt_bothedge"]
        pub type R = crate::R<u32, super::INTERRUPT_BOTHEDGE>;
        #[doc = "Writer for register interrupt_bothedge"]
        pub type W = crate::W<u32, super::INTERRUPT_BOTHEDGE>;
        #[doc = "Register interrupt_bothedge `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_BOTHEDGE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 1"]
pub struct UART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART1 {}
impl UART1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        0x5021_0000 as *const _
    }
}
impl Deref for UART1 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*UART1::ptr() }
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 1"]
pub mod uart1 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Receive Buffer Register / Divisor Latch (Low) / Transmit Holding Register (depending on context and R/W)"]
        pub rbr_dll_thr: RBR_DLL_THR,
        #[doc = "0x04 - Divisor Latch (High) / Interrupt Enable Register"]
        pub dlh_ier: DLH_IER,
        #[doc = "0x08 - FIFO Control Register / Interrupt Identification Register"]
        pub fcr_iir: FCR_IIR,
        #[doc = "0x0c - Line Control Register"]
        pub lcr: LCR,
        #[doc = "0x10 - Modem Control Register"]
        pub mcr: MCR,
        #[doc = "0x14 - Line Status Register"]
        pub lsr: LSR,
        #[doc = "0x18 - Modem Status Register"]
        pub msr: MSR,
        #[doc = "0x1c - Scratchpad Register"]
        pub scr: SCR,
        #[doc = "0x20 - Low Power Divisor Latch (Low) Register"]
        pub lpdll: LPDLL,
        #[doc = "0x24 - Low Power Divisor Latch (High) Register"]
        pub lpdlh: LPDLH,
        _reserved10: [u8; 8usize],
        #[doc = "0x30 - Shadow Receive Buffer Register / Shadow Transmit Holding Register (depending on R/W)"]
        pub srbr_sthr: [SRBR_STHR; 16],
        #[doc = "0x70 - FIFO Access Register"]
        pub far: FAR,
        #[doc = "0x74 - Transmit FIFO Read Register"]
        pub tfr: TFR,
        #[doc = "0x78 - Receive FIFO Write Register"]
        pub rfw: RFW,
        #[doc = "0x7c - UART Status Register"]
        pub usr: USR,
        #[doc = "0x80 - Transmit FIFO Level"]
        pub tfl: TFL,
        #[doc = "0x84 - Receive FIFO Level"]
        pub rfl: RFL,
        #[doc = "0x88 - Software Reset Register"]
        pub srr: SRR,
        #[doc = "0x8c - Shadow Request to Send Register"]
        pub srts: SRTS,
        #[doc = "0x90 - Shadow Break Control Register"]
        pub sbcr: SBCR,
        #[doc = "0x94 - Shadow DMA Mode"]
        pub sdmam: SDMAM,
        #[doc = "0x98 - Shadow FIFO Enable"]
        pub sfe: SFE,
        #[doc = "0x9c - Shadow RCVR Trigger Register"]
        pub srt: SRT,
        #[doc = "0xa0 - Shadow TX Empty Trigger Register"]
        pub stet: STET,
        #[doc = "0xa4 - Halt TX Regster"]
        pub htx: HTX,
        #[doc = "0xa8 - DMA Software Acknowledge Register"]
        pub dmasa: DMASA,
        #[doc = "0xac - Transfer Control Register"]
        pub tcr: TCR,
        #[doc = "0xb0 - DE Enable Register"]
        pub de_en: DE_EN,
        #[doc = "0xb4 - RE Enable Register"]
        pub re_en: RE_EN,
        #[doc = "0xb8 - DE Assertion Time Register"]
        pub det: DET,
        #[doc = "0xbc - Turn-Around Time Register"]
        pub tat: TAT,
        #[doc = "0xc0 - Divisor Latch (Fractional) Register"]
        pub dlf: DLF,
        #[doc = "0xc4 - Receive-Mode Address Register"]
        pub rar: RAR,
        #[doc = "0xc8 - Transmit-Mode Address Register"]
        pub tar: TAR,
        #[doc = "0xcc - Line Control Register (Extended)"]
        pub lcr_ext: LCR_EXT,
        _reserved35: [u8; 36usize],
        #[doc = "0xf4 - Component Parameter Register"]
        pub cpr: CPR,
        #[doc = "0xf8 - UART Component Version"]
        pub ucv: UCV,
        #[doc = "0xfc - Component Type Register"]
        pub ctr: CTR,
    }
    #[doc = "Receive Buffer Register / Divisor Latch (Low) / Transmit Holding Register (depending on context and R/W)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rbr_dll_thr](rbr_dll_thr) module"]
    pub type RBR_DLL_THR = crate::Reg<u32, _RBR_DLL_THR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RBR_DLL_THR;
    #[doc = "`read()` method returns [rbr_dll_thr::R](rbr_dll_thr::R) reader structure"]
    impl crate::Readable for RBR_DLL_THR {}
    #[doc = "`write(|w| ..)` method takes [rbr_dll_thr::W](rbr_dll_thr::W) writer structure"]
    impl crate::Writable for RBR_DLL_THR {}
    #[doc = "Receive Buffer Register / Divisor Latch (Low) / Transmit Holding Register (depending on context and R/W)"]
    pub mod rbr_dll_thr {
        #[doc = "Reader of register rbr_dll_thr"]
        pub type R = crate::R<u32, super::RBR_DLL_THR>;
        #[doc = "Writer for register rbr_dll_thr"]
        pub type W = crate::W<u32, super::RBR_DLL_THR>;
        #[doc = "Register rbr_dll_thr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RBR_DLL_THR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Divisor Latch (High) / Interrupt Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dlh_ier](dlh_ier) module"]
    pub type DLH_IER = crate::Reg<u32, _DLH_IER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DLH_IER;
    #[doc = "`read()` method returns [dlh_ier::R](dlh_ier::R) reader structure"]
    impl crate::Readable for DLH_IER {}
    #[doc = "`write(|w| ..)` method takes [dlh_ier::W](dlh_ier::W) writer structure"]
    impl crate::Writable for DLH_IER {}
    #[doc = "Divisor Latch (High) / Interrupt Enable Register"]
    pub mod dlh_ier {
        #[doc = "Reader of register dlh_ier"]
        pub type R = crate::R<u32, super::DLH_IER>;
        #[doc = "Writer for register dlh_ier"]
        pub type W = crate::W<u32, super::DLH_IER>;
        #[doc = "Register dlh_ier `reset()`'s with value 0"]
        impl crate::ResetValue for super::DLH_IER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "FIFO Control Register / Interrupt Identification Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fcr_iir](fcr_iir) module"]
    pub type FCR_IIR = crate::Reg<u32, _FCR_IIR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FCR_IIR;
    #[doc = "`read()` method returns [fcr_iir::R](fcr_iir::R) reader structure"]
    impl crate::Readable for FCR_IIR {}
    #[doc = "`write(|w| ..)` method takes [fcr_iir::W](fcr_iir::W) writer structure"]
    impl crate::Writable for FCR_IIR {}
    #[doc = "FIFO Control Register / Interrupt Identification Register"]
    pub mod fcr_iir {
        #[doc = "Reader of register fcr_iir"]
        pub type R = crate::R<u32, super::FCR_IIR>;
        #[doc = "Writer for register fcr_iir"]
        pub type W = crate::W<u32, super::FCR_IIR>;
        #[doc = "Register fcr_iir `reset()`'s with value 0"]
        impl crate::ResetValue for super::FCR_IIR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Line Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lcr](lcr) module"]
    pub type LCR = crate::Reg<u32, _LCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LCR;
    #[doc = "`read()` method returns [lcr::R](lcr::R) reader structure"]
    impl crate::Readable for LCR {}
    #[doc = "`write(|w| ..)` method takes [lcr::W](lcr::W) writer structure"]
    impl crate::Writable for LCR {}
    #[doc = "Line Control Register"]
    pub mod lcr {
        #[doc = "Reader of register lcr"]
        pub type R = crate::R<u32, super::LCR>;
        #[doc = "Writer for register lcr"]
        pub type W = crate::W<u32, super::LCR>;
        #[doc = "Register lcr `reset()`'s with value 0"]
        impl crate::ResetValue for super::LCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Modem Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mcr](mcr) module"]
    pub type MCR = crate::Reg<u32, _MCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MCR;
    #[doc = "`read()` method returns [mcr::R](mcr::R) reader structure"]
    impl crate::Readable for MCR {}
    #[doc = "`write(|w| ..)` method takes [mcr::W](mcr::W) writer structure"]
    impl crate::Writable for MCR {}
    #[doc = "Modem Control Register"]
    pub mod mcr {
        #[doc = "Reader of register mcr"]
        pub type R = crate::R<u32, super::MCR>;
        #[doc = "Writer for register mcr"]
        pub type W = crate::W<u32, super::MCR>;
        #[doc = "Register mcr `reset()`'s with value 0"]
        impl crate::ResetValue for super::MCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Line Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lsr](lsr) module"]
    pub type LSR = crate::Reg<u32, _LSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LSR;
    #[doc = "`read()` method returns [lsr::R](lsr::R) reader structure"]
    impl crate::Readable for LSR {}
    #[doc = "`write(|w| ..)` method takes [lsr::W](lsr::W) writer structure"]
    impl crate::Writable for LSR {}
    #[doc = "Line Status Register"]
    pub mod lsr {
        #[doc = "Reader of register lsr"]
        pub type R = crate::R<u32, super::LSR>;
        #[doc = "Writer for register lsr"]
        pub type W = crate::W<u32, super::LSR>;
        #[doc = "Register lsr `reset()`'s with value 0"]
        impl crate::ResetValue for super::LSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Modem Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msr](msr) module"]
    pub type MSR = crate::Reg<u32, _MSR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MSR;
    #[doc = "`read()` method returns [msr::R](msr::R) reader structure"]
    impl crate::Readable for MSR {}
    #[doc = "`write(|w| ..)` method takes [msr::W](msr::W) writer structure"]
    impl crate::Writable for MSR {}
    #[doc = "Modem Status Register"]
    pub mod msr {
        #[doc = "Reader of register msr"]
        pub type R = crate::R<u32, super::MSR>;
        #[doc = "Writer for register msr"]
        pub type W = crate::W<u32, super::MSR>;
        #[doc = "Register msr `reset()`'s with value 0"]
        impl crate::ResetValue for super::MSR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Scratchpad Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [scr](scr) module"]
    pub type SCR = crate::Reg<u32, _SCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SCR;
    #[doc = "`read()` method returns [scr::R](scr::R) reader structure"]
    impl crate::Readable for SCR {}
    #[doc = "`write(|w| ..)` method takes [scr::W](scr::W) writer structure"]
    impl crate::Writable for SCR {}
    #[doc = "Scratchpad Register"]
    pub mod scr {
        #[doc = "Reader of register scr"]
        pub type R = crate::R<u32, super::SCR>;
        #[doc = "Writer for register scr"]
        pub type W = crate::W<u32, super::SCR>;
        #[doc = "Register scr `reset()`'s with value 0"]
        impl crate::ResetValue for super::SCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Low Power Divisor Latch (Low) Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lpdll](lpdll) module"]
    pub type LPDLL = crate::Reg<u32, _LPDLL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LPDLL;
    #[doc = "`read()` method returns [lpdll::R](lpdll::R) reader structure"]
    impl crate::Readable for LPDLL {}
    #[doc = "`write(|w| ..)` method takes [lpdll::W](lpdll::W) writer structure"]
    impl crate::Writable for LPDLL {}
    #[doc = "Low Power Divisor Latch (Low) Register"]
    pub mod lpdll {
        #[doc = "Reader of register lpdll"]
        pub type R = crate::R<u32, super::LPDLL>;
        #[doc = "Writer for register lpdll"]
        pub type W = crate::W<u32, super::LPDLL>;
        #[doc = "Register lpdll `reset()`'s with value 0"]
        impl crate::ResetValue for super::LPDLL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Low Power Divisor Latch (High) Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lpdlh](lpdlh) module"]
    pub type LPDLH = crate::Reg<u32, _LPDLH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LPDLH;
    #[doc = "`read()` method returns [lpdlh::R](lpdlh::R) reader structure"]
    impl crate::Readable for LPDLH {}
    #[doc = "`write(|w| ..)` method takes [lpdlh::W](lpdlh::W) writer structure"]
    impl crate::Writable for LPDLH {}
    #[doc = "Low Power Divisor Latch (High) Register"]
    pub mod lpdlh {
        #[doc = "Reader of register lpdlh"]
        pub type R = crate::R<u32, super::LPDLH>;
        #[doc = "Writer for register lpdlh"]
        pub type W = crate::W<u32, super::LPDLH>;
        #[doc = "Register lpdlh `reset()`'s with value 0"]
        impl crate::ResetValue for super::LPDLH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Shadow Receive Buffer Register / Shadow Transmit Holding Register (depending on R/W)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [srbr_sthr](srbr_sthr) module"]
    pub type SRBR_STHR = crate::Reg<u32, _SRBR_STHR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SRBR_STHR;
    #[doc = "`read()` method returns [srbr_sthr::R](srbr_sthr::R) reader structure"]
    impl crate::Readable for SRBR_STHR {}
    #[doc = "`write(|w| ..)` method takes [srbr_sthr::W](srbr_sthr::W) writer structure"]
    impl crate::Writable for SRBR_STHR {}
    #[doc = "Shadow Receive Buffer Register / Shadow Transmit Holding Register (depending on R/W)"]
    pub mod srbr_sthr {
        #[doc = "Reader of register srbr_sthr[%s]"]
        pub type R = crate::R<u32, super::SRBR_STHR>;
        #[doc = "Writer for register srbr_sthr[%s]"]
        pub type W = crate::W<u32, super::SRBR_STHR>;
        #[doc = "Register srbr_sthr[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::SRBR_STHR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "FIFO Access Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [far](far) module"]
    pub type FAR = crate::Reg<u32, _FAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FAR;
    #[doc = "`read()` method returns [far::R](far::R) reader structure"]
    impl crate::Readable for FAR {}
    #[doc = "`write(|w| ..)` method takes [far::W](far::W) writer structure"]
    impl crate::Writable for FAR {}
    #[doc = "FIFO Access Register"]
    pub mod far {
        #[doc = "Reader of register far"]
        pub type R = crate::R<u32, super::FAR>;
        #[doc = "Writer for register far"]
        pub type W = crate::W<u32, super::FAR>;
        #[doc = "Register far `reset()`'s with value 0"]
        impl crate::ResetValue for super::FAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Read Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tfr](tfr) module"]
    pub type TFR = crate::Reg<u32, _TFR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TFR;
    #[doc = "`read()` method returns [tfr::R](tfr::R) reader structure"]
    impl crate::Readable for TFR {}
    #[doc = "`write(|w| ..)` method takes [tfr::W](tfr::W) writer structure"]
    impl crate::Writable for TFR {}
    #[doc = "Transmit FIFO Read Register"]
    pub mod tfr {
        #[doc = "Reader of register tfr"]
        pub type R = crate::R<u32, super::TFR>;
        #[doc = "Writer for register tfr"]
        pub type W = crate::W<u32, super::TFR>;
        #[doc = "Register tfr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TFR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Write Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rfw](rfw) module"]
    pub type RFW = crate::Reg<u32, _RFW>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RFW;
    #[doc = "`read()` method returns [rfw::R](rfw::R) reader structure"]
    impl crate::Readable for RFW {}
    #[doc = "`write(|w| ..)` method takes [rfw::W](rfw::W) writer structure"]
    impl crate::Writable for RFW {}
    #[doc = "Receive FIFO Write Register"]
    pub mod rfw {
        #[doc = "Reader of register rfw"]
        pub type R = crate::R<u32, super::RFW>;
        #[doc = "Writer for register rfw"]
        pub type W = crate::W<u32, super::RFW>;
        #[doc = "Register rfw `reset()`'s with value 0"]
        impl crate::ResetValue for super::RFW {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "UART Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [usr](usr) module"]
    pub type USR = crate::Reg<u32, _USR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _USR;
    #[doc = "`read()` method returns [usr::R](usr::R) reader structure"]
    impl crate::Readable for USR {}
    #[doc = "`write(|w| ..)` method takes [usr::W](usr::W) writer structure"]
    impl crate::Writable for USR {}
    #[doc = "UART Status Register"]
    pub mod usr {
        #[doc = "Reader of register usr"]
        pub type R = crate::R<u32, super::USR>;
        #[doc = "Writer for register usr"]
        pub type W = crate::W<u32, super::USR>;
        #[doc = "Register usr `reset()`'s with value 0"]
        impl crate::ResetValue for super::USR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tfl](tfl) module"]
    pub type TFL = crate::Reg<u32, _TFL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TFL;
    #[doc = "`read()` method returns [tfl::R](tfl::R) reader structure"]
    impl crate::Readable for TFL {}
    #[doc = "`write(|w| ..)` method takes [tfl::W](tfl::W) writer structure"]
    impl crate::Writable for TFL {}
    #[doc = "Transmit FIFO Level"]
    pub mod tfl {
        #[doc = "Reader of register tfl"]
        pub type R = crate::R<u32, super::TFL>;
        #[doc = "Writer for register tfl"]
        pub type W = crate::W<u32, super::TFL>;
        #[doc = "Register tfl `reset()`'s with value 0"]
        impl crate::ResetValue for super::TFL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rfl](rfl) module"]
    pub type RFL = crate::Reg<u32, _RFL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RFL;
    #[doc = "`read()` method returns [rfl::R](rfl::R) reader structure"]
    impl crate::Readable for RFL {}
    #[doc = "`write(|w| ..)` method takes [rfl::W](rfl::W) writer structure"]
    impl crate::Writable for RFL {}
    #[doc = "Receive FIFO Level"]
    pub mod rfl {
        #[doc = "Reader of register rfl"]
        pub type R = crate::R<u32, super::RFL>;
        #[doc = "Writer for register rfl"]
        pub type W = crate::W<u32, super::RFL>;
        #[doc = "Register rfl `reset()`'s with value 0"]
        impl crate::ResetValue for super::RFL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Software Reset Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [srr](srr) module"]
    pub type SRR = crate::Reg<u32, _SRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SRR;
    #[doc = "`read()` method returns [srr::R](srr::R) reader structure"]
    impl crate::Readable for SRR {}
    #[doc = "`write(|w| ..)` method takes [srr::W](srr::W) writer structure"]
    impl crate::Writable for SRR {}
    #[doc = "Software Reset Register"]
    pub mod srr {
        #[doc = "Reader of register srr"]
        pub type R = crate::R<u32, super::SRR>;
        #[doc = "Writer for register srr"]
        pub type W = crate::W<u32, super::SRR>;
        #[doc = "Register srr `reset()`'s with value 0"]
        impl crate::ResetValue for super::SRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Shadow Request to Send Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [srts](srts) module"]
    pub type SRTS = crate::Reg<u32, _SRTS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SRTS;
    #[doc = "`read()` method returns [srts::R](srts::R) reader structure"]
    impl crate::Readable for SRTS {}
    #[doc = "`write(|w| ..)` method takes [srts::W](srts::W) writer structure"]
    impl crate::Writable for SRTS {}
    #[doc = "Shadow Request to Send Register"]
    pub mod srts {
        #[doc = "Reader of register srts"]
        pub type R = crate::R<u32, super::SRTS>;
        #[doc = "Writer for register srts"]
        pub type W = crate::W<u32, super::SRTS>;
        #[doc = "Register srts `reset()`'s with value 0"]
        impl crate::ResetValue for super::SRTS {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Shadow Break Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sbcr](sbcr) module"]
    pub type SBCR = crate::Reg<u32, _SBCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SBCR;
    #[doc = "`read()` method returns [sbcr::R](sbcr::R) reader structure"]
    impl crate::Readable for SBCR {}
    #[doc = "`write(|w| ..)` method takes [sbcr::W](sbcr::W) writer structure"]
    impl crate::Writable for SBCR {}
    #[doc = "Shadow Break Control Register"]
    pub mod sbcr {
        #[doc = "Reader of register sbcr"]
        pub type R = crate::R<u32, super::SBCR>;
        #[doc = "Writer for register sbcr"]
        pub type W = crate::W<u32, super::SBCR>;
        #[doc = "Register sbcr `reset()`'s with value 0"]
        impl crate::ResetValue for super::SBCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Shadow DMA Mode\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sdmam](sdmam) module"]
    pub type SDMAM = crate::Reg<u32, _SDMAM>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SDMAM;
    #[doc = "`read()` method returns [sdmam::R](sdmam::R) reader structure"]
    impl crate::Readable for SDMAM {}
    #[doc = "`write(|w| ..)` method takes [sdmam::W](sdmam::W) writer structure"]
    impl crate::Writable for SDMAM {}
    #[doc = "Shadow DMA Mode"]
    pub mod sdmam {
        #[doc = "Reader of register sdmam"]
        pub type R = crate::R<u32, super::SDMAM>;
        #[doc = "Writer for register sdmam"]
        pub type W = crate::W<u32, super::SDMAM>;
        #[doc = "Register sdmam `reset()`'s with value 0"]
        impl crate::ResetValue for super::SDMAM {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Shadow FIFO Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sfe](sfe) module"]
    pub type SFE = crate::Reg<u32, _SFE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SFE;
    #[doc = "`read()` method returns [sfe::R](sfe::R) reader structure"]
    impl crate::Readable for SFE {}
    #[doc = "`write(|w| ..)` method takes [sfe::W](sfe::W) writer structure"]
    impl crate::Writable for SFE {}
    #[doc = "Shadow FIFO Enable"]
    pub mod sfe {
        #[doc = "Reader of register sfe"]
        pub type R = crate::R<u32, super::SFE>;
        #[doc = "Writer for register sfe"]
        pub type W = crate::W<u32, super::SFE>;
        #[doc = "Register sfe `reset()`'s with value 0"]
        impl crate::ResetValue for super::SFE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Shadow RCVR Trigger Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [srt](srt) module"]
    pub type SRT = crate::Reg<u32, _SRT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SRT;
    #[doc = "`read()` method returns [srt::R](srt::R) reader structure"]
    impl crate::Readable for SRT {}
    #[doc = "`write(|w| ..)` method takes [srt::W](srt::W) writer structure"]
    impl crate::Writable for SRT {}
    #[doc = "Shadow RCVR Trigger Register"]
    pub mod srt {
        #[doc = "Reader of register srt"]
        pub type R = crate::R<u32, super::SRT>;
        #[doc = "Writer for register srt"]
        pub type W = crate::W<u32, super::SRT>;
        #[doc = "Register srt `reset()`'s with value 0"]
        impl crate::ResetValue for super::SRT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Shadow TX Empty Trigger Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [stet](stet) module"]
    pub type STET = crate::Reg<u32, _STET>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _STET;
    #[doc = "`read()` method returns [stet::R](stet::R) reader structure"]
    impl crate::Readable for STET {}
    #[doc = "`write(|w| ..)` method takes [stet::W](stet::W) writer structure"]
    impl crate::Writable for STET {}
    #[doc = "Shadow TX Empty Trigger Register"]
    pub mod stet {
        #[doc = "Reader of register stet"]
        pub type R = crate::R<u32, super::STET>;
        #[doc = "Writer for register stet"]
        pub type W = crate::W<u32, super::STET>;
        #[doc = "Register stet `reset()`'s with value 0"]
        impl crate::ResetValue for super::STET {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Halt TX Regster\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [htx](htx) module"]
    pub type HTX = crate::Reg<u32, _HTX>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _HTX;
    #[doc = "`read()` method returns [htx::R](htx::R) reader structure"]
    impl crate::Readable for HTX {}
    #[doc = "`write(|w| ..)` method takes [htx::W](htx::W) writer structure"]
    impl crate::Writable for HTX {}
    #[doc = "Halt TX Regster"]
    pub mod htx {
        #[doc = "Reader of register htx"]
        pub type R = crate::R<u32, super::HTX>;
        #[doc = "Writer for register htx"]
        pub type W = crate::W<u32, super::HTX>;
        #[doc = "Register htx `reset()`'s with value 0"]
        impl crate::ResetValue for super::HTX {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DMA Software Acknowledge Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmasa](dmasa) module"]
    pub type DMASA = crate::Reg<u32, _DMASA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMASA;
    #[doc = "`read()` method returns [dmasa::R](dmasa::R) reader structure"]
    impl crate::Readable for DMASA {}
    #[doc = "`write(|w| ..)` method takes [dmasa::W](dmasa::W) writer structure"]
    impl crate::Writable for DMASA {}
    #[doc = "DMA Software Acknowledge Register"]
    pub mod dmasa {
        #[doc = "Reader of register dmasa"]
        pub type R = crate::R<u32, super::DMASA>;
        #[doc = "Writer for register dmasa"]
        pub type W = crate::W<u32, super::DMASA>;
        #[doc = "Register dmasa `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMASA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transfer Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcr](tcr) module"]
    pub type TCR = crate::Reg<u32, _TCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TCR;
    #[doc = "`read()` method returns [tcr::R](tcr::R) reader structure"]
    impl crate::Readable for TCR {}
    #[doc = "`write(|w| ..)` method takes [tcr::W](tcr::W) writer structure"]
    impl crate::Writable for TCR {}
    #[doc = "Transfer Control Register"]
    pub mod tcr {
        #[doc = "Reader of register tcr"]
        pub type R = crate::R<u32, super::TCR>;
        #[doc = "Writer for register tcr"]
        pub type W = crate::W<u32, super::TCR>;
        #[doc = "Register tcr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DE Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [de_en](de_en) module"]
    pub type DE_EN = crate::Reg<u32, _DE_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DE_EN;
    #[doc = "`read()` method returns [de_en::R](de_en::R) reader structure"]
    impl crate::Readable for DE_EN {}
    #[doc = "`write(|w| ..)` method takes [de_en::W](de_en::W) writer structure"]
    impl crate::Writable for DE_EN {}
    #[doc = "DE Enable Register"]
    pub mod de_en {
        #[doc = "Reader of register de_en"]
        pub type R = crate::R<u32, super::DE_EN>;
        #[doc = "Writer for register de_en"]
        pub type W = crate::W<u32, super::DE_EN>;
        #[doc = "Register de_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::DE_EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "RE Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [re_en](re_en) module"]
    pub type RE_EN = crate::Reg<u32, _RE_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RE_EN;
    #[doc = "`read()` method returns [re_en::R](re_en::R) reader structure"]
    impl crate::Readable for RE_EN {}
    #[doc = "`write(|w| ..)` method takes [re_en::W](re_en::W) writer structure"]
    impl crate::Writable for RE_EN {}
    #[doc = "RE Enable Register"]
    pub mod re_en {
        #[doc = "Reader of register re_en"]
        pub type R = crate::R<u32, super::RE_EN>;
        #[doc = "Writer for register re_en"]
        pub type W = crate::W<u32, super::RE_EN>;
        #[doc = "Register re_en `reset()`'s with value 0"]
        impl crate::ResetValue for super::RE_EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DE Assertion Time Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [det](det) module"]
    pub type DET = crate::Reg<u32, _DET>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DET;
    #[doc = "`read()` method returns [det::R](det::R) reader structure"]
    impl crate::Readable for DET {}
    #[doc = "`write(|w| ..)` method takes [det::W](det::W) writer structure"]
    impl crate::Writable for DET {}
    #[doc = "DE Assertion Time Register"]
    pub mod det {
        #[doc = "Reader of register det"]
        pub type R = crate::R<u32, super::DET>;
        #[doc = "Writer for register det"]
        pub type W = crate::W<u32, super::DET>;
        #[doc = "Register det `reset()`'s with value 0"]
        impl crate::ResetValue for super::DET {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Turn-Around Time Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tat](tat) module"]
    pub type TAT = crate::Reg<u32, _TAT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TAT;
    #[doc = "`read()` method returns [tat::R](tat::R) reader structure"]
    impl crate::Readable for TAT {}
    #[doc = "`write(|w| ..)` method takes [tat::W](tat::W) writer structure"]
    impl crate::Writable for TAT {}
    #[doc = "Turn-Around Time Register"]
    pub mod tat {
        #[doc = "Reader of register tat"]
        pub type R = crate::R<u32, super::TAT>;
        #[doc = "Writer for register tat"]
        pub type W = crate::W<u32, super::TAT>;
        #[doc = "Register tat `reset()`'s with value 0"]
        impl crate::ResetValue for super::TAT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Divisor Latch (Fractional) Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dlf](dlf) module"]
    pub type DLF = crate::Reg<u32, _DLF>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DLF;
    #[doc = "`read()` method returns [dlf::R](dlf::R) reader structure"]
    impl crate::Readable for DLF {}
    #[doc = "`write(|w| ..)` method takes [dlf::W](dlf::W) writer structure"]
    impl crate::Writable for DLF {}
    #[doc = "Divisor Latch (Fractional) Register"]
    pub mod dlf {
        #[doc = "Reader of register dlf"]
        pub type R = crate::R<u32, super::DLF>;
        #[doc = "Writer for register dlf"]
        pub type W = crate::W<u32, super::DLF>;
        #[doc = "Register dlf `reset()`'s with value 0"]
        impl crate::ResetValue for super::DLF {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive-Mode Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rar](rar) module"]
    pub type RAR = crate::Reg<u32, _RAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RAR;
    #[doc = "`read()` method returns [rar::R](rar::R) reader structure"]
    impl crate::Readable for RAR {}
    #[doc = "`write(|w| ..)` method takes [rar::W](rar::W) writer structure"]
    impl crate::Writable for RAR {}
    #[doc = "Receive-Mode Address Register"]
    pub mod rar {
        #[doc = "Reader of register rar"]
        pub type R = crate::R<u32, super::RAR>;
        #[doc = "Writer for register rar"]
        pub type W = crate::W<u32, super::RAR>;
        #[doc = "Register rar `reset()`'s with value 0"]
        impl crate::ResetValue for super::RAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit-Mode Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tar](tar) module"]
    pub type TAR = crate::Reg<u32, _TAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TAR;
    #[doc = "`read()` method returns [tar::R](tar::R) reader structure"]
    impl crate::Readable for TAR {}
    #[doc = "`write(|w| ..)` method takes [tar::W](tar::W) writer structure"]
    impl crate::Writable for TAR {}
    #[doc = "Transmit-Mode Address Register"]
    pub mod tar {
        #[doc = "Reader of register tar"]
        pub type R = crate::R<u32, super::TAR>;
        #[doc = "Writer for register tar"]
        pub type W = crate::W<u32, super::TAR>;
        #[doc = "Register tar `reset()`'s with value 0"]
        impl crate::ResetValue for super::TAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Line Control Register (Extended)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [lcr_ext](lcr_ext) module"]
    pub type LCR_EXT = crate::Reg<u32, _LCR_EXT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LCR_EXT;
    #[doc = "`read()` method returns [lcr_ext::R](lcr_ext::R) reader structure"]
    impl crate::Readable for LCR_EXT {}
    #[doc = "`write(|w| ..)` method takes [lcr_ext::W](lcr_ext::W) writer structure"]
    impl crate::Writable for LCR_EXT {}
    #[doc = "Line Control Register (Extended)"]
    pub mod lcr_ext {
        #[doc = "Reader of register lcr_ext"]
        pub type R = crate::R<u32, super::LCR_EXT>;
        #[doc = "Writer for register lcr_ext"]
        pub type W = crate::W<u32, super::LCR_EXT>;
        #[doc = "Register lcr_ext `reset()`'s with value 0"]
        impl crate::ResetValue for super::LCR_EXT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Parameter Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cpr](cpr) module"]
    pub type CPR = crate::Reg<u32, _CPR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CPR;
    #[doc = "`read()` method returns [cpr::R](cpr::R) reader structure"]
    impl crate::Readable for CPR {}
    #[doc = "`write(|w| ..)` method takes [cpr::W](cpr::W) writer structure"]
    impl crate::Writable for CPR {}
    #[doc = "Component Parameter Register"]
    pub mod cpr {
        #[doc = "Reader of register cpr"]
        pub type R = crate::R<u32, super::CPR>;
        #[doc = "Writer for register cpr"]
        pub type W = crate::W<u32, super::CPR>;
        #[doc = "Register cpr `reset()`'s with value 0"]
        impl crate::ResetValue for super::CPR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "UART Component Version\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ucv](ucv) module"]
    pub type UCV = crate::Reg<u32, _UCV>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _UCV;
    #[doc = "`read()` method returns [ucv::R](ucv::R) reader structure"]
    impl crate::Readable for UCV {}
    #[doc = "`write(|w| ..)` method takes [ucv::W](ucv::W) writer structure"]
    impl crate::Writable for UCV {}
    #[doc = "UART Component Version"]
    pub mod ucv {
        #[doc = "Reader of register ucv"]
        pub type R = crate::R<u32, super::UCV>;
        #[doc = "Writer for register ucv"]
        pub type W = crate::W<u32, super::UCV>;
        #[doc = "Register ucv `reset()`'s with value 0"]
        impl crate::ResetValue for super::UCV {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Type Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctr](ctr) module"]
    pub type CTR = crate::Reg<u32, _CTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTR;
    #[doc = "`read()` method returns [ctr::R](ctr::R) reader structure"]
    impl crate::Readable for CTR {}
    #[doc = "`write(|w| ..)` method takes [ctr::W](ctr::W) writer structure"]
    impl crate::Writable for CTR {}
    #[doc = "Component Type Register"]
    pub mod ctr {
        #[doc = "Reader of register ctr"]
        pub type R = crate::R<u32, super::CTR>;
        #[doc = "Writer for register ctr"]
        pub type W = crate::W<u32, super::CTR>;
        #[doc = "Register ctr `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 2"]
pub struct UART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART2 {}
impl UART2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        0x5022_0000 as *const _
    }
}
impl Deref for UART2 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*UART2::ptr() }
    }
}
#[doc = "Universal Asynchronous Receiver-Transmitter 3"]
pub struct UART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART3 {}
impl UART3 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart1::RegisterBlock {
        0x5023_0000 as *const _
    }
}
impl Deref for UART3 {
    type Target = uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*UART3::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 0 (master)"]
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        0x5200_0000 as *const _
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI0::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 0 (master)"]
pub mod spi0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register 0"]
        pub ctrlr0: CTRLR0,
        #[doc = "0x04 - Control Register 1"]
        pub ctrlr1: CTRLR1,
        #[doc = "0x08 - Enable Register"]
        pub ssienr: SSIENR,
        #[doc = "0x0c - Microwire Control Register"]
        pub mwcr: MWCR,
        #[doc = "0x10 - Slave Enable Register"]
        pub ser: SER,
        #[doc = "0x14 - Baud Rate Select"]
        pub baudr: BAUDR,
        #[doc = "0x18 - Transmit FIFO Threshold Level"]
        pub txftlr: TXFTLR,
        #[doc = "0x1c - Receive FIFO Threshold Level"]
        pub rxftlr: RXFTLR,
        #[doc = "0x20 - Transmit FIFO Level Register"]
        pub txflr: TXFLR,
        #[doc = "0x24 - Receive FIFO Level Register"]
        pub rxflr: RXFLR,
        #[doc = "0x28 - Status Register"]
        pub sr: SR,
        #[doc = "0x2c - Interrupt Mask Register"]
        pub imr: IMR,
        #[doc = "0x30 - Interrupt Status Register"]
        pub isr: ISR,
        #[doc = "0x34 - Raw Interrupt Status Register"]
        pub risr: RISR,
        #[doc = "0x38 - Transmit FIFO Overflow Interrupt Clear Register"]
        pub txoicr: TXOICR,
        #[doc = "0x3c - Receive FIFO Overflow Interrupt Clear Register"]
        pub rxoicr: RXOICR,
        #[doc = "0x40 - Receive FIFO Underflow Interrupt Clear Register"]
        pub rxuicr: RXUICR,
        #[doc = "0x44 - Multi-Master Interrupt Clear Register"]
        pub msticr: MSTICR,
        #[doc = "0x48 - Interrupt Clear Register"]
        pub icr: ICR,
        #[doc = "0x4c - DMA Control Register"]
        pub dmacr: DMACR,
        #[doc = "0x50 - DMA Transmit Data Level"]
        pub dmatdlr: DMATDLR,
        #[doc = "0x54 - DMA Receive Data Level"]
        pub dmardlr: DMARDLR,
        #[doc = "0x58 - Identification Register"]
        pub idr: IDR,
        #[doc = "0x5c - DWC_ssi component version"]
        pub ssic_version_id: SSIC_VERSION_ID,
        #[doc = "0x60 - Data Register"]
        pub dr: [DR; 36],
        #[doc = "0xf0 - RX Sample Delay Register"]
        pub rx_sample_delay: RX_SAMPLE_DELAY,
        #[doc = "0xf4 - SPI Control Register"]
        pub spi_ctrlr0: SPI_CTRLR0,
        _reserved27: [u8; 4usize],
        #[doc = "0xfc - XIP Mode bits"]
        pub xip_mode_bits: XIP_MODE_BITS,
        #[doc = "0x100 - XIP INCR transfer opcode"]
        pub xip_incr_inst: XIP_INCR_INST,
        #[doc = "0x104 - XIP WRAP transfer opcode"]
        pub xip_wrap_inst: XIP_WRAP_INST,
        #[doc = "0x108 - XIP Control Register"]
        pub xip_ctrl: XIP_CTRL,
        #[doc = "0x10c - XIP Slave Enable Register"]
        pub xip_ser: XIP_SER,
        #[doc = "0x110 - XIP Receive FIFO Overflow Interrupt Clear Register"]
        pub xrxoicr: XRXOICR,
        #[doc = "0x114 - XIP time out register for continuous transfers"]
        pub xip_cnt_time_out: XIP_CNT_TIME_OUT,
        #[doc = "0x118 - ENDIAN"]
        pub endian: ENDIAN,
    }
    #[doc = "Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlr0](ctrlr0) module"]
    pub type CTRLR0 = crate::Reg<u32, _CTRLR0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTRLR0;
    #[doc = "`read()` method returns [ctrlr0::R](ctrlr0::R) reader structure"]
    impl crate::Readable for CTRLR0 {}
    #[doc = "`write(|w| ..)` method takes [ctrlr0::W](ctrlr0::W) writer structure"]
    impl crate::Writable for CTRLR0 {}
    #[doc = "Control Register 0"]
    pub mod ctrlr0 {
        #[doc = "Reader of register ctrlr0"]
        pub type R = crate::R<u32, super::CTRLR0>;
        #[doc = "Writer for register ctrlr0"]
        pub type W = crate::W<u32, super::CTRLR0>;
        #[doc = "Register ctrlr0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTRLR0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "WORK_MODE\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WORK_MODE_A {
            #[doc = "0: MODE_0"]
            MODE0 = 0,
            #[doc = "1: MODE_1"]
            MODE1 = 1,
            #[doc = "2: MODE_2"]
            MODE2 = 2,
            #[doc = "3: MODE_3"]
            MODE3 = 3,
        }
        impl From<WORK_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: WORK_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `work_mode`"]
        pub type WORK_MODE_R = crate::R<u8, WORK_MODE_A>;
        impl WORK_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WORK_MODE_A {
                match self.bits {
                    0 => WORK_MODE_A::MODE0,
                    1 => WORK_MODE_A::MODE1,
                    2 => WORK_MODE_A::MODE2,
                    3 => WORK_MODE_A::MODE3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MODE0`"]
            #[inline(always)]
            pub fn is_mode0(&self) -> bool {
                *self == WORK_MODE_A::MODE0
            }
            #[doc = "Checks if the value of the field is `MODE1`"]
            #[inline(always)]
            pub fn is_mode1(&self) -> bool {
                *self == WORK_MODE_A::MODE1
            }
            #[doc = "Checks if the value of the field is `MODE2`"]
            #[inline(always)]
            pub fn is_mode2(&self) -> bool {
                *self == WORK_MODE_A::MODE2
            }
            #[doc = "Checks if the value of the field is `MODE3`"]
            #[inline(always)]
            pub fn is_mode3(&self) -> bool {
                *self == WORK_MODE_A::MODE3
            }
        }
        #[doc = "Write proxy for field `work_mode`"]
        pub struct WORK_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WORK_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WORK_MODE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "MODE_0"]
            #[inline(always)]
            pub fn mode0(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE0)
            }
            #[doc = "MODE_1"]
            #[inline(always)]
            pub fn mode1(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE1)
            }
            #[doc = "MODE_2"]
            #[inline(always)]
            pub fn mode2(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE2)
            }
            #[doc = "MODE_3"]
            #[inline(always)]
            pub fn mode3(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | (((value as u32) & 0x03) << 6);
                self.w
            }
        }
        #[doc = "TRANSFER_MODE\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TMOD_A {
            #[doc = "0: TRANS_RECV"]
            TRANS_RECV = 0,
            #[doc = "1: TRANS"]
            TRANS = 1,
            #[doc = "2: RECV"]
            RECV = 2,
            #[doc = "3: EEROM"]
            EEROM = 3,
        }
        impl From<TMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: TMOD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `tmod`"]
        pub type TMOD_R = crate::R<u8, TMOD_A>;
        impl TMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TMOD_A {
                match self.bits {
                    0 => TMOD_A::TRANS_RECV,
                    1 => TMOD_A::TRANS,
                    2 => TMOD_A::RECV,
                    3 => TMOD_A::EEROM,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TRANS_RECV`"]
            #[inline(always)]
            pub fn is_trans_recv(&self) -> bool {
                *self == TMOD_A::TRANS_RECV
            }
            #[doc = "Checks if the value of the field is `TRANS`"]
            #[inline(always)]
            pub fn is_trans(&self) -> bool {
                *self == TMOD_A::TRANS
            }
            #[doc = "Checks if the value of the field is `RECV`"]
            #[inline(always)]
            pub fn is_recv(&self) -> bool {
                *self == TMOD_A::RECV
            }
            #[doc = "Checks if the value of the field is `EEROM`"]
            #[inline(always)]
            pub fn is_eerom(&self) -> bool {
                *self == TMOD_A::EEROM
            }
        }
        #[doc = "Write proxy for field `tmod`"]
        pub struct TMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TMOD_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "TRANS_RECV"]
            #[inline(always)]
            pub fn trans_recv(self) -> &'a mut W {
                self.variant(TMOD_A::TRANS_RECV)
            }
            #[doc = "TRANS"]
            #[inline(always)]
            pub fn trans(self) -> &'a mut W {
                self.variant(TMOD_A::TRANS)
            }
            #[doc = "RECV"]
            #[inline(always)]
            pub fn recv(self) -> &'a mut W {
                self.variant(TMOD_A::RECV)
            }
            #[doc = "EEROM"]
            #[inline(always)]
            pub fn eerom(self) -> &'a mut W {
                self.variant(TMOD_A::EEROM)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "FRAME_FORMAT\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum FRAME_FORMAT_A {
            #[doc = "0: STANDARD"]
            STANDARD = 0,
            #[doc = "1: DUAL"]
            DUAL = 1,
            #[doc = "2: QUAD"]
            QUAD = 2,
            #[doc = "3: OCTAL"]
            OCTAL = 3,
        }
        impl From<FRAME_FORMAT_A> for u8 {
            #[inline(always)]
            fn from(variant: FRAME_FORMAT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `frame_format`"]
        pub type FRAME_FORMAT_R = crate::R<u8, FRAME_FORMAT_A>;
        impl FRAME_FORMAT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FRAME_FORMAT_A {
                match self.bits {
                    0 => FRAME_FORMAT_A::STANDARD,
                    1 => FRAME_FORMAT_A::DUAL,
                    2 => FRAME_FORMAT_A::QUAD,
                    3 => FRAME_FORMAT_A::OCTAL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == FRAME_FORMAT_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline(always)]
            pub fn is_dual(&self) -> bool {
                *self == FRAME_FORMAT_A::DUAL
            }
            #[doc = "Checks if the value of the field is `QUAD`"]
            #[inline(always)]
            pub fn is_quad(&self) -> bool {
                *self == FRAME_FORMAT_A::QUAD
            }
            #[doc = "Checks if the value of the field is `OCTAL`"]
            #[inline(always)]
            pub fn is_octal(&self) -> bool {
                *self == FRAME_FORMAT_A::OCTAL
            }
        }
        #[doc = "Write proxy for field `frame_format`"]
        pub struct FRAME_FORMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FRAME_FORMAT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FRAME_FORMAT_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "STANDARD"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::STANDARD)
            }
            #[doc = "DUAL"]
            #[inline(always)]
            pub fn dual(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::DUAL)
            }
            #[doc = "QUAD"]
            #[inline(always)]
            pub fn quad(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::QUAD)
            }
            #[doc = "OCTAL"]
            #[inline(always)]
            pub fn octal(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::OCTAL)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 21)) | (((value as u32) & 0x03) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `data_length`"]
        pub type DATA_LENGTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `data_length`"]
        pub struct DATA_LENGTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_LENGTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 16)) | (((value as u32) & 0x1f) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 6:7 - WORK_MODE"]
            #[inline(always)]
            pub fn work_mode(&self) -> WORK_MODE_R {
                WORK_MODE_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            #[doc = "Bits 8:9 - TRANSFER_MODE"]
            #[inline(always)]
            pub fn tmod(&self) -> TMOD_R {
                TMOD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 21:22 - FRAME_FORMAT"]
            #[inline(always)]
            pub fn frame_format(&self) -> FRAME_FORMAT_R {
                FRAME_FORMAT_R::new(((self.bits >> 21) & 0x03) as u8)
            }
            #[doc = "Bits 16:20 - DATA_BIT_LENGTH"]
            #[inline(always)]
            pub fn data_length(&self) -> DATA_LENGTH_R {
                DATA_LENGTH_R::new(((self.bits >> 16) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 6:7 - WORK_MODE"]
            #[inline(always)]
            pub fn work_mode(&mut self) -> WORK_MODE_W {
                WORK_MODE_W { w: self }
            }
            #[doc = "Bits 8:9 - TRANSFER_MODE"]
            #[inline(always)]
            pub fn tmod(&mut self) -> TMOD_W {
                TMOD_W { w: self }
            }
            #[doc = "Bits 21:22 - FRAME_FORMAT"]
            #[inline(always)]
            pub fn frame_format(&mut self) -> FRAME_FORMAT_W {
                FRAME_FORMAT_W { w: self }
            }
            #[doc = "Bits 16:20 - DATA_BIT_LENGTH"]
            #[inline(always)]
            pub fn data_length(&mut self) -> DATA_LENGTH_W {
                DATA_LENGTH_W { w: self }
            }
        }
    }
    #[doc = "Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlr1](ctrlr1) module"]
    pub type CTRLR1 = crate::Reg<u32, _CTRLR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTRLR1;
    #[doc = "`read()` method returns [ctrlr1::R](ctrlr1::R) reader structure"]
    impl crate::Readable for CTRLR1 {}
    #[doc = "`write(|w| ..)` method takes [ctrlr1::W](ctrlr1::W) writer structure"]
    impl crate::Writable for CTRLR1 {}
    #[doc = "Control Register 1"]
    pub mod ctrlr1 {
        #[doc = "Reader of register ctrlr1"]
        pub type R = crate::R<u32, super::CTRLR1>;
        #[doc = "Writer for register ctrlr1"]
        pub type W = crate::W<u32, super::CTRLR1>;
        #[doc = "Register ctrlr1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTRLR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ssienr](ssienr) module"]
    pub type SSIENR = crate::Reg<u32, _SSIENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SSIENR;
    #[doc = "`read()` method returns [ssienr::R](ssienr::R) reader structure"]
    impl crate::Readable for SSIENR {}
    #[doc = "`write(|w| ..)` method takes [ssienr::W](ssienr::W) writer structure"]
    impl crate::Writable for SSIENR {}
    #[doc = "Enable Register"]
    pub mod ssienr {
        #[doc = "Reader of register ssienr"]
        pub type R = crate::R<u32, super::SSIENR>;
        #[doc = "Writer for register ssienr"]
        pub type W = crate::W<u32, super::SSIENR>;
        #[doc = "Register ssienr `reset()`'s with value 0"]
        impl crate::ResetValue for super::SSIENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Microwire Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mwcr](mwcr) module"]
    pub type MWCR = crate::Reg<u32, _MWCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MWCR;
    #[doc = "`read()` method returns [mwcr::R](mwcr::R) reader structure"]
    impl crate::Readable for MWCR {}
    #[doc = "`write(|w| ..)` method takes [mwcr::W](mwcr::W) writer structure"]
    impl crate::Writable for MWCR {}
    #[doc = "Microwire Control Register"]
    pub mod mwcr {
        #[doc = "Reader of register mwcr"]
        pub type R = crate::R<u32, super::MWCR>;
        #[doc = "Writer for register mwcr"]
        pub type W = crate::W<u32, super::MWCR>;
        #[doc = "Register mwcr `reset()`'s with value 0"]
        impl crate::ResetValue for super::MWCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Slave Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ser](ser) module"]
    pub type SER = crate::Reg<u32, _SER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SER;
    #[doc = "`read()` method returns [ser::R](ser::R) reader structure"]
    impl crate::Readable for SER {}
    #[doc = "`write(|w| ..)` method takes [ser::W](ser::W) writer structure"]
    impl crate::Writable for SER {}
    #[doc = "Slave Enable Register"]
    pub mod ser {
        #[doc = "Reader of register ser"]
        pub type R = crate::R<u32, super::SER>;
        #[doc = "Writer for register ser"]
        pub type W = crate::W<u32, super::SER>;
        #[doc = "Register ser `reset()`'s with value 0"]
        impl crate::ResetValue for super::SER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Baud Rate Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudr](baudr) module"]
    pub type BAUDR = crate::Reg<u32, _BAUDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BAUDR;
    #[doc = "`read()` method returns [baudr::R](baudr::R) reader structure"]
    impl crate::Readable for BAUDR {}
    #[doc = "`write(|w| ..)` method takes [baudr::W](baudr::W) writer structure"]
    impl crate::Writable for BAUDR {}
    #[doc = "Baud Rate Select"]
    pub mod baudr {
        #[doc = "Reader of register baudr"]
        pub type R = crate::R<u32, super::BAUDR>;
        #[doc = "Writer for register baudr"]
        pub type W = crate::W<u32, super::BAUDR>;
        #[doc = "Register baudr `reset()`'s with value 0"]
        impl crate::ResetValue for super::BAUDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Threshold Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txftlr](txftlr) module"]
    pub type TXFTLR = crate::Reg<u32, _TXFTLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXFTLR;
    #[doc = "`read()` method returns [txftlr::R](txftlr::R) reader structure"]
    impl crate::Readable for TXFTLR {}
    #[doc = "`write(|w| ..)` method takes [txftlr::W](txftlr::W) writer structure"]
    impl crate::Writable for TXFTLR {}
    #[doc = "Transmit FIFO Threshold Level"]
    pub mod txftlr {
        #[doc = "Reader of register txftlr"]
        pub type R = crate::R<u32, super::TXFTLR>;
        #[doc = "Writer for register txftlr"]
        pub type W = crate::W<u32, super::TXFTLR>;
        #[doc = "Register txftlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXFTLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Threshold Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxftlr](rxftlr) module"]
    pub type RXFTLR = crate::Reg<u32, _RXFTLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXFTLR;
    #[doc = "`read()` method returns [rxftlr::R](rxftlr::R) reader structure"]
    impl crate::Readable for RXFTLR {}
    #[doc = "`write(|w| ..)` method takes [rxftlr::W](rxftlr::W) writer structure"]
    impl crate::Writable for RXFTLR {}
    #[doc = "Receive FIFO Threshold Level"]
    pub mod rxftlr {
        #[doc = "Reader of register rxftlr"]
        pub type R = crate::R<u32, super::RXFTLR>;
        #[doc = "Writer for register rxftlr"]
        pub type W = crate::W<u32, super::RXFTLR>;
        #[doc = "Register rxftlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXFTLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txflr](txflr) module"]
    pub type TXFLR = crate::Reg<u32, _TXFLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXFLR;
    #[doc = "`read()` method returns [txflr::R](txflr::R) reader structure"]
    impl crate::Readable for TXFLR {}
    #[doc = "`write(|w| ..)` method takes [txflr::W](txflr::W) writer structure"]
    impl crate::Writable for TXFLR {}
    #[doc = "Transmit FIFO Level Register"]
    pub mod txflr {
        #[doc = "Reader of register txflr"]
        pub type R = crate::R<u32, super::TXFLR>;
        #[doc = "Writer for register txflr"]
        pub type W = crate::W<u32, super::TXFLR>;
        #[doc = "Register txflr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXFLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxflr](rxflr) module"]
    pub type RXFLR = crate::Reg<u32, _RXFLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXFLR;
    #[doc = "`read()` method returns [rxflr::R](rxflr::R) reader structure"]
    impl crate::Readable for RXFLR {}
    #[doc = "`write(|w| ..)` method takes [rxflr::W](rxflr::W) writer structure"]
    impl crate::Writable for RXFLR {}
    #[doc = "Receive FIFO Level Register"]
    pub mod rxflr {
        #[doc = "Reader of register rxflr"]
        pub type R = crate::R<u32, super::RXFLR>;
        #[doc = "Writer for register rxflr"]
        pub type W = crate::W<u32, super::RXFLR>;
        #[doc = "Register rxflr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXFLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status Register"]
    pub mod sr {
        #[doc = "Reader of register sr"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register sr"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register sr `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [imr](imr) module"]
    pub type IMR = crate::Reg<u32, _IMR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IMR;
    #[doc = "`read()` method returns [imr::R](imr::R) reader structure"]
    impl crate::Readable for IMR {}
    #[doc = "`write(|w| ..)` method takes [imr::W](imr::W) writer structure"]
    impl crate::Writable for IMR {}
    #[doc = "Interrupt Mask Register"]
    pub mod imr {
        #[doc = "Reader of register imr"]
        pub type R = crate::R<u32, super::IMR>;
        #[doc = "Writer for register imr"]
        pub type W = crate::W<u32, super::IMR>;
        #[doc = "Register imr `reset()`'s with value 0"]
        impl crate::ResetValue for super::IMR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "`write(|w| ..)` method takes [isr::W](isr::W) writer structure"]
    impl crate::Writable for ISR {}
    #[doc = "Interrupt Status Register"]
    pub mod isr {
        #[doc = "Reader of register isr"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Writer for register isr"]
        pub type W = crate::W<u32, super::ISR>;
        #[doc = "Register isr `reset()`'s with value 0"]
        impl crate::ResetValue for super::ISR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Raw Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [risr](risr) module"]
    pub type RISR = crate::Reg<u32, _RISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RISR;
    #[doc = "`read()` method returns [risr::R](risr::R) reader structure"]
    impl crate::Readable for RISR {}
    #[doc = "`write(|w| ..)` method takes [risr::W](risr::W) writer structure"]
    impl crate::Writable for RISR {}
    #[doc = "Raw Interrupt Status Register"]
    pub mod risr {
        #[doc = "Reader of register risr"]
        pub type R = crate::R<u32, super::RISR>;
        #[doc = "Writer for register risr"]
        pub type W = crate::W<u32, super::RISR>;
        #[doc = "Register risr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RISR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txoicr](txoicr) module"]
    pub type TXOICR = crate::Reg<u32, _TXOICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXOICR;
    #[doc = "`read()` method returns [txoicr::R](txoicr::R) reader structure"]
    impl crate::Readable for TXOICR {}
    #[doc = "`write(|w| ..)` method takes [txoicr::W](txoicr::W) writer structure"]
    impl crate::Writable for TXOICR {}
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register"]
    pub mod txoicr {
        #[doc = "Reader of register txoicr"]
        pub type R = crate::R<u32, super::TXOICR>;
        #[doc = "Writer for register txoicr"]
        pub type W = crate::W<u32, super::TXOICR>;
        #[doc = "Register txoicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXOICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Overflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxoicr](rxoicr) module"]
    pub type RXOICR = crate::Reg<u32, _RXOICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXOICR;
    #[doc = "`read()` method returns [rxoicr::R](rxoicr::R) reader structure"]
    impl crate::Readable for RXOICR {}
    #[doc = "`write(|w| ..)` method takes [rxoicr::W](rxoicr::W) writer structure"]
    impl crate::Writable for RXOICR {}
    #[doc = "Receive FIFO Overflow Interrupt Clear Register"]
    pub mod rxoicr {
        #[doc = "Reader of register rxoicr"]
        pub type R = crate::R<u32, super::RXOICR>;
        #[doc = "Writer for register rxoicr"]
        pub type W = crate::W<u32, super::RXOICR>;
        #[doc = "Register rxoicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXOICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Underflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxuicr](rxuicr) module"]
    pub type RXUICR = crate::Reg<u32, _RXUICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXUICR;
    #[doc = "`read()` method returns [rxuicr::R](rxuicr::R) reader structure"]
    impl crate::Readable for RXUICR {}
    #[doc = "`write(|w| ..)` method takes [rxuicr::W](rxuicr::W) writer structure"]
    impl crate::Writable for RXUICR {}
    #[doc = "Receive FIFO Underflow Interrupt Clear Register"]
    pub mod rxuicr {
        #[doc = "Reader of register rxuicr"]
        pub type R = crate::R<u32, super::RXUICR>;
        #[doc = "Writer for register rxuicr"]
        pub type W = crate::W<u32, super::RXUICR>;
        #[doc = "Register rxuicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXUICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Multi-Master Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msticr](msticr) module"]
    pub type MSTICR = crate::Reg<u32, _MSTICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MSTICR;
    #[doc = "`read()` method returns [msticr::R](msticr::R) reader structure"]
    impl crate::Readable for MSTICR {}
    #[doc = "`write(|w| ..)` method takes [msticr::W](msticr::W) writer structure"]
    impl crate::Writable for MSTICR {}
    #[doc = "Multi-Master Interrupt Clear Register"]
    pub mod msticr {
        #[doc = "Reader of register msticr"]
        pub type R = crate::R<u32, super::MSTICR>;
        #[doc = "Writer for register msticr"]
        pub type W = crate::W<u32, super::MSTICR>;
        #[doc = "Register msticr `reset()`'s with value 0"]
        impl crate::ResetValue for super::MSTICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr](icr) module"]
    pub type ICR = crate::Reg<u32, _ICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ICR;
    #[doc = "`read()` method returns [icr::R](icr::R) reader structure"]
    impl crate::Readable for ICR {}
    #[doc = "`write(|w| ..)` method takes [icr::W](icr::W) writer structure"]
    impl crate::Writable for ICR {}
    #[doc = "Interrupt Clear Register"]
    pub mod icr {
        #[doc = "Reader of register icr"]
        pub type R = crate::R<u32, super::ICR>;
        #[doc = "Writer for register icr"]
        pub type W = crate::W<u32, super::ICR>;
        #[doc = "Register icr `reset()`'s with value 0"]
        impl crate::ResetValue for super::ICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DMA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmacr](dmacr) module"]
    pub type DMACR = crate::Reg<u32, _DMACR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMACR;
    #[doc = "`read()` method returns [dmacr::R](dmacr::R) reader structure"]
    impl crate::Readable for DMACR {}
    #[doc = "`write(|w| ..)` method takes [dmacr::W](dmacr::W) writer structure"]
    impl crate::Writable for DMACR {}
    #[doc = "DMA Control Register"]
    pub mod dmacr {
        #[doc = "Reader of register dmacr"]
        pub type R = crate::R<u32, super::DMACR>;
        #[doc = "Writer for register dmacr"]
        pub type W = crate::W<u32, super::DMACR>;
        #[doc = "Register dmacr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMACR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DMA Transmit Data Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmatdlr](dmatdlr) module"]
    pub type DMATDLR = crate::Reg<u32, _DMATDLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMATDLR;
    #[doc = "`read()` method returns [dmatdlr::R](dmatdlr::R) reader structure"]
    impl crate::Readable for DMATDLR {}
    #[doc = "`write(|w| ..)` method takes [dmatdlr::W](dmatdlr::W) writer structure"]
    impl crate::Writable for DMATDLR {}
    #[doc = "DMA Transmit Data Level"]
    pub mod dmatdlr {
        #[doc = "Reader of register dmatdlr"]
        pub type R = crate::R<u32, super::DMATDLR>;
        #[doc = "Writer for register dmatdlr"]
        pub type W = crate::W<u32, super::DMATDLR>;
        #[doc = "Register dmatdlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMATDLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DMA Receive Data Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmardlr](dmardlr) module"]
    pub type DMARDLR = crate::Reg<u32, _DMARDLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMARDLR;
    #[doc = "`read()` method returns [dmardlr::R](dmardlr::R) reader structure"]
    impl crate::Readable for DMARDLR {}
    #[doc = "`write(|w| ..)` method takes [dmardlr::W](dmardlr::W) writer structure"]
    impl crate::Writable for DMARDLR {}
    #[doc = "DMA Receive Data Level"]
    pub mod dmardlr {
        #[doc = "Reader of register dmardlr"]
        pub type R = crate::R<u32, super::DMARDLR>;
        #[doc = "Writer for register dmardlr"]
        pub type W = crate::W<u32, super::DMARDLR>;
        #[doc = "Register dmardlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMARDLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Identification Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idr](idr) module"]
    pub type IDR = crate::Reg<u32, _IDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDR;
    #[doc = "`read()` method returns [idr::R](idr::R) reader structure"]
    impl crate::Readable for IDR {}
    #[doc = "`write(|w| ..)` method takes [idr::W](idr::W) writer structure"]
    impl crate::Writable for IDR {}
    #[doc = "Identification Register"]
    pub mod idr {
        #[doc = "Reader of register idr"]
        pub type R = crate::R<u32, super::IDR>;
        #[doc = "Writer for register idr"]
        pub type W = crate::W<u32, super::IDR>;
        #[doc = "Register idr `reset()`'s with value 0"]
        impl crate::ResetValue for super::IDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DWC_ssi component version\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ssic_version_id](ssic_version_id) module"]
    pub type SSIC_VERSION_ID = crate::Reg<u32, _SSIC_VERSION_ID>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SSIC_VERSION_ID;
    #[doc = "`read()` method returns [ssic_version_id::R](ssic_version_id::R) reader structure"]
    impl crate::Readable for SSIC_VERSION_ID {}
    #[doc = "`write(|w| ..)` method takes [ssic_version_id::W](ssic_version_id::W) writer structure"]
    impl crate::Writable for SSIC_VERSION_ID {}
    #[doc = "DWC_ssi component version"]
    pub mod ssic_version_id {
        #[doc = "Reader of register ssic_version_id"]
        pub type R = crate::R<u32, super::SSIC_VERSION_ID>;
        #[doc = "Writer for register ssic_version_id"]
        pub type W = crate::W<u32, super::SSIC_VERSION_ID>;
        #[doc = "Register ssic_version_id `reset()`'s with value 0"]
        impl crate::ResetValue for super::SSIC_VERSION_ID {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Data Register"]
    pub mod dr {
        #[doc = "Reader of register dr%s"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register dr%s"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register dr%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "RX Sample Delay Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_sample_delay](rx_sample_delay) module"]
    pub type RX_SAMPLE_DELAY = crate::Reg<u32, _RX_SAMPLE_DELAY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RX_SAMPLE_DELAY;
    #[doc = "`read()` method returns [rx_sample_delay::R](rx_sample_delay::R) reader structure"]
    impl crate::Readable for RX_SAMPLE_DELAY {}
    #[doc = "`write(|w| ..)` method takes [rx_sample_delay::W](rx_sample_delay::W) writer structure"]
    impl crate::Writable for RX_SAMPLE_DELAY {}
    #[doc = "RX Sample Delay Register"]
    pub mod rx_sample_delay {
        #[doc = "Reader of register rx_sample_delay"]
        pub type R = crate::R<u32, super::RX_SAMPLE_DELAY>;
        #[doc = "Writer for register rx_sample_delay"]
        pub type W = crate::W<u32, super::RX_SAMPLE_DELAY>;
        #[doc = "Register rx_sample_delay `reset()`'s with value 0"]
        impl crate::ResetValue for super::RX_SAMPLE_DELAY {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "SPI Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spi_ctrlr0](spi_ctrlr0) module"]
    pub type SPI_CTRLR0 = crate::Reg<u32, _SPI_CTRLR0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SPI_CTRLR0;
    #[doc = "`read()` method returns [spi_ctrlr0::R](spi_ctrlr0::R) reader structure"]
    impl crate::Readable for SPI_CTRLR0 {}
    #[doc = "`write(|w| ..)` method takes [spi_ctrlr0::W](spi_ctrlr0::W) writer structure"]
    impl crate::Writable for SPI_CTRLR0 {}
    #[doc = "SPI Control Register"]
    pub mod spi_ctrlr0 {
        #[doc = "Reader of register spi_ctrlr0"]
        pub type R = crate::R<u32, super::SPI_CTRLR0>;
        #[doc = "Writer for register spi_ctrlr0"]
        pub type W = crate::W<u32, super::SPI_CTRLR0>;
        #[doc = "Register spi_ctrlr0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SPI_CTRLR0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "instruction_address_trans_mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum AITM_A {
            #[doc = "0: STANDARD"]
            STANDARD = 0,
            #[doc = "1: ADDR_STANDARD"]
            ADDR_STANDARD = 1,
            #[doc = "2: AS_FRAME_FORMAT"]
            AS_FRAME_FORMAT = 2,
        }
        impl From<AITM_A> for u8 {
            #[inline(always)]
            fn from(variant: AITM_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `aitm`"]
        pub type AITM_R = crate::R<u8, AITM_A>;
        impl AITM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, AITM_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(AITM_A::STANDARD),
                    1 => Val(AITM_A::ADDR_STANDARD),
                    2 => Val(AITM_A::AS_FRAME_FORMAT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == AITM_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `ADDR_STANDARD`"]
            #[inline(always)]
            pub fn is_addr_standard(&self) -> bool {
                *self == AITM_A::ADDR_STANDARD
            }
            #[doc = "Checks if the value of the field is `AS_FRAME_FORMAT`"]
            #[inline(always)]
            pub fn is_as_frame_format(&self) -> bool {
                *self == AITM_A::AS_FRAME_FORMAT
            }
        }
        #[doc = "Write proxy for field `aitm`"]
        pub struct AITM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AITM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AITM_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "STANDARD"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(AITM_A::STANDARD)
            }
            #[doc = "ADDR_STANDARD"]
            #[inline(always)]
            pub fn addr_standard(self) -> &'a mut W {
                self.variant(AITM_A::ADDR_STANDARD)
            }
            #[doc = "AS_FRAME_FORMAT"]
            #[inline(always)]
            pub fn as_frame_format(self) -> &'a mut W {
                self.variant(AITM_A::AS_FRAME_FORMAT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Reader of field `addr_length`"]
        pub type ADDR_LENGTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `addr_length`"]
        pub struct ADDR_LENGTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDR_LENGTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 2)) | (((value as u32) & 0x0f) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `inst_length`"]
        pub type INST_LENGTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `inst_length`"]
        pub struct INST_LENGTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INST_LENGTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `wait_cycles`"]
        pub type WAIT_CYCLES_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `wait_cycles`"]
        pub struct WAIT_CYCLES_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAIT_CYCLES_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 11)) | (((value as u32) & 0x1f) << 11);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline(always)]
            pub fn aitm(&self) -> AITM_R {
                AITM_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline(always)]
            pub fn addr_length(&self) -> ADDR_LENGTH_R {
                ADDR_LENGTH_R::new(((self.bits >> 2) & 0x0f) as u8)
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline(always)]
            pub fn inst_length(&self) -> INST_LENGTH_R {
                INST_LENGTH_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline(always)]
            pub fn wait_cycles(&self) -> WAIT_CYCLES_R {
                WAIT_CYCLES_R::new(((self.bits >> 11) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline(always)]
            pub fn aitm(&mut self) -> AITM_W {
                AITM_W { w: self }
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline(always)]
            pub fn addr_length(&mut self) -> ADDR_LENGTH_W {
                ADDR_LENGTH_W { w: self }
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline(always)]
            pub fn inst_length(&mut self) -> INST_LENGTH_W {
                INST_LENGTH_W { w: self }
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline(always)]
            pub fn wait_cycles(&mut self) -> WAIT_CYCLES_W {
                WAIT_CYCLES_W { w: self }
            }
        }
    }
    #[doc = "XIP Mode bits\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_mode_bits](xip_mode_bits) module"]
    pub type XIP_MODE_BITS = crate::Reg<u32, _XIP_MODE_BITS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_MODE_BITS;
    #[doc = "`read()` method returns [xip_mode_bits::R](xip_mode_bits::R) reader structure"]
    impl crate::Readable for XIP_MODE_BITS {}
    #[doc = "`write(|w| ..)` method takes [xip_mode_bits::W](xip_mode_bits::W) writer structure"]
    impl crate::Writable for XIP_MODE_BITS {}
    #[doc = "XIP Mode bits"]
    pub mod xip_mode_bits {
        #[doc = "Reader of register xip_mode_bits"]
        pub type R = crate::R<u32, super::XIP_MODE_BITS>;
        #[doc = "Writer for register xip_mode_bits"]
        pub type W = crate::W<u32, super::XIP_MODE_BITS>;
        #[doc = "Register xip_mode_bits `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_MODE_BITS {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP INCR transfer opcode\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_incr_inst](xip_incr_inst) module"]
    pub type XIP_INCR_INST = crate::Reg<u32, _XIP_INCR_INST>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_INCR_INST;
    #[doc = "`read()` method returns [xip_incr_inst::R](xip_incr_inst::R) reader structure"]
    impl crate::Readable for XIP_INCR_INST {}
    #[doc = "`write(|w| ..)` method takes [xip_incr_inst::W](xip_incr_inst::W) writer structure"]
    impl crate::Writable for XIP_INCR_INST {}
    #[doc = "XIP INCR transfer opcode"]
    pub mod xip_incr_inst {
        #[doc = "Reader of register xip_incr_inst"]
        pub type R = crate::R<u32, super::XIP_INCR_INST>;
        #[doc = "Writer for register xip_incr_inst"]
        pub type W = crate::W<u32, super::XIP_INCR_INST>;
        #[doc = "Register xip_incr_inst `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_INCR_INST {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP WRAP transfer opcode\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_wrap_inst](xip_wrap_inst) module"]
    pub type XIP_WRAP_INST = crate::Reg<u32, _XIP_WRAP_INST>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_WRAP_INST;
    #[doc = "`read()` method returns [xip_wrap_inst::R](xip_wrap_inst::R) reader structure"]
    impl crate::Readable for XIP_WRAP_INST {}
    #[doc = "`write(|w| ..)` method takes [xip_wrap_inst::W](xip_wrap_inst::W) writer structure"]
    impl crate::Writable for XIP_WRAP_INST {}
    #[doc = "XIP WRAP transfer opcode"]
    pub mod xip_wrap_inst {
        #[doc = "Reader of register xip_wrap_inst"]
        pub type R = crate::R<u32, super::XIP_WRAP_INST>;
        #[doc = "Writer for register xip_wrap_inst"]
        pub type W = crate::W<u32, super::XIP_WRAP_INST>;
        #[doc = "Register xip_wrap_inst `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_WRAP_INST {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_ctrl](xip_ctrl) module"]
    pub type XIP_CTRL = crate::Reg<u32, _XIP_CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_CTRL;
    #[doc = "`read()` method returns [xip_ctrl::R](xip_ctrl::R) reader structure"]
    impl crate::Readable for XIP_CTRL {}
    #[doc = "`write(|w| ..)` method takes [xip_ctrl::W](xip_ctrl::W) writer structure"]
    impl crate::Writable for XIP_CTRL {}
    #[doc = "XIP Control Register"]
    pub mod xip_ctrl {
        #[doc = "Reader of register xip_ctrl"]
        pub type R = crate::R<u32, super::XIP_CTRL>;
        #[doc = "Writer for register xip_ctrl"]
        pub type W = crate::W<u32, super::XIP_CTRL>;
        #[doc = "Register xip_ctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_CTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP Slave Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_ser](xip_ser) module"]
    pub type XIP_SER = crate::Reg<u32, _XIP_SER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_SER;
    #[doc = "`read()` method returns [xip_ser::R](xip_ser::R) reader structure"]
    impl crate::Readable for XIP_SER {}
    #[doc = "`write(|w| ..)` method takes [xip_ser::W](xip_ser::W) writer structure"]
    impl crate::Writable for XIP_SER {}
    #[doc = "XIP Slave Enable Register"]
    pub mod xip_ser {
        #[doc = "Reader of register xip_ser"]
        pub type R = crate::R<u32, super::XIP_SER>;
        #[doc = "Writer for register xip_ser"]
        pub type W = crate::W<u32, super::XIP_SER>;
        #[doc = "Register xip_ser `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_SER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xrxoicr](xrxoicr) module"]
    pub type XRXOICR = crate::Reg<u32, _XRXOICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XRXOICR;
    #[doc = "`read()` method returns [xrxoicr::R](xrxoicr::R) reader structure"]
    impl crate::Readable for XRXOICR {}
    #[doc = "`write(|w| ..)` method takes [xrxoicr::W](xrxoicr::W) writer structure"]
    impl crate::Writable for XRXOICR {}
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register"]
    pub mod xrxoicr {
        #[doc = "Reader of register xrxoicr"]
        pub type R = crate::R<u32, super::XRXOICR>;
        #[doc = "Writer for register xrxoicr"]
        pub type W = crate::W<u32, super::XRXOICR>;
        #[doc = "Register xrxoicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::XRXOICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP time out register for continuous transfers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_cnt_time_out](xip_cnt_time_out) module"]
    pub type XIP_CNT_TIME_OUT = crate::Reg<u32, _XIP_CNT_TIME_OUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_CNT_TIME_OUT;
    #[doc = "`read()` method returns [xip_cnt_time_out::R](xip_cnt_time_out::R) reader structure"]
    impl crate::Readable for XIP_CNT_TIME_OUT {}
    #[doc = "`write(|w| ..)` method takes [xip_cnt_time_out::W](xip_cnt_time_out::W) writer structure"]
    impl crate::Writable for XIP_CNT_TIME_OUT {}
    #[doc = "XIP time out register for continuous transfers"]
    pub mod xip_cnt_time_out {
        #[doc = "Reader of register xip_cnt_time_out"]
        pub type R = crate::R<u32, super::XIP_CNT_TIME_OUT>;
        #[doc = "Writer for register xip_cnt_time_out"]
        pub type W = crate::W<u32, super::XIP_CNT_TIME_OUT>;
        #[doc = "Register xip_cnt_time_out `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_CNT_TIME_OUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "ENDIAN\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [endian](endian) module"]
    pub type ENDIAN = crate::Reg<u32, _ENDIAN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ENDIAN;
    #[doc = "`read()` method returns [endian::R](endian::R) reader structure"]
    impl crate::Readable for ENDIAN {}
    #[doc = "`write(|w| ..)` method takes [endian::W](endian::W) writer structure"]
    impl crate::Writable for ENDIAN {}
    #[doc = "ENDIAN"]
    pub mod endian {
        #[doc = "Reader of register endian"]
        pub type R = crate::R<u32, super::ENDIAN>;
        #[doc = "Writer for register endian"]
        pub type W = crate::W<u32, super::ENDIAN>;
        #[doc = "Register endian `reset()`'s with value 0"]
        impl crate::ResetValue for super::ENDIAN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Serial Peripheral Interface 1 (master)"]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi0::RegisterBlock {
        0x5300_0000 as *const _
    }
}
impl Deref for SPI1 {
    type Target = spi0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI1::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 2 (slave)"]
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi2::RegisterBlock {
        0x5024_0000 as *const _
    }
}
impl Deref for SPI2 {
    type Target = spi2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI2::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 2 (slave)"]
pub mod spi2 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Dummy register: this peripheral is not implemented yet"]
        pub dummy: DUMMY,
    }
    #[doc = "Dummy register: this peripheral is not implemented yet\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dummy](dummy) module"]
    pub type DUMMY = crate::Reg<u32, _DUMMY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DUMMY;
    #[doc = "`read()` method returns [dummy::R](dummy::R) reader structure"]
    impl crate::Readable for DUMMY {}
    #[doc = "`write(|w| ..)` method takes [dummy::W](dummy::W) writer structure"]
    impl crate::Writable for DUMMY {}
    #[doc = "Dummy register: this peripheral is not implemented yet"]
    pub mod dummy {
        #[doc = "Reader of register dummy"]
        pub type R = crate::R<u32, super::DUMMY>;
        #[doc = "Writer for register dummy"]
        pub type W = crate::W<u32, super::DUMMY>;
        #[doc = "Register dummy `reset()`'s with value 0"]
        impl crate::ResetValue for super::DUMMY {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Serial Peripheral Interface 3 (master)"]
pub struct SPI3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI3 {}
impl SPI3 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spi3::RegisterBlock {
        0x5400_0000 as *const _
    }
}
impl Deref for SPI3 {
    type Target = spi3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SPI3::ptr() }
    }
}
#[doc = "Serial Peripheral Interface 3 (master)"]
pub mod spi3 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register 0"]
        pub ctrlr0: CTRLR0,
        #[doc = "0x04 - Control Register 1"]
        pub ctrlr1: CTRLR1,
        #[doc = "0x08 - Enable Register"]
        pub ssienr: SSIENR,
        #[doc = "0x0c - Microwire Control Register"]
        pub mwcr: MWCR,
        #[doc = "0x10 - Slave Enable Register"]
        pub ser: SER,
        #[doc = "0x14 - Baud Rate Select"]
        pub baudr: BAUDR,
        #[doc = "0x18 - Transmit FIFO Threshold Level"]
        pub txftlr: TXFTLR,
        #[doc = "0x1c - Receive FIFO Threshold Level"]
        pub rxftlr: RXFTLR,
        #[doc = "0x20 - Transmit FIFO Level Register"]
        pub txflr: TXFLR,
        #[doc = "0x24 - Receive FIFO Level Register"]
        pub rxflr: RXFLR,
        #[doc = "0x28 - Status Register"]
        pub sr: SR,
        #[doc = "0x2c - Interrupt Mask Register"]
        pub imr: IMR,
        #[doc = "0x30 - Interrupt Status Register"]
        pub isr: ISR,
        #[doc = "0x34 - Raw Interrupt Status Register"]
        pub risr: RISR,
        #[doc = "0x38 - Transmit FIFO Overflow Interrupt Clear Register"]
        pub txoicr: TXOICR,
        #[doc = "0x3c - Receive FIFO Overflow Interrupt Clear Register"]
        pub rxoicr: RXOICR,
        #[doc = "0x40 - Receive FIFO Underflow Interrupt Clear Register"]
        pub rxuicr: RXUICR,
        #[doc = "0x44 - Multi-Master Interrupt Clear Register"]
        pub msticr: MSTICR,
        #[doc = "0x48 - Interrupt Clear Register"]
        pub icr: ICR,
        #[doc = "0x4c - DMA Control Register"]
        pub dmacr: DMACR,
        #[doc = "0x50 - DMA Transmit Data Level"]
        pub dmatdlr: DMATDLR,
        #[doc = "0x54 - DMA Receive Data Level"]
        pub dmardlr: DMARDLR,
        #[doc = "0x58 - Identification Register"]
        pub idr: IDR,
        #[doc = "0x5c - DWC_ssi component version"]
        pub ssic_version_id: SSIC_VERSION_ID,
        #[doc = "0x60 - Data Register"]
        pub dr: [DR; 36],
        #[doc = "0xf0 - RX Sample Delay Register"]
        pub rx_sample_delay: RX_SAMPLE_DELAY,
        #[doc = "0xf4 - SPI Control Register"]
        pub spi_ctrlr0: SPI_CTRLR0,
        _reserved27: [u8; 4usize],
        #[doc = "0xfc - XIP Mode bits"]
        pub xip_mode_bits: XIP_MODE_BITS,
        #[doc = "0x100 - XIP INCR transfer opcode"]
        pub xip_incr_inst: XIP_INCR_INST,
        #[doc = "0x104 - XIP WRAP transfer opcode"]
        pub xip_wrap_inst: XIP_WRAP_INST,
        #[doc = "0x108 - XIP Control Register"]
        pub xip_ctrl: XIP_CTRL,
        #[doc = "0x10c - XIP Slave Enable Register"]
        pub xip_ser: XIP_SER,
        #[doc = "0x110 - XIP Receive FIFO Overflow Interrupt Clear Register"]
        pub xrxoicr: XRXOICR,
        #[doc = "0x114 - XIP time out register for continuous transfers"]
        pub xip_cnt_time_out: XIP_CNT_TIME_OUT,
        #[doc = "0x118 - ENDIAN"]
        pub endian: ENDIAN,
    }
    #[doc = "Control Register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlr0](ctrlr0) module"]
    pub type CTRLR0 = crate::Reg<u32, _CTRLR0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTRLR0;
    #[doc = "`read()` method returns [ctrlr0::R](ctrlr0::R) reader structure"]
    impl crate::Readable for CTRLR0 {}
    #[doc = "`write(|w| ..)` method takes [ctrlr0::W](ctrlr0::W) writer structure"]
    impl crate::Writable for CTRLR0 {}
    #[doc = "Control Register 0"]
    pub mod ctrlr0 {
        #[doc = "Reader of register ctrlr0"]
        pub type R = crate::R<u32, super::CTRLR0>;
        #[doc = "Writer for register ctrlr0"]
        pub type W = crate::W<u32, super::CTRLR0>;
        #[doc = "Register ctrlr0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTRLR0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `data_length`"]
        pub type DATA_LENGTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `data_length`"]
        pub struct DATA_LENGTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_LENGTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        #[doc = "WORK_MODE\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WORK_MODE_A {
            #[doc = "0: MODE_0"]
            MODE0 = 0,
            #[doc = "1: MODE_1"]
            MODE1 = 1,
            #[doc = "2: MODE_2"]
            MODE2 = 2,
            #[doc = "3: MODE_3"]
            MODE3 = 3,
        }
        impl From<WORK_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: WORK_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `work_mode`"]
        pub type WORK_MODE_R = crate::R<u8, WORK_MODE_A>;
        impl WORK_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> WORK_MODE_A {
                match self.bits {
                    0 => WORK_MODE_A::MODE0,
                    1 => WORK_MODE_A::MODE1,
                    2 => WORK_MODE_A::MODE2,
                    3 => WORK_MODE_A::MODE3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `MODE0`"]
            #[inline(always)]
            pub fn is_mode0(&self) -> bool {
                *self == WORK_MODE_A::MODE0
            }
            #[doc = "Checks if the value of the field is `MODE1`"]
            #[inline(always)]
            pub fn is_mode1(&self) -> bool {
                *self == WORK_MODE_A::MODE1
            }
            #[doc = "Checks if the value of the field is `MODE2`"]
            #[inline(always)]
            pub fn is_mode2(&self) -> bool {
                *self == WORK_MODE_A::MODE2
            }
            #[doc = "Checks if the value of the field is `MODE3`"]
            #[inline(always)]
            pub fn is_mode3(&self) -> bool {
                *self == WORK_MODE_A::MODE3
            }
        }
        #[doc = "Write proxy for field `work_mode`"]
        pub struct WORK_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WORK_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WORK_MODE_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "MODE_0"]
            #[inline(always)]
            pub fn mode0(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE0)
            }
            #[doc = "MODE_1"]
            #[inline(always)]
            pub fn mode1(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE1)
            }
            #[doc = "MODE_2"]
            #[inline(always)]
            pub fn mode2(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE2)
            }
            #[doc = "MODE_3"]
            #[inline(always)]
            pub fn mode3(self) -> &'a mut W {
                self.variant(WORK_MODE_A::MODE3)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "TRANSFER_MODE\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TMOD_A {
            #[doc = "0: TRANS_RECV"]
            TRANS_RECV = 0,
            #[doc = "1: TRANS"]
            TRANS = 1,
            #[doc = "2: RECV"]
            RECV = 2,
            #[doc = "3: EEROM"]
            EEROM = 3,
        }
        impl From<TMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: TMOD_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `tmod`"]
        pub type TMOD_R = crate::R<u8, TMOD_A>;
        impl TMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> TMOD_A {
                match self.bits {
                    0 => TMOD_A::TRANS_RECV,
                    1 => TMOD_A::TRANS,
                    2 => TMOD_A::RECV,
                    3 => TMOD_A::EEROM,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TRANS_RECV`"]
            #[inline(always)]
            pub fn is_trans_recv(&self) -> bool {
                *self == TMOD_A::TRANS_RECV
            }
            #[doc = "Checks if the value of the field is `TRANS`"]
            #[inline(always)]
            pub fn is_trans(&self) -> bool {
                *self == TMOD_A::TRANS
            }
            #[doc = "Checks if the value of the field is `RECV`"]
            #[inline(always)]
            pub fn is_recv(&self) -> bool {
                *self == TMOD_A::RECV
            }
            #[doc = "Checks if the value of the field is `EEROM`"]
            #[inline(always)]
            pub fn is_eerom(&self) -> bool {
                *self == TMOD_A::EEROM
            }
        }
        #[doc = "Write proxy for field `tmod`"]
        pub struct TMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TMOD_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "TRANS_RECV"]
            #[inline(always)]
            pub fn trans_recv(self) -> &'a mut W {
                self.variant(TMOD_A::TRANS_RECV)
            }
            #[doc = "TRANS"]
            #[inline(always)]
            pub fn trans(self) -> &'a mut W {
                self.variant(TMOD_A::TRANS)
            }
            #[doc = "RECV"]
            #[inline(always)]
            pub fn recv(self) -> &'a mut W {
                self.variant(TMOD_A::RECV)
            }
            #[doc = "EEROM"]
            #[inline(always)]
            pub fn eerom(self) -> &'a mut W {
                self.variant(TMOD_A::EEROM)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | (((value as u32) & 0x03) << 10);
                self.w
            }
        }
        #[doc = "FRAME_FORMAT\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum FRAME_FORMAT_A {
            #[doc = "0: STANDARD"]
            STANDARD = 0,
            #[doc = "1: DUAL"]
            DUAL = 1,
            #[doc = "2: QUAD"]
            QUAD = 2,
            #[doc = "3: OCTAL"]
            OCTAL = 3,
        }
        impl From<FRAME_FORMAT_A> for u8 {
            #[inline(always)]
            fn from(variant: FRAME_FORMAT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `frame_format`"]
        pub type FRAME_FORMAT_R = crate::R<u8, FRAME_FORMAT_A>;
        impl FRAME_FORMAT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FRAME_FORMAT_A {
                match self.bits {
                    0 => FRAME_FORMAT_A::STANDARD,
                    1 => FRAME_FORMAT_A::DUAL,
                    2 => FRAME_FORMAT_A::QUAD,
                    3 => FRAME_FORMAT_A::OCTAL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == FRAME_FORMAT_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `DUAL`"]
            #[inline(always)]
            pub fn is_dual(&self) -> bool {
                *self == FRAME_FORMAT_A::DUAL
            }
            #[doc = "Checks if the value of the field is `QUAD`"]
            #[inline(always)]
            pub fn is_quad(&self) -> bool {
                *self == FRAME_FORMAT_A::QUAD
            }
            #[doc = "Checks if the value of the field is `OCTAL`"]
            #[inline(always)]
            pub fn is_octal(&self) -> bool {
                *self == FRAME_FORMAT_A::OCTAL
            }
        }
        #[doc = "Write proxy for field `frame_format`"]
        pub struct FRAME_FORMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FRAME_FORMAT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FRAME_FORMAT_A) -> &'a mut W {
                {
                    self.bits(variant.into())
                }
            }
            #[doc = "STANDARD"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::STANDARD)
            }
            #[doc = "DUAL"]
            #[inline(always)]
            pub fn dual(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::DUAL)
            }
            #[doc = "QUAD"]
            #[inline(always)]
            pub fn quad(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::QUAD)
            }
            #[doc = "OCTAL"]
            #[inline(always)]
            pub fn octal(self) -> &'a mut W {
                self.variant(FRAME_FORMAT_A::OCTAL)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | (((value as u32) & 0x03) << 22);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:4 - DATA_BIT_LENGTH"]
            #[inline(always)]
            pub fn data_length(&self) -> DATA_LENGTH_R {
                DATA_LENGTH_R::new((self.bits & 0x1f) as u8)
            }
            #[doc = "Bits 8:9 - WORK_MODE"]
            #[inline(always)]
            pub fn work_mode(&self) -> WORK_MODE_R {
                WORK_MODE_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 10:11 - TRANSFER_MODE"]
            #[inline(always)]
            pub fn tmod(&self) -> TMOD_R {
                TMOD_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            #[doc = "Bits 22:23 - FRAME_FORMAT"]
            #[inline(always)]
            pub fn frame_format(&self) -> FRAME_FORMAT_R {
                FRAME_FORMAT_R::new(((self.bits >> 22) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - DATA_BIT_LENGTH"]
            #[inline(always)]
            pub fn data_length(&mut self) -> DATA_LENGTH_W {
                DATA_LENGTH_W { w: self }
            }
            #[doc = "Bits 8:9 - WORK_MODE"]
            #[inline(always)]
            pub fn work_mode(&mut self) -> WORK_MODE_W {
                WORK_MODE_W { w: self }
            }
            #[doc = "Bits 10:11 - TRANSFER_MODE"]
            #[inline(always)]
            pub fn tmod(&mut self) -> TMOD_W {
                TMOD_W { w: self }
            }
            #[doc = "Bits 22:23 - FRAME_FORMAT"]
            #[inline(always)]
            pub fn frame_format(&mut self) -> FRAME_FORMAT_W {
                FRAME_FORMAT_W { w: self }
            }
        }
    }
    #[doc = "Control Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctrlr1](ctrlr1) module"]
    pub type CTRLR1 = crate::Reg<u32, _CTRLR1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTRLR1;
    #[doc = "`read()` method returns [ctrlr1::R](ctrlr1::R) reader structure"]
    impl crate::Readable for CTRLR1 {}
    #[doc = "`write(|w| ..)` method takes [ctrlr1::W](ctrlr1::W) writer structure"]
    impl crate::Writable for CTRLR1 {}
    #[doc = "Control Register 1"]
    pub mod ctrlr1 {
        #[doc = "Reader of register ctrlr1"]
        pub type R = crate::R<u32, super::CTRLR1>;
        #[doc = "Writer for register ctrlr1"]
        pub type W = crate::W<u32, super::CTRLR1>;
        #[doc = "Register ctrlr1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTRLR1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ssienr](ssienr) module"]
    pub type SSIENR = crate::Reg<u32, _SSIENR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SSIENR;
    #[doc = "`read()` method returns [ssienr::R](ssienr::R) reader structure"]
    impl crate::Readable for SSIENR {}
    #[doc = "`write(|w| ..)` method takes [ssienr::W](ssienr::W) writer structure"]
    impl crate::Writable for SSIENR {}
    #[doc = "Enable Register"]
    pub mod ssienr {
        #[doc = "Reader of register ssienr"]
        pub type R = crate::R<u32, super::SSIENR>;
        #[doc = "Writer for register ssienr"]
        pub type W = crate::W<u32, super::SSIENR>;
        #[doc = "Register ssienr `reset()`'s with value 0"]
        impl crate::ResetValue for super::SSIENR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Microwire Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mwcr](mwcr) module"]
    pub type MWCR = crate::Reg<u32, _MWCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MWCR;
    #[doc = "`read()` method returns [mwcr::R](mwcr::R) reader structure"]
    impl crate::Readable for MWCR {}
    #[doc = "`write(|w| ..)` method takes [mwcr::W](mwcr::W) writer structure"]
    impl crate::Writable for MWCR {}
    #[doc = "Microwire Control Register"]
    pub mod mwcr {
        #[doc = "Reader of register mwcr"]
        pub type R = crate::R<u32, super::MWCR>;
        #[doc = "Writer for register mwcr"]
        pub type W = crate::W<u32, super::MWCR>;
        #[doc = "Register mwcr `reset()`'s with value 0"]
        impl crate::ResetValue for super::MWCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Slave Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ser](ser) module"]
    pub type SER = crate::Reg<u32, _SER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SER;
    #[doc = "`read()` method returns [ser::R](ser::R) reader structure"]
    impl crate::Readable for SER {}
    #[doc = "`write(|w| ..)` method takes [ser::W](ser::W) writer structure"]
    impl crate::Writable for SER {}
    #[doc = "Slave Enable Register"]
    pub mod ser {
        #[doc = "Reader of register ser"]
        pub type R = crate::R<u32, super::SER>;
        #[doc = "Writer for register ser"]
        pub type W = crate::W<u32, super::SER>;
        #[doc = "Register ser `reset()`'s with value 0"]
        impl crate::ResetValue for super::SER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Baud Rate Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [baudr](baudr) module"]
    pub type BAUDR = crate::Reg<u32, _BAUDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _BAUDR;
    #[doc = "`read()` method returns [baudr::R](baudr::R) reader structure"]
    impl crate::Readable for BAUDR {}
    #[doc = "`write(|w| ..)` method takes [baudr::W](baudr::W) writer structure"]
    impl crate::Writable for BAUDR {}
    #[doc = "Baud Rate Select"]
    pub mod baudr {
        #[doc = "Reader of register baudr"]
        pub type R = crate::R<u32, super::BAUDR>;
        #[doc = "Writer for register baudr"]
        pub type W = crate::W<u32, super::BAUDR>;
        #[doc = "Register baudr `reset()`'s with value 0"]
        impl crate::ResetValue for super::BAUDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Threshold Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txftlr](txftlr) module"]
    pub type TXFTLR = crate::Reg<u32, _TXFTLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXFTLR;
    #[doc = "`read()` method returns [txftlr::R](txftlr::R) reader structure"]
    impl crate::Readable for TXFTLR {}
    #[doc = "`write(|w| ..)` method takes [txftlr::W](txftlr::W) writer structure"]
    impl crate::Writable for TXFTLR {}
    #[doc = "Transmit FIFO Threshold Level"]
    pub mod txftlr {
        #[doc = "Reader of register txftlr"]
        pub type R = crate::R<u32, super::TXFTLR>;
        #[doc = "Writer for register txftlr"]
        pub type W = crate::W<u32, super::TXFTLR>;
        #[doc = "Register txftlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXFTLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Threshold Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxftlr](rxftlr) module"]
    pub type RXFTLR = crate::Reg<u32, _RXFTLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXFTLR;
    #[doc = "`read()` method returns [rxftlr::R](rxftlr::R) reader structure"]
    impl crate::Readable for RXFTLR {}
    #[doc = "`write(|w| ..)` method takes [rxftlr::W](rxftlr::W) writer structure"]
    impl crate::Writable for RXFTLR {}
    #[doc = "Receive FIFO Threshold Level"]
    pub mod rxftlr {
        #[doc = "Reader of register rxftlr"]
        pub type R = crate::R<u32, super::RXFTLR>;
        #[doc = "Writer for register rxftlr"]
        pub type W = crate::W<u32, super::RXFTLR>;
        #[doc = "Register rxftlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXFTLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txflr](txflr) module"]
    pub type TXFLR = crate::Reg<u32, _TXFLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXFLR;
    #[doc = "`read()` method returns [txflr::R](txflr::R) reader structure"]
    impl crate::Readable for TXFLR {}
    #[doc = "`write(|w| ..)` method takes [txflr::W](txflr::W) writer structure"]
    impl crate::Writable for TXFLR {}
    #[doc = "Transmit FIFO Level Register"]
    pub mod txflr {
        #[doc = "Reader of register txflr"]
        pub type R = crate::R<u32, super::TXFLR>;
        #[doc = "Writer for register txflr"]
        pub type W = crate::W<u32, super::TXFLR>;
        #[doc = "Register txflr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXFLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxflr](rxflr) module"]
    pub type RXFLR = crate::Reg<u32, _RXFLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXFLR;
    #[doc = "`read()` method returns [rxflr::R](rxflr::R) reader structure"]
    impl crate::Readable for RXFLR {}
    #[doc = "`write(|w| ..)` method takes [rxflr::W](rxflr::W) writer structure"]
    impl crate::Writable for RXFLR {}
    #[doc = "Receive FIFO Level Register"]
    pub mod rxflr {
        #[doc = "Reader of register rxflr"]
        pub type R = crate::R<u32, super::RXFLR>;
        #[doc = "Writer for register rxflr"]
        pub type W = crate::W<u32, super::RXFLR>;
        #[doc = "Register rxflr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXFLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sr](sr) module"]
    pub type SR = crate::Reg<u32, _SR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SR;
    #[doc = "`read()` method returns [sr::R](sr::R) reader structure"]
    impl crate::Readable for SR {}
    #[doc = "`write(|w| ..)` method takes [sr::W](sr::W) writer structure"]
    impl crate::Writable for SR {}
    #[doc = "Status Register"]
    pub mod sr {
        #[doc = "Reader of register sr"]
        pub type R = crate::R<u32, super::SR>;
        #[doc = "Writer for register sr"]
        pub type W = crate::W<u32, super::SR>;
        #[doc = "Register sr `reset()`'s with value 0"]
        impl crate::ResetValue for super::SR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [imr](imr) module"]
    pub type IMR = crate::Reg<u32, _IMR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IMR;
    #[doc = "`read()` method returns [imr::R](imr::R) reader structure"]
    impl crate::Readable for IMR {}
    #[doc = "`write(|w| ..)` method takes [imr::W](imr::W) writer structure"]
    impl crate::Writable for IMR {}
    #[doc = "Interrupt Mask Register"]
    pub mod imr {
        #[doc = "Reader of register imr"]
        pub type R = crate::R<u32, super::IMR>;
        #[doc = "Writer for register imr"]
        pub type W = crate::W<u32, super::IMR>;
        #[doc = "Register imr `reset()`'s with value 0"]
        impl crate::ResetValue for super::IMR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
    pub type ISR = crate::Reg<u32, _ISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ISR;
    #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
    impl crate::Readable for ISR {}
    #[doc = "`write(|w| ..)` method takes [isr::W](isr::W) writer structure"]
    impl crate::Writable for ISR {}
    #[doc = "Interrupt Status Register"]
    pub mod isr {
        #[doc = "Reader of register isr"]
        pub type R = crate::R<u32, super::ISR>;
        #[doc = "Writer for register isr"]
        pub type W = crate::W<u32, super::ISR>;
        #[doc = "Register isr `reset()`'s with value 0"]
        impl crate::ResetValue for super::ISR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Raw Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [risr](risr) module"]
    pub type RISR = crate::Reg<u32, _RISR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RISR;
    #[doc = "`read()` method returns [risr::R](risr::R) reader structure"]
    impl crate::Readable for RISR {}
    #[doc = "`write(|w| ..)` method takes [risr::W](risr::W) writer structure"]
    impl crate::Writable for RISR {}
    #[doc = "Raw Interrupt Status Register"]
    pub mod risr {
        #[doc = "Reader of register risr"]
        pub type R = crate::R<u32, super::RISR>;
        #[doc = "Writer for register risr"]
        pub type W = crate::W<u32, super::RISR>;
        #[doc = "Register risr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RISR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txoicr](txoicr) module"]
    pub type TXOICR = crate::Reg<u32, _TXOICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXOICR;
    #[doc = "`read()` method returns [txoicr::R](txoicr::R) reader structure"]
    impl crate::Readable for TXOICR {}
    #[doc = "`write(|w| ..)` method takes [txoicr::W](txoicr::W) writer structure"]
    impl crate::Writable for TXOICR {}
    #[doc = "Transmit FIFO Overflow Interrupt Clear Register"]
    pub mod txoicr {
        #[doc = "Reader of register txoicr"]
        pub type R = crate::R<u32, super::TXOICR>;
        #[doc = "Writer for register txoicr"]
        pub type W = crate::W<u32, super::TXOICR>;
        #[doc = "Register txoicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXOICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Overflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxoicr](rxoicr) module"]
    pub type RXOICR = crate::Reg<u32, _RXOICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXOICR;
    #[doc = "`read()` method returns [rxoicr::R](rxoicr::R) reader structure"]
    impl crate::Readable for RXOICR {}
    #[doc = "`write(|w| ..)` method takes [rxoicr::W](rxoicr::W) writer structure"]
    impl crate::Writable for RXOICR {}
    #[doc = "Receive FIFO Overflow Interrupt Clear Register"]
    pub mod rxoicr {
        #[doc = "Reader of register rxoicr"]
        pub type R = crate::R<u32, super::RXOICR>;
        #[doc = "Writer for register rxoicr"]
        pub type W = crate::W<u32, super::RXOICR>;
        #[doc = "Register rxoicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXOICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Receive FIFO Underflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxuicr](rxuicr) module"]
    pub type RXUICR = crate::Reg<u32, _RXUICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXUICR;
    #[doc = "`read()` method returns [rxuicr::R](rxuicr::R) reader structure"]
    impl crate::Readable for RXUICR {}
    #[doc = "`write(|w| ..)` method takes [rxuicr::W](rxuicr::W) writer structure"]
    impl crate::Writable for RXUICR {}
    #[doc = "Receive FIFO Underflow Interrupt Clear Register"]
    pub mod rxuicr {
        #[doc = "Reader of register rxuicr"]
        pub type R = crate::R<u32, super::RXUICR>;
        #[doc = "Writer for register rxuicr"]
        pub type W = crate::W<u32, super::RXUICR>;
        #[doc = "Register rxuicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXUICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Multi-Master Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [msticr](msticr) module"]
    pub type MSTICR = crate::Reg<u32, _MSTICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MSTICR;
    #[doc = "`read()` method returns [msticr::R](msticr::R) reader structure"]
    impl crate::Readable for MSTICR {}
    #[doc = "`write(|w| ..)` method takes [msticr::W](msticr::W) writer structure"]
    impl crate::Writable for MSTICR {}
    #[doc = "Multi-Master Interrupt Clear Register"]
    pub mod msticr {
        #[doc = "Reader of register msticr"]
        pub type R = crate::R<u32, super::MSTICR>;
        #[doc = "Writer for register msticr"]
        pub type W = crate::W<u32, super::MSTICR>;
        #[doc = "Register msticr `reset()`'s with value 0"]
        impl crate::ResetValue for super::MSTICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [icr](icr) module"]
    pub type ICR = crate::Reg<u32, _ICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ICR;
    #[doc = "`read()` method returns [icr::R](icr::R) reader structure"]
    impl crate::Readable for ICR {}
    #[doc = "`write(|w| ..)` method takes [icr::W](icr::W) writer structure"]
    impl crate::Writable for ICR {}
    #[doc = "Interrupt Clear Register"]
    pub mod icr {
        #[doc = "Reader of register icr"]
        pub type R = crate::R<u32, super::ICR>;
        #[doc = "Writer for register icr"]
        pub type W = crate::W<u32, super::ICR>;
        #[doc = "Register icr `reset()`'s with value 0"]
        impl crate::ResetValue for super::ICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DMA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmacr](dmacr) module"]
    pub type DMACR = crate::Reg<u32, _DMACR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMACR;
    #[doc = "`read()` method returns [dmacr::R](dmacr::R) reader structure"]
    impl crate::Readable for DMACR {}
    #[doc = "`write(|w| ..)` method takes [dmacr::W](dmacr::W) writer structure"]
    impl crate::Writable for DMACR {}
    #[doc = "DMA Control Register"]
    pub mod dmacr {
        #[doc = "Reader of register dmacr"]
        pub type R = crate::R<u32, super::DMACR>;
        #[doc = "Writer for register dmacr"]
        pub type W = crate::W<u32, super::DMACR>;
        #[doc = "Register dmacr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMACR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DMA Transmit Data Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmatdlr](dmatdlr) module"]
    pub type DMATDLR = crate::Reg<u32, _DMATDLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMATDLR;
    #[doc = "`read()` method returns [dmatdlr::R](dmatdlr::R) reader structure"]
    impl crate::Readable for DMATDLR {}
    #[doc = "`write(|w| ..)` method takes [dmatdlr::W](dmatdlr::W) writer structure"]
    impl crate::Writable for DMATDLR {}
    #[doc = "DMA Transmit Data Level"]
    pub mod dmatdlr {
        #[doc = "Reader of register dmatdlr"]
        pub type R = crate::R<u32, super::DMATDLR>;
        #[doc = "Writer for register dmatdlr"]
        pub type W = crate::W<u32, super::DMATDLR>;
        #[doc = "Register dmatdlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMATDLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DMA Receive Data Level\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dmardlr](dmardlr) module"]
    pub type DMARDLR = crate::Reg<u32, _DMARDLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMARDLR;
    #[doc = "`read()` method returns [dmardlr::R](dmardlr::R) reader structure"]
    impl crate::Readable for DMARDLR {}
    #[doc = "`write(|w| ..)` method takes [dmardlr::W](dmardlr::W) writer structure"]
    impl crate::Writable for DMARDLR {}
    #[doc = "DMA Receive Data Level"]
    pub mod dmardlr {
        #[doc = "Reader of register dmardlr"]
        pub type R = crate::R<u32, super::DMARDLR>;
        #[doc = "Writer for register dmardlr"]
        pub type W = crate::W<u32, super::DMARDLR>;
        #[doc = "Register dmardlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMARDLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Identification Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [idr](idr) module"]
    pub type IDR = crate::Reg<u32, _IDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IDR;
    #[doc = "`read()` method returns [idr::R](idr::R) reader structure"]
    impl crate::Readable for IDR {}
    #[doc = "`write(|w| ..)` method takes [idr::W](idr::W) writer structure"]
    impl crate::Writable for IDR {}
    #[doc = "Identification Register"]
    pub mod idr {
        #[doc = "Reader of register idr"]
        pub type R = crate::R<u32, super::IDR>;
        #[doc = "Writer for register idr"]
        pub type W = crate::W<u32, super::IDR>;
        #[doc = "Register idr `reset()`'s with value 0"]
        impl crate::ResetValue for super::IDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "DWC_ssi component version\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ssic_version_id](ssic_version_id) module"]
    pub type SSIC_VERSION_ID = crate::Reg<u32, _SSIC_VERSION_ID>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SSIC_VERSION_ID;
    #[doc = "`read()` method returns [ssic_version_id::R](ssic_version_id::R) reader structure"]
    impl crate::Readable for SSIC_VERSION_ID {}
    #[doc = "`write(|w| ..)` method takes [ssic_version_id::W](ssic_version_id::W) writer structure"]
    impl crate::Writable for SSIC_VERSION_ID {}
    #[doc = "DWC_ssi component version"]
    pub mod ssic_version_id {
        #[doc = "Reader of register ssic_version_id"]
        pub type R = crate::R<u32, super::SSIC_VERSION_ID>;
        #[doc = "Writer for register ssic_version_id"]
        pub type W = crate::W<u32, super::SSIC_VERSION_ID>;
        #[doc = "Register ssic_version_id `reset()`'s with value 0"]
        impl crate::ResetValue for super::SSIC_VERSION_ID {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Data Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dr](dr) module"]
    pub type DR = crate::Reg<u32, _DR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DR;
    #[doc = "`read()` method returns [dr::R](dr::R) reader structure"]
    impl crate::Readable for DR {}
    #[doc = "`write(|w| ..)` method takes [dr::W](dr::W) writer structure"]
    impl crate::Writable for DR {}
    #[doc = "Data Register"]
    pub mod dr {
        #[doc = "Reader of register dr%s"]
        pub type R = crate::R<u32, super::DR>;
        #[doc = "Writer for register dr%s"]
        pub type W = crate::W<u32, super::DR>;
        #[doc = "Register dr%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::DR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "RX Sample Delay Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_sample_delay](rx_sample_delay) module"]
    pub type RX_SAMPLE_DELAY = crate::Reg<u32, _RX_SAMPLE_DELAY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RX_SAMPLE_DELAY;
    #[doc = "`read()` method returns [rx_sample_delay::R](rx_sample_delay::R) reader structure"]
    impl crate::Readable for RX_SAMPLE_DELAY {}
    #[doc = "`write(|w| ..)` method takes [rx_sample_delay::W](rx_sample_delay::W) writer structure"]
    impl crate::Writable for RX_SAMPLE_DELAY {}
    #[doc = "RX Sample Delay Register"]
    pub mod rx_sample_delay {
        #[doc = "Reader of register rx_sample_delay"]
        pub type R = crate::R<u32, super::RX_SAMPLE_DELAY>;
        #[doc = "Writer for register rx_sample_delay"]
        pub type W = crate::W<u32, super::RX_SAMPLE_DELAY>;
        #[doc = "Register rx_sample_delay `reset()`'s with value 0"]
        impl crate::ResetValue for super::RX_SAMPLE_DELAY {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "SPI Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spi_ctrlr0](spi_ctrlr0) module"]
    pub type SPI_CTRLR0 = crate::Reg<u32, _SPI_CTRLR0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SPI_CTRLR0;
    #[doc = "`read()` method returns [spi_ctrlr0::R](spi_ctrlr0::R) reader structure"]
    impl crate::Readable for SPI_CTRLR0 {}
    #[doc = "`write(|w| ..)` method takes [spi_ctrlr0::W](spi_ctrlr0::W) writer structure"]
    impl crate::Writable for SPI_CTRLR0 {}
    #[doc = "SPI Control Register"]
    pub mod spi_ctrlr0 {
        #[doc = "Reader of register spi_ctrlr0"]
        pub type R = crate::R<u32, super::SPI_CTRLR0>;
        #[doc = "Writer for register spi_ctrlr0"]
        pub type W = crate::W<u32, super::SPI_CTRLR0>;
        #[doc = "Register spi_ctrlr0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::SPI_CTRLR0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "instruction_address_trans_mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum AITM_A {
            #[doc = "0: STANDARD"]
            STANDARD = 0,
            #[doc = "1: ADDR_STANDARD"]
            ADDR_STANDARD = 1,
            #[doc = "2: AS_FRAME_FORMAT"]
            AS_FRAME_FORMAT = 2,
        }
        impl From<AITM_A> for u8 {
            #[inline(always)]
            fn from(variant: AITM_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `aitm`"]
        pub type AITM_R = crate::R<u8, AITM_A>;
        impl AITM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, AITM_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(AITM_A::STANDARD),
                    1 => Val(AITM_A::ADDR_STANDARD),
                    2 => Val(AITM_A::AS_FRAME_FORMAT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == AITM_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `ADDR_STANDARD`"]
            #[inline(always)]
            pub fn is_addr_standard(&self) -> bool {
                *self == AITM_A::ADDR_STANDARD
            }
            #[doc = "Checks if the value of the field is `AS_FRAME_FORMAT`"]
            #[inline(always)]
            pub fn is_as_frame_format(&self) -> bool {
                *self == AITM_A::AS_FRAME_FORMAT
            }
        }
        #[doc = "Write proxy for field `aitm`"]
        pub struct AITM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AITM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: AITM_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "STANDARD"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(AITM_A::STANDARD)
            }
            #[doc = "ADDR_STANDARD"]
            #[inline(always)]
            pub fn addr_standard(self) -> &'a mut W {
                self.variant(AITM_A::ADDR_STANDARD)
            }
            #[doc = "AS_FRAME_FORMAT"]
            #[inline(always)]
            pub fn as_frame_format(self) -> &'a mut W {
                self.variant(AITM_A::AS_FRAME_FORMAT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Reader of field `addr_length`"]
        pub type ADDR_LENGTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `addr_length`"]
        pub struct ADDR_LENGTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDR_LENGTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 2)) | (((value as u32) & 0x0f) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `inst_length`"]
        pub type INST_LENGTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `inst_length`"]
        pub struct INST_LENGTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INST_LENGTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `wait_cycles`"]
        pub type WAIT_CYCLES_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `wait_cycles`"]
        pub struct WAIT_CYCLES_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAIT_CYCLES_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 11)) | (((value as u32) & 0x1f) << 11);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline(always)]
            pub fn aitm(&self) -> AITM_R {
                AITM_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline(always)]
            pub fn addr_length(&self) -> ADDR_LENGTH_R {
                ADDR_LENGTH_R::new(((self.bits >> 2) & 0x0f) as u8)
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline(always)]
            pub fn inst_length(&self) -> INST_LENGTH_R {
                INST_LENGTH_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline(always)]
            pub fn wait_cycles(&self) -> WAIT_CYCLES_R {
                WAIT_CYCLES_R::new(((self.bits >> 11) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - instruction_address_trans_mode"]
            #[inline(always)]
            pub fn aitm(&mut self) -> AITM_W {
                AITM_W { w: self }
            }
            #[doc = "Bits 2:5 - ADDR_LENGTH"]
            #[inline(always)]
            pub fn addr_length(&mut self) -> ADDR_LENGTH_W {
                ADDR_LENGTH_W { w: self }
            }
            #[doc = "Bits 8:9 - INSTRUCTION_LENGTH"]
            #[inline(always)]
            pub fn inst_length(&mut self) -> INST_LENGTH_W {
                INST_LENGTH_W { w: self }
            }
            #[doc = "Bits 11:15 - WAIT_CYCLES"]
            #[inline(always)]
            pub fn wait_cycles(&mut self) -> WAIT_CYCLES_W {
                WAIT_CYCLES_W { w: self }
            }
        }
    }
    #[doc = "XIP Mode bits\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_mode_bits](xip_mode_bits) module"]
    pub type XIP_MODE_BITS = crate::Reg<u32, _XIP_MODE_BITS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_MODE_BITS;
    #[doc = "`read()` method returns [xip_mode_bits::R](xip_mode_bits::R) reader structure"]
    impl crate::Readable for XIP_MODE_BITS {}
    #[doc = "`write(|w| ..)` method takes [xip_mode_bits::W](xip_mode_bits::W) writer structure"]
    impl crate::Writable for XIP_MODE_BITS {}
    #[doc = "XIP Mode bits"]
    pub mod xip_mode_bits {
        #[doc = "Reader of register xip_mode_bits"]
        pub type R = crate::R<u32, super::XIP_MODE_BITS>;
        #[doc = "Writer for register xip_mode_bits"]
        pub type W = crate::W<u32, super::XIP_MODE_BITS>;
        #[doc = "Register xip_mode_bits `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_MODE_BITS {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP INCR transfer opcode\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_incr_inst](xip_incr_inst) module"]
    pub type XIP_INCR_INST = crate::Reg<u32, _XIP_INCR_INST>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_INCR_INST;
    #[doc = "`read()` method returns [xip_incr_inst::R](xip_incr_inst::R) reader structure"]
    impl crate::Readable for XIP_INCR_INST {}
    #[doc = "`write(|w| ..)` method takes [xip_incr_inst::W](xip_incr_inst::W) writer structure"]
    impl crate::Writable for XIP_INCR_INST {}
    #[doc = "XIP INCR transfer opcode"]
    pub mod xip_incr_inst {
        #[doc = "Reader of register xip_incr_inst"]
        pub type R = crate::R<u32, super::XIP_INCR_INST>;
        #[doc = "Writer for register xip_incr_inst"]
        pub type W = crate::W<u32, super::XIP_INCR_INST>;
        #[doc = "Register xip_incr_inst `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_INCR_INST {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP WRAP transfer opcode\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_wrap_inst](xip_wrap_inst) module"]
    pub type XIP_WRAP_INST = crate::Reg<u32, _XIP_WRAP_INST>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_WRAP_INST;
    #[doc = "`read()` method returns [xip_wrap_inst::R](xip_wrap_inst::R) reader structure"]
    impl crate::Readable for XIP_WRAP_INST {}
    #[doc = "`write(|w| ..)` method takes [xip_wrap_inst::W](xip_wrap_inst::W) writer structure"]
    impl crate::Writable for XIP_WRAP_INST {}
    #[doc = "XIP WRAP transfer opcode"]
    pub mod xip_wrap_inst {
        #[doc = "Reader of register xip_wrap_inst"]
        pub type R = crate::R<u32, super::XIP_WRAP_INST>;
        #[doc = "Writer for register xip_wrap_inst"]
        pub type W = crate::W<u32, super::XIP_WRAP_INST>;
        #[doc = "Register xip_wrap_inst `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_WRAP_INST {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_ctrl](xip_ctrl) module"]
    pub type XIP_CTRL = crate::Reg<u32, _XIP_CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_CTRL;
    #[doc = "`read()` method returns [xip_ctrl::R](xip_ctrl::R) reader structure"]
    impl crate::Readable for XIP_CTRL {}
    #[doc = "`write(|w| ..)` method takes [xip_ctrl::W](xip_ctrl::W) writer structure"]
    impl crate::Writable for XIP_CTRL {}
    #[doc = "XIP Control Register"]
    pub mod xip_ctrl {
        #[doc = "Reader of register xip_ctrl"]
        pub type R = crate::R<u32, super::XIP_CTRL>;
        #[doc = "Writer for register xip_ctrl"]
        pub type W = crate::W<u32, super::XIP_CTRL>;
        #[doc = "Register xip_ctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_CTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP Slave Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_ser](xip_ser) module"]
    pub type XIP_SER = crate::Reg<u32, _XIP_SER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_SER;
    #[doc = "`read()` method returns [xip_ser::R](xip_ser::R) reader structure"]
    impl crate::Readable for XIP_SER {}
    #[doc = "`write(|w| ..)` method takes [xip_ser::W](xip_ser::W) writer structure"]
    impl crate::Writable for XIP_SER {}
    #[doc = "XIP Slave Enable Register"]
    pub mod xip_ser {
        #[doc = "Reader of register xip_ser"]
        pub type R = crate::R<u32, super::XIP_SER>;
        #[doc = "Writer for register xip_ser"]
        pub type W = crate::W<u32, super::XIP_SER>;
        #[doc = "Register xip_ser `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_SER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xrxoicr](xrxoicr) module"]
    pub type XRXOICR = crate::Reg<u32, _XRXOICR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XRXOICR;
    #[doc = "`read()` method returns [xrxoicr::R](xrxoicr::R) reader structure"]
    impl crate::Readable for XRXOICR {}
    #[doc = "`write(|w| ..)` method takes [xrxoicr::W](xrxoicr::W) writer structure"]
    impl crate::Writable for XRXOICR {}
    #[doc = "XIP Receive FIFO Overflow Interrupt Clear Register"]
    pub mod xrxoicr {
        #[doc = "Reader of register xrxoicr"]
        pub type R = crate::R<u32, super::XRXOICR>;
        #[doc = "Writer for register xrxoicr"]
        pub type W = crate::W<u32, super::XRXOICR>;
        #[doc = "Register xrxoicr `reset()`'s with value 0"]
        impl crate::ResetValue for super::XRXOICR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "XIP time out register for continuous transfers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [xip_cnt_time_out](xip_cnt_time_out) module"]
    pub type XIP_CNT_TIME_OUT = crate::Reg<u32, _XIP_CNT_TIME_OUT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _XIP_CNT_TIME_OUT;
    #[doc = "`read()` method returns [xip_cnt_time_out::R](xip_cnt_time_out::R) reader structure"]
    impl crate::Readable for XIP_CNT_TIME_OUT {}
    #[doc = "`write(|w| ..)` method takes [xip_cnt_time_out::W](xip_cnt_time_out::W) writer structure"]
    impl crate::Writable for XIP_CNT_TIME_OUT {}
    #[doc = "XIP time out register for continuous transfers"]
    pub mod xip_cnt_time_out {
        #[doc = "Reader of register xip_cnt_time_out"]
        pub type R = crate::R<u32, super::XIP_CNT_TIME_OUT>;
        #[doc = "Writer for register xip_cnt_time_out"]
        pub type W = crate::W<u32, super::XIP_CNT_TIME_OUT>;
        #[doc = "Register xip_cnt_time_out `reset()`'s with value 0"]
        impl crate::ResetValue for super::XIP_CNT_TIME_OUT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "ENDIAN\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [endian](endian) module"]
    pub type ENDIAN = crate::Reg<u32, _ENDIAN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ENDIAN;
    #[doc = "`read()` method returns [endian::R](endian::R) reader structure"]
    impl crate::Readable for ENDIAN {}
    #[doc = "`write(|w| ..)` method takes [endian::W](endian::W) writer structure"]
    impl crate::Writable for ENDIAN {}
    #[doc = "ENDIAN"]
    pub mod endian {
        #[doc = "Reader of register endian"]
        pub type R = crate::R<u32, super::ENDIAN>;
        #[doc = "Writer for register endian"]
        pub type W = crate::W<u32, super::ENDIAN>;
        #[doc = "Register endian `reset()`'s with value 0"]
        impl crate::ResetValue for super::ENDIAN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Inter-Integrated Sound Interface 0"]
pub struct I2S0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2S0 {}
impl I2S0 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        0x5025_0000 as *const _
    }
}
impl Deref for I2S0 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2S0::ptr() }
    }
}
#[doc = "Inter-Integrated Sound Interface 0"]
pub mod i2s0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Enable Register"]
        pub ier: IER,
        #[doc = "0x04 - Receiver Block Enable Register"]
        pub irer: IRER,
        #[doc = "0x08 - Transmitter Block Enable Register"]
        pub iter: ITER,
        #[doc = "0x0c - Clock Generation enable"]
        pub cer: CER,
        #[doc = "0x10 - Clock Configuration Register"]
        pub ccr: CCR,
        #[doc = "0x14 - Receiver Block FIFO Reset Register"]
        pub rxffr: RXFFR,
        #[doc = "0x18 - Transmitter Block FIFO Reset Register"]
        pub txffr: TXFFR,
        _reserved7: [u8; 4usize],
        #[doc = "0x20 - Channel cluster"]
        pub channel: [CHANNEL; 4],
        _reserved8: [u8; 160usize],
        #[doc = "0x1c0 - Receiver Block DMA Register"]
        pub rxdma: RXDMA,
        #[doc = "0x1c4 - Reset Receiver Block DMA Register"]
        pub rrxdma: RRXDMA,
        #[doc = "0x1c8 - Transmitter Block DMA Register"]
        pub txdma: TXDMA,
        #[doc = "0x1cc - Reset Transmitter Block DMA Register"]
        pub rtxdma: RTXDMA,
        _reserved12: [u8; 32usize],
        #[doc = "0x1f0 - Component Parameter Register 2"]
        pub i2s_comp_param_2: I2S_COMP_PARAM_2,
        #[doc = "0x1f4 - Component Parameter Register 1"]
        pub i2s_comp_param_1: I2S_COMP_PARAM_1,
        #[doc = "0x1f8 - Component Version Register"]
        pub i2s_comp_version_1: I2S_COMP_VERSION_1,
        #[doc = "0x1fc - Component Type Register"]
        pub i2s_comp_type: I2S_COMP_TYPE,
    }
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct CHANNEL {
        #[doc = "0x00 - Left Receive or Left Transmit Register"]
        pub left_rxtx: self::channel::LEFT_RXTX,
        #[doc = "0x04 - Right Receive or Right Transmit Register"]
        pub right_rxtx: self::channel::RIGHT_RXTX,
        #[doc = "0x08 - Receive Enable Register"]
        pub rer: self::channel::RER,
        #[doc = "0x0c - Transmit Enable Register"]
        pub ter: self::channel::TER,
        #[doc = "0x10 - Receive Configuration Register"]
        pub rcr: self::channel::RCR,
        #[doc = "0x14 - Transmit Configuration Register"]
        pub tcr: self::channel::TCR,
        #[doc = "0x18 - Interrupt Status Register"]
        pub isr: self::channel::ISR,
        #[doc = "0x1c - Interrupt Mask Register"]
        pub imr: self::channel::IMR,
        #[doc = "0x20 - Receive Overrun Register"]
        pub ror: self::channel::ROR,
        #[doc = "0x24 - Transmit Overrun Register"]
        pub tor: self::channel::TOR,
        #[doc = "0x28 - Receive FIFO Configuration Register"]
        pub rfcr: self::channel::RFCR,
        #[doc = "0x2c - Transmit FIFO Configuration Register"]
        pub tfcr: self::channel::TFCR,
        #[doc = "0x30 - Receive FIFO Flush Register"]
        pub rff: self::channel::RFF,
        #[doc = "0x34 - Transmit FIFO Flush Register"]
        pub tff: self::channel::TFF,
        #[doc = "0x38 - _RESERVED0"]
        pub _reserved: [self::channel::_RESERVED; 2],
    }
    #[doc = r"Register block"]
    #[doc = "Channel cluster"]
    pub mod channel {
        #[doc = "Left Receive or Left Transmit Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [left_rxtx](left_rxtx) module"]
        pub type LEFT_RXTX = crate::Reg<u32, _LEFT_RXTX>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _LEFT_RXTX;
        #[doc = "`read()` method returns [left_rxtx::R](left_rxtx::R) reader structure"]
        impl crate::Readable for LEFT_RXTX {}
        #[doc = "`write(|w| ..)` method takes [left_rxtx::W](left_rxtx::W) writer structure"]
        impl crate::Writable for LEFT_RXTX {}
        #[doc = "Left Receive or Left Transmit Register"]
        pub mod left_rxtx {
            #[doc = "Reader of register left_rxtx"]
            pub type R = crate::R<u32, super::LEFT_RXTX>;
            #[doc = "Writer for register left_rxtx"]
            pub type W = crate::W<u32, super::LEFT_RXTX>;
            #[doc = "Register left_rxtx `reset()`'s with value 0"]
            impl crate::ResetValue for super::LEFT_RXTX {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Right Receive or Right Transmit Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [right_rxtx](right_rxtx) module"]
        pub type RIGHT_RXTX = crate::Reg<u32, _RIGHT_RXTX>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _RIGHT_RXTX;
        #[doc = "`read()` method returns [right_rxtx::R](right_rxtx::R) reader structure"]
        impl crate::Readable for RIGHT_RXTX {}
        #[doc = "`write(|w| ..)` method takes [right_rxtx::W](right_rxtx::W) writer structure"]
        impl crate::Writable for RIGHT_RXTX {}
        #[doc = "Right Receive or Right Transmit Register"]
        pub mod right_rxtx {
            #[doc = "Reader of register right_rxtx"]
            pub type R = crate::R<u32, super::RIGHT_RXTX>;
            #[doc = "Writer for register right_rxtx"]
            pub type W = crate::W<u32, super::RIGHT_RXTX>;
            #[doc = "Register right_rxtx `reset()`'s with value 0"]
            impl crate::ResetValue for super::RIGHT_RXTX {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Receive Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rer](rer) module"]
        pub type RER = crate::Reg<u32, _RER>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _RER;
        #[doc = "`read()` method returns [rer::R](rer::R) reader structure"]
        impl crate::Readable for RER {}
        #[doc = "`write(|w| ..)` method takes [rer::W](rer::W) writer structure"]
        impl crate::Writable for RER {}
        #[doc = "Receive Enable Register"]
        pub mod rer {
            #[doc = "Reader of register rer"]
            pub type R = crate::R<u32, super::RER>;
            #[doc = "Writer for register rer"]
            pub type W = crate::W<u32, super::RER>;
            #[doc = "Register rer `reset()`'s with value 0"]
            impl crate::ResetValue for super::RER {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `rxchenx`"]
            pub type RXCHENX_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `rxchenx`"]
            pub struct RXCHENX_W<'a> {
                w: &'a mut W,
            }
            impl<'a> RXCHENX_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Receive channel enable/disable"]
                #[inline(always)]
                pub fn rxchenx(&self) -> RXCHENX_R {
                    RXCHENX_R::new((self.bits & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Receive channel enable/disable"]
                #[inline(always)]
                pub fn rxchenx(&mut self) -> RXCHENX_W {
                    RXCHENX_W { w: self }
                }
            }
        }
        #[doc = "Transmit Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ter](ter) module"]
        pub type TER = crate::Reg<u32, _TER>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _TER;
        #[doc = "`read()` method returns [ter::R](ter::R) reader structure"]
        impl crate::Readable for TER {}
        #[doc = "`write(|w| ..)` method takes [ter::W](ter::W) writer structure"]
        impl crate::Writable for TER {}
        #[doc = "Transmit Enable Register"]
        pub mod ter {
            #[doc = "Reader of register ter"]
            pub type R = crate::R<u32, super::TER>;
            #[doc = "Writer for register ter"]
            pub type W = crate::W<u32, super::TER>;
            #[doc = "Register ter `reset()`'s with value 0"]
            impl crate::ResetValue for super::TER {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `txchenx`"]
            pub type TXCHENX_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `txchenx`"]
            pub struct TXCHENX_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TXCHENX_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Transmit channel enable/disable"]
                #[inline(always)]
                pub fn txchenx(&self) -> TXCHENX_R {
                    TXCHENX_R::new((self.bits & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Transmit channel enable/disable"]
                #[inline(always)]
                pub fn txchenx(&mut self) -> TXCHENX_W {
                    TXCHENX_W { w: self }
                }
            }
        }
        #[doc = "Receive Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rcr](rcr) module"]
        pub type RCR = crate::Reg<u32, _RCR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _RCR;
        #[doc = "`read()` method returns [rcr::R](rcr::R) reader structure"]
        impl crate::Readable for RCR {}
        #[doc = "`write(|w| ..)` method takes [rcr::W](rcr::W) writer structure"]
        impl crate::Writable for RCR {}
        #[doc = "Receive Configuration Register"]
        pub mod rcr {
            #[doc = "Reader of register rcr"]
            pub type R = crate::R<u32, super::RCR>;
            #[doc = "Writer for register rcr"]
            pub type W = crate::W<u32, super::RCR>;
            #[doc = "Register rcr `reset()`'s with value 0"]
            impl crate::ResetValue for super::RCR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Desired data resolution of receiver\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum WLEN_A {
                #[doc = "0: Ignore the word length"]
                IGNORE = 0,
                #[doc = "1: 12-bit data resolution of the receiver"]
                RESOLUTION12 = 1,
                #[doc = "2: 16-bit data resolution of the receiver"]
                RESOLUTION16 = 2,
                #[doc = "3: 20-bit data resolution of the receiver"]
                RESOLUTION20 = 3,
                #[doc = "4: 24-bit data resolution of the receiver"]
                RESOLUTION24 = 4,
                #[doc = "5: 32-bit data resolution of the receiver"]
                RESOLUTION32 = 5,
            }
            impl From<WLEN_A> for u8 {
                #[inline(always)]
                fn from(variant: WLEN_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `wlen`"]
            pub type WLEN_R = crate::R<u8, WLEN_A>;
            impl WLEN_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> crate::Variant<u8, WLEN_A> {
                    use crate::Variant::*;
                    match self.bits {
                        0 => Val(WLEN_A::IGNORE),
                        1 => Val(WLEN_A::RESOLUTION12),
                        2 => Val(WLEN_A::RESOLUTION16),
                        3 => Val(WLEN_A::RESOLUTION20),
                        4 => Val(WLEN_A::RESOLUTION24),
                        5 => Val(WLEN_A::RESOLUTION32),
                        i => Res(i),
                    }
                }
                #[doc = "Checks if the value of the field is `IGNORE`"]
                #[inline(always)]
                pub fn is_ignore(&self) -> bool {
                    *self == WLEN_A::IGNORE
                }
                #[doc = "Checks if the value of the field is `RESOLUTION12`"]
                #[inline(always)]
                pub fn is_resolution12(&self) -> bool {
                    *self == WLEN_A::RESOLUTION12
                }
                #[doc = "Checks if the value of the field is `RESOLUTION16`"]
                #[inline(always)]
                pub fn is_resolution16(&self) -> bool {
                    *self == WLEN_A::RESOLUTION16
                }
                #[doc = "Checks if the value of the field is `RESOLUTION20`"]
                #[inline(always)]
                pub fn is_resolution20(&self) -> bool {
                    *self == WLEN_A::RESOLUTION20
                }
                #[doc = "Checks if the value of the field is `RESOLUTION24`"]
                #[inline(always)]
                pub fn is_resolution24(&self) -> bool {
                    *self == WLEN_A::RESOLUTION24
                }
                #[doc = "Checks if the value of the field is `RESOLUTION32`"]
                #[inline(always)]
                pub fn is_resolution32(&self) -> bool {
                    *self == WLEN_A::RESOLUTION32
                }
            }
            #[doc = "Write proxy for field `wlen`"]
            pub struct WLEN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> WLEN_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: WLEN_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "Ignore the word length"]
                #[inline(always)]
                pub fn ignore(self) -> &'a mut W {
                    self.variant(WLEN_A::IGNORE)
                }
                #[doc = "12-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution12(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION12)
                }
                #[doc = "16-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution16(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION16)
                }
                #[doc = "20-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution20(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION20)
                }
                #[doc = "24-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution24(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION24)
                }
                #[doc = "32-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution32(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION32)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:2 - Desired data resolution of receiver"]
                #[inline(always)]
                pub fn wlen(&self) -> WLEN_R {
                    WLEN_R::new((self.bits & 0x07) as u8)
                }
            }
            impl W {
                #[doc = "Bits 0:2 - Desired data resolution of receiver"]
                #[inline(always)]
                pub fn wlen(&mut self) -> WLEN_W {
                    WLEN_W { w: self }
                }
            }
        }
        #[doc = "Transmit Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tcr](tcr) module"]
        pub type TCR = crate::Reg<u32, _TCR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _TCR;
        #[doc = "`read()` method returns [tcr::R](tcr::R) reader structure"]
        impl crate::Readable for TCR {}
        #[doc = "`write(|w| ..)` method takes [tcr::W](tcr::W) writer structure"]
        impl crate::Writable for TCR {}
        #[doc = "Transmit Configuration Register"]
        pub mod tcr {
            #[doc = "Reader of register tcr"]
            pub type R = crate::R<u32, super::TCR>;
            #[doc = "Writer for register tcr"]
            pub type W = crate::W<u32, super::TCR>;
            #[doc = "Register tcr `reset()`'s with value 0"]
            impl crate::ResetValue for super::TCR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Desired data resolution of transmitter"]
            pub type WLEN_A = super::rcr::WLEN_A;
            #[doc = "Reader of field `wlen`"]
            pub type WLEN_R = crate::R<u8, WLEN_A>;
            #[doc = "Write proxy for field `wlen`"]
            pub struct WLEN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> WLEN_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: WLEN_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                #[doc = "Ignore the word length"]
                #[inline(always)]
                pub fn ignore(self) -> &'a mut W {
                    self.variant(WLEN_A::IGNORE)
                }
                #[doc = "12-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution12(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION12)
                }
                #[doc = "16-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution16(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION16)
                }
                #[doc = "20-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution20(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION20)
                }
                #[doc = "24-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution24(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION24)
                }
                #[doc = "32-bit data resolution of the receiver"]
                #[inline(always)]
                pub fn resolution32(self) -> &'a mut W {
                    self.variant(WLEN_A::RESOLUTION32)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:2 - Desired data resolution of transmitter"]
                #[inline(always)]
                pub fn wlen(&self) -> WLEN_R {
                    WLEN_R::new((self.bits & 0x07) as u8)
                }
            }
            impl W {
                #[doc = "Bits 0:2 - Desired data resolution of transmitter"]
                #[inline(always)]
                pub fn wlen(&mut self) -> WLEN_W {
                    WLEN_W { w: self }
                }
            }
        }
        #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [isr](isr) module"]
        pub type ISR = crate::Reg<u32, _ISR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _ISR;
        #[doc = "`read()` method returns [isr::R](isr::R) reader structure"]
        impl crate::Readable for ISR {}
        #[doc = "Interrupt Status Register"]
        pub mod isr {
            #[doc = "Reader of register isr"]
            pub type R = crate::R<u32, super::ISR>;
            #[doc = "Reader of field `rxda`"]
            pub type RXDA_R = crate::R<bool, bool>;
            #[doc = "Reader of field `rxfo`"]
            pub type RXFO_R = crate::R<bool, bool>;
            #[doc = "Reader of field `txfe`"]
            pub type TXFE_R = crate::R<bool, bool>;
            #[doc = "Reader of field `txfo`"]
            pub type TXFO_R = crate::R<bool, bool>;
            impl R {
                #[doc = "Bit 0 - Status of receiver data avaliable interrupt"]
                #[inline(always)]
                pub fn rxda(&self) -> RXDA_R {
                    RXDA_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Status of data overrun interrupt for RX channel"]
                #[inline(always)]
                pub fn rxfo(&self) -> RXFO_R {
                    RXFO_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Status of transmit empty triger interrupt"]
                #[inline(always)]
                pub fn txfe(&self) -> TXFE_R {
                    TXFE_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Status of data overrun interrupt for the TX channel"]
                #[inline(always)]
                pub fn txfo(&self) -> TXFO_R {
                    TXFO_R::new(((self.bits >> 5) & 0x01) != 0)
                }
            }
        }
        #[doc = "Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [imr](imr) module"]
        pub type IMR = crate::Reg<u32, _IMR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _IMR;
        #[doc = "`read()` method returns [imr::R](imr::R) reader structure"]
        impl crate::Readable for IMR {}
        #[doc = "`write(|w| ..)` method takes [imr::W](imr::W) writer structure"]
        impl crate::Writable for IMR {}
        #[doc = "Interrupt Mask Register"]
        pub mod imr {
            #[doc = "Reader of register imr"]
            pub type R = crate::R<u32, super::IMR>;
            #[doc = "Writer for register imr"]
            pub type W = crate::W<u32, super::IMR>;
            #[doc = "Register imr `reset()`'s with value 0"]
            impl crate::ResetValue for super::IMR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `rxdam`"]
            pub type RXDAM_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `rxdam`"]
            pub struct RXDAM_W<'a> {
                w: &'a mut W,
            }
            impl<'a> RXDAM_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            #[doc = "Reader of field `rxfom`"]
            pub type RXFOM_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `rxfom`"]
            pub struct RXFOM_W<'a> {
                w: &'a mut W,
            }
            impl<'a> RXFOM_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `txfem`"]
            pub type TXFEM_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `txfem`"]
            pub struct TXFEM_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TXFEM_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                    self.w
                }
            }
            #[doc = "Reader of field `txfom`"]
            pub type TXFOM_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `txfom`"]
            pub struct TXFOM_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TXFOM_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Mask RX FIFO data avaliable interrupt"]
                #[inline(always)]
                pub fn rxdam(&self) -> RXDAM_R {
                    RXDAM_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - Mask RX FIFO overrun interrupt"]
                #[inline(always)]
                pub fn rxfom(&self) -> RXFOM_R {
                    RXFOM_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 4 - Mask TX FIFO empty interrupt"]
                #[inline(always)]
                pub fn txfem(&self) -> TXFEM_R {
                    TXFEM_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                #[doc = "Bit 5 - Mask TX FIFO overrun interrupt"]
                #[inline(always)]
                pub fn txfom(&self) -> TXFOM_R {
                    TXFOM_R::new(((self.bits >> 5) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Mask RX FIFO data avaliable interrupt"]
                #[inline(always)]
                pub fn rxdam(&mut self) -> RXDAM_W {
                    RXDAM_W { w: self }
                }
                #[doc = "Bit 1 - Mask RX FIFO overrun interrupt"]
                #[inline(always)]
                pub fn rxfom(&mut self) -> RXFOM_W {
                    RXFOM_W { w: self }
                }
                #[doc = "Bit 4 - Mask TX FIFO empty interrupt"]
                #[inline(always)]
                pub fn txfem(&mut self) -> TXFEM_W {
                    TXFEM_W { w: self }
                }
                #[doc = "Bit 5 - Mask TX FIFO overrun interrupt"]
                #[inline(always)]
                pub fn txfom(&mut self) -> TXFOM_W {
                    TXFOM_W { w: self }
                }
            }
        }
        #[doc = "Receive Overrun Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ror](ror) module"]
        pub type ROR = crate::Reg<u32, _ROR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _ROR;
        #[doc = "`read()` method returns [ror::R](ror::R) reader structure"]
        impl crate::Readable for ROR {}
        #[doc = "Receive Overrun Register"]
        pub mod ror {
            #[doc = "Reader of register ror"]
            pub type R = crate::R<u32, super::ROR>;
            #[doc = "Reader of field `rxcho`"]
            pub type RXCHO_R = crate::R<bool, bool>;
            impl R {
                #[doc = "Bit 0 - Read this bit to clear RX FIFO data overrun interrupt. 0x0 for RX FIFO write valid, 0x1 for RX FIFO write overrun"]
                #[inline(always)]
                pub fn rxcho(&self) -> RXCHO_R {
                    RXCHO_R::new((self.bits & 0x01) != 0)
                }
            }
        }
        #[doc = "Transmit Overrun Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tor](tor) module"]
        pub type TOR = crate::Reg<u32, _TOR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _TOR;
        #[doc = "`read()` method returns [tor::R](tor::R) reader structure"]
        impl crate::Readable for TOR {}
        #[doc = "Transmit Overrun Register"]
        pub mod tor {
            #[doc = "Reader of register tor"]
            pub type R = crate::R<u32, super::TOR>;
            #[doc = "Reader of field `txcho`"]
            pub type TXCHO_R = crate::R<bool, bool>;
            impl R {
                #[doc = "Bit 0 - Read this bit to clear TX FIFO data overrun interrupt. 0x0 for TX FIFO write valid, 0x1 for TX FIFO write overrun"]
                #[inline(always)]
                pub fn txcho(&self) -> TXCHO_R {
                    TXCHO_R::new((self.bits & 0x01) != 0)
                }
            }
        }
        #[doc = "Receive FIFO Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rfcr](rfcr) module"]
        pub type RFCR = crate::Reg<u32, _RFCR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _RFCR;
        #[doc = "`read()` method returns [rfcr::R](rfcr::R) reader structure"]
        impl crate::Readable for RFCR {}
        #[doc = "`write(|w| ..)` method takes [rfcr::W](rfcr::W) writer structure"]
        impl crate::Writable for RFCR {}
        #[doc = "Receive FIFO Configuration Register"]
        pub mod rfcr {
            #[doc = "Reader of register rfcr"]
            pub type R = crate::R<u32, super::RFCR>;
            #[doc = "Writer for register rfcr"]
            pub type W = crate::W<u32, super::RFCR>;
            #[doc = "Register rfcr `reset()`'s with value 0"]
            impl crate::ResetValue for super::RFCR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Trigger level in the RX FIFO at which the receiver data available interrupt generate\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum RXCHDT_A {
                #[doc = "0: Interrupt trigger when FIFO level is 1"]
                LEVEL1 = 0,
                #[doc = "1: Interrupt trigger when FIFO level is 2"]
                LEVEL2 = 1,
                #[doc = "2: Interrupt trigger when FIFO level is 3"]
                LEVEL3 = 2,
                #[doc = "3: Interrupt trigger when FIFO level is 4"]
                LEVEL4 = 3,
                #[doc = "4: Interrupt trigger when FIFO level is 5"]
                LEVEL5 = 4,
                #[doc = "5: Interrupt trigger when FIFO level is 6"]
                LEVEL6 = 5,
                #[doc = "6: Interrupt trigger when FIFO level is 7"]
                LEVEL7 = 6,
                #[doc = "7: Interrupt trigger when FIFO level is 8"]
                LEVEL8 = 7,
                #[doc = "8: Interrupt trigger when FIFO level is 9"]
                LEVEL9 = 8,
                #[doc = "9: Interrupt trigger when FIFO level is 10"]
                LEVEL10 = 9,
                #[doc = "10: Interrupt trigger when FIFO level is 11"]
                LEVEL11 = 10,
                #[doc = "11: Interrupt trigger when FIFO level is 12"]
                LEVEL12 = 11,
                #[doc = "12: Interrupt trigger when FIFO level is 13"]
                LEVEL13 = 12,
                #[doc = "13: Interrupt trigger when FIFO level is 14"]
                LEVEL14 = 13,
                #[doc = "14: Interrupt trigger when FIFO level is 15"]
                LEVEL15 = 14,
                #[doc = "15: Interrupt trigger when FIFO level is 16"]
                LEVEL16 = 15,
            }
            impl From<RXCHDT_A> for u8 {
                #[inline(always)]
                fn from(variant: RXCHDT_A) -> Self {
                    variant as _
                }
            }
            #[doc = "Reader of field `rxchdt`"]
            pub type RXCHDT_R = crate::R<u8, RXCHDT_A>;
            impl RXCHDT_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> RXCHDT_A {
                    match self.bits {
                        0 => RXCHDT_A::LEVEL1,
                        1 => RXCHDT_A::LEVEL2,
                        2 => RXCHDT_A::LEVEL3,
                        3 => RXCHDT_A::LEVEL4,
                        4 => RXCHDT_A::LEVEL5,
                        5 => RXCHDT_A::LEVEL6,
                        6 => RXCHDT_A::LEVEL7,
                        7 => RXCHDT_A::LEVEL8,
                        8 => RXCHDT_A::LEVEL9,
                        9 => RXCHDT_A::LEVEL10,
                        10 => RXCHDT_A::LEVEL11,
                        11 => RXCHDT_A::LEVEL12,
                        12 => RXCHDT_A::LEVEL13,
                        13 => RXCHDT_A::LEVEL14,
                        14 => RXCHDT_A::LEVEL15,
                        15 => RXCHDT_A::LEVEL16,
                        _ => unreachable!(),
                    }
                }
                #[doc = "Checks if the value of the field is `LEVEL1`"]
                #[inline(always)]
                pub fn is_level1(&self) -> bool {
                    *self == RXCHDT_A::LEVEL1
                }
                #[doc = "Checks if the value of the field is `LEVEL2`"]
                #[inline(always)]
                pub fn is_level2(&self) -> bool {
                    *self == RXCHDT_A::LEVEL2
                }
                #[doc = "Checks if the value of the field is `LEVEL3`"]
                #[inline(always)]
                pub fn is_level3(&self) -> bool {
                    *self == RXCHDT_A::LEVEL3
                }
                #[doc = "Checks if the value of the field is `LEVEL4`"]
                #[inline(always)]
                pub fn is_level4(&self) -> bool {
                    *self == RXCHDT_A::LEVEL4
                }
                #[doc = "Checks if the value of the field is `LEVEL5`"]
                #[inline(always)]
                pub fn is_level5(&self) -> bool {
                    *self == RXCHDT_A::LEVEL5
                }
                #[doc = "Checks if the value of the field is `LEVEL6`"]
                #[inline(always)]
                pub fn is_level6(&self) -> bool {
                    *self == RXCHDT_A::LEVEL6
                }
                #[doc = "Checks if the value of the field is `LEVEL7`"]
                #[inline(always)]
                pub fn is_level7(&self) -> bool {
                    *self == RXCHDT_A::LEVEL7
                }
                #[doc = "Checks if the value of the field is `LEVEL8`"]
                #[inline(always)]
                pub fn is_level8(&self) -> bool {
                    *self == RXCHDT_A::LEVEL8
                }
                #[doc = "Checks if the value of the field is `LEVEL9`"]
                #[inline(always)]
                pub fn is_level9(&self) -> bool {
                    *self == RXCHDT_A::LEVEL9
                }
                #[doc = "Checks if the value of the field is `LEVEL10`"]
                #[inline(always)]
                pub fn is_level10(&self) -> bool {
                    *self == RXCHDT_A::LEVEL10
                }
                #[doc = "Checks if the value of the field is `LEVEL11`"]
                #[inline(always)]
                pub fn is_level11(&self) -> bool {
                    *self == RXCHDT_A::LEVEL11
                }
                #[doc = "Checks if the value of the field is `LEVEL12`"]
                #[inline(always)]
                pub fn is_level12(&self) -> bool {
                    *self == RXCHDT_A::LEVEL12
                }
                #[doc = "Checks if the value of the field is `LEVEL13`"]
                #[inline(always)]
                pub fn is_level13(&self) -> bool {
                    *self == RXCHDT_A::LEVEL13
                }
                #[doc = "Checks if the value of the field is `LEVEL14`"]
                #[inline(always)]
                pub fn is_level14(&self) -> bool {
                    *self == RXCHDT_A::LEVEL14
                }
                #[doc = "Checks if the value of the field is `LEVEL15`"]
                #[inline(always)]
                pub fn is_level15(&self) -> bool {
                    *self == RXCHDT_A::LEVEL15
                }
                #[doc = "Checks if the value of the field is `LEVEL16`"]
                #[inline(always)]
                pub fn is_level16(&self) -> bool {
                    *self == RXCHDT_A::LEVEL16
                }
            }
            #[doc = "Write proxy for field `rxchdt`"]
            pub struct RXCHDT_W<'a> {
                w: &'a mut W,
            }
            impl<'a> RXCHDT_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: RXCHDT_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Interrupt trigger when FIFO level is 1"]
                #[inline(always)]
                pub fn level1(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL1)
                }
                #[doc = "Interrupt trigger when FIFO level is 2"]
                #[inline(always)]
                pub fn level2(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL2)
                }
                #[doc = "Interrupt trigger when FIFO level is 3"]
                #[inline(always)]
                pub fn level3(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL3)
                }
                #[doc = "Interrupt trigger when FIFO level is 4"]
                #[inline(always)]
                pub fn level4(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL4)
                }
                #[doc = "Interrupt trigger when FIFO level is 5"]
                #[inline(always)]
                pub fn level5(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL5)
                }
                #[doc = "Interrupt trigger when FIFO level is 6"]
                #[inline(always)]
                pub fn level6(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL6)
                }
                #[doc = "Interrupt trigger when FIFO level is 7"]
                #[inline(always)]
                pub fn level7(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL7)
                }
                #[doc = "Interrupt trigger when FIFO level is 8"]
                #[inline(always)]
                pub fn level8(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL8)
                }
                #[doc = "Interrupt trigger when FIFO level is 9"]
                #[inline(always)]
                pub fn level9(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL9)
                }
                #[doc = "Interrupt trigger when FIFO level is 10"]
                #[inline(always)]
                pub fn level10(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL10)
                }
                #[doc = "Interrupt trigger when FIFO level is 11"]
                #[inline(always)]
                pub fn level11(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL11)
                }
                #[doc = "Interrupt trigger when FIFO level is 12"]
                #[inline(always)]
                pub fn level12(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL12)
                }
                #[doc = "Interrupt trigger when FIFO level is 13"]
                #[inline(always)]
                pub fn level13(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL13)
                }
                #[doc = "Interrupt trigger when FIFO level is 14"]
                #[inline(always)]
                pub fn level14(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL14)
                }
                #[doc = "Interrupt trigger when FIFO level is 15"]
                #[inline(always)]
                pub fn level15(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL15)
                }
                #[doc = "Interrupt trigger when FIFO level is 16"]
                #[inline(always)]
                pub fn level16(self) -> &'a mut W {
                    self.variant(RXCHDT_A::LEVEL16)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:3 - Trigger level in the RX FIFO at which the receiver data available interrupt generate"]
                #[inline(always)]
                pub fn rxchdt(&self) -> RXCHDT_R {
                    RXCHDT_R::new((self.bits & 0x0f) as u8)
                }
            }
            impl W {
                #[doc = "Bits 0:3 - Trigger level in the RX FIFO at which the receiver data available interrupt generate"]
                #[inline(always)]
                pub fn rxchdt(&mut self) -> RXCHDT_W {
                    RXCHDT_W { w: self }
                }
            }
        }
        #[doc = "Transmit FIFO Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tfcr](tfcr) module"]
        pub type TFCR = crate::Reg<u32, _TFCR>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _TFCR;
        #[doc = "`read()` method returns [tfcr::R](tfcr::R) reader structure"]
        impl crate::Readable for TFCR {}
        #[doc = "`write(|w| ..)` method takes [tfcr::W](tfcr::W) writer structure"]
        impl crate::Writable for TFCR {}
        #[doc = "Transmit FIFO Configuration Register"]
        pub mod tfcr {
            #[doc = "Reader of register tfcr"]
            pub type R = crate::R<u32, super::TFCR>;
            #[doc = "Writer for register tfcr"]
            pub type W = crate::W<u32, super::TFCR>;
            #[doc = "Register tfcr `reset()`'s with value 0"]
            impl crate::ResetValue for super::TFCR {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Trigger level in the TX FIFO at which the transmitter data available interrupt generate"]
            pub type TXCHET_A = super::rfcr::RXCHDT_A;
            #[doc = "Reader of field `txchet`"]
            pub type TXCHET_R = crate::R<u8, TXCHET_A>;
            #[doc = "Write proxy for field `txchet`"]
            pub struct TXCHET_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TXCHET_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: TXCHET_A) -> &'a mut W {
                    {
                        self.bits(variant.into())
                    }
                }
                #[doc = "Interrupt trigger when FIFO level is 1"]
                #[inline(always)]
                pub fn level1(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL1)
                }
                #[doc = "Interrupt trigger when FIFO level is 2"]
                #[inline(always)]
                pub fn level2(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL2)
                }
                #[doc = "Interrupt trigger when FIFO level is 3"]
                #[inline(always)]
                pub fn level3(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL3)
                }
                #[doc = "Interrupt trigger when FIFO level is 4"]
                #[inline(always)]
                pub fn level4(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL4)
                }
                #[doc = "Interrupt trigger when FIFO level is 5"]
                #[inline(always)]
                pub fn level5(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL5)
                }
                #[doc = "Interrupt trigger when FIFO level is 6"]
                #[inline(always)]
                pub fn level6(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL6)
                }
                #[doc = "Interrupt trigger when FIFO level is 7"]
                #[inline(always)]
                pub fn level7(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL7)
                }
                #[doc = "Interrupt trigger when FIFO level is 8"]
                #[inline(always)]
                pub fn level8(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL8)
                }
                #[doc = "Interrupt trigger when FIFO level is 9"]
                #[inline(always)]
                pub fn level9(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL9)
                }
                #[doc = "Interrupt trigger when FIFO level is 10"]
                #[inline(always)]
                pub fn level10(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL10)
                }
                #[doc = "Interrupt trigger when FIFO level is 11"]
                #[inline(always)]
                pub fn level11(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL11)
                }
                #[doc = "Interrupt trigger when FIFO level is 12"]
                #[inline(always)]
                pub fn level12(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL12)
                }
                #[doc = "Interrupt trigger when FIFO level is 13"]
                #[inline(always)]
                pub fn level13(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL13)
                }
                #[doc = "Interrupt trigger when FIFO level is 14"]
                #[inline(always)]
                pub fn level14(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL14)
                }
                #[doc = "Interrupt trigger when FIFO level is 15"]
                #[inline(always)]
                pub fn level15(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL15)
                }
                #[doc = "Interrupt trigger when FIFO level is 16"]
                #[inline(always)]
                pub fn level16(self) -> &'a mut W {
                    self.variant(TXCHET_A::LEVEL16)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                    self.w
                }
            }
            impl R {
                #[doc = "Bits 0:3 - Trigger level in the TX FIFO at which the transmitter data available interrupt generate"]
                #[inline(always)]
                pub fn txchet(&self) -> TXCHET_R {
                    TXCHET_R::new((self.bits & 0x0f) as u8)
                }
            }
            impl W {
                #[doc = "Bits 0:3 - Trigger level in the TX FIFO at which the transmitter data available interrupt generate"]
                #[inline(always)]
                pub fn txchet(&mut self) -> TXCHET_W {
                    TXCHET_W { w: self }
                }
            }
        }
        #[doc = "Receive FIFO Flush Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rff](rff) module"]
        pub type RFF = crate::Reg<u32, _RFF>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _RFF;
        #[doc = "`read()` method returns [rff::R](rff::R) reader structure"]
        impl crate::Readable for RFF {}
        #[doc = "`write(|w| ..)` method takes [rff::W](rff::W) writer structure"]
        impl crate::Writable for RFF {}
        #[doc = "Receive FIFO Flush Register"]
        pub mod rff {
            #[doc = "Reader of register rff"]
            pub type R = crate::R<u32, super::RFF>;
            #[doc = "Writer for register rff"]
            pub type W = crate::W<u32, super::RFF>;
            #[doc = "Register rff `reset()`'s with value 0"]
            impl crate::ResetValue for super::RFF {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Receiver channel FIFO reset\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum RXCHFR_A {
                #[doc = "0: Not flush an individual FIFO"]
                NOT_FLUSH = 0,
                #[doc = "1: Flush an indiviadual FIFO"]
                FLUSH = 1,
            }
            impl From<RXCHFR_A> for bool {
                #[inline(always)]
                fn from(variant: RXCHFR_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `rxchfr`"]
            pub type RXCHFR_R = crate::R<bool, RXCHFR_A>;
            impl RXCHFR_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> RXCHFR_A {
                    match self.bits {
                        false => RXCHFR_A::NOT_FLUSH,
                        true => RXCHFR_A::FLUSH,
                    }
                }
                #[doc = "Checks if the value of the field is `NOT_FLUSH`"]
                #[inline(always)]
                pub fn is_not_flush(&self) -> bool {
                    *self == RXCHFR_A::NOT_FLUSH
                }
                #[doc = "Checks if the value of the field is `FLUSH`"]
                #[inline(always)]
                pub fn is_flush(&self) -> bool {
                    *self == RXCHFR_A::FLUSH
                }
            }
            #[doc = "Write proxy for field `rxchfr`"]
            pub struct RXCHFR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> RXCHFR_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: RXCHFR_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Not flush an individual FIFO"]
                #[inline(always)]
                pub fn not_flush(self) -> &'a mut W {
                    self.variant(RXCHFR_A::NOT_FLUSH)
                }
                #[doc = "Flush an indiviadual FIFO"]
                #[inline(always)]
                pub fn flush(self) -> &'a mut W {
                    self.variant(RXCHFR_A::FLUSH)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Receiver channel FIFO reset"]
                #[inline(always)]
                pub fn rxchfr(&self) -> RXCHFR_R {
                    RXCHFR_R::new((self.bits & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Receiver channel FIFO reset"]
                #[inline(always)]
                pub fn rxchfr(&mut self) -> RXCHFR_W {
                    RXCHFR_W { w: self }
                }
            }
        }
        #[doc = "Transmit FIFO Flush Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tff](tff) module"]
        pub type TFF = crate::Reg<u32, _TFF>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _TFF;
        #[doc = "`read()` method returns [tff::R](tff::R) reader structure"]
        impl crate::Readable for TFF {}
        #[doc = "`write(|w| ..)` method takes [tff::W](tff::W) writer structure"]
        impl crate::Writable for TFF {}
        #[doc = "Transmit FIFO Flush Register"]
        pub mod tff {
            #[doc = "Reader of register tff"]
            pub type R = crate::R<u32, super::TFF>;
            #[doc = "Writer for register tff"]
            pub type W = crate::W<u32, super::TFF>;
            #[doc = "Register tff `reset()`'s with value 0"]
            impl crate::ResetValue for super::TFF {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Transmit channel FIFO reset"]
            pub type RTXCHFR_A = super::rff::RXCHFR_A;
            #[doc = "Reader of field `rtxchfr`"]
            pub type RTXCHFR_R = crate::R<bool, RTXCHFR_A>;
            #[doc = "Write proxy for field `rtxchfr`"]
            pub struct RTXCHFR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> RTXCHFR_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: RTXCHFR_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "Not flush an individual FIFO"]
                #[inline(always)]
                pub fn not_flush(self) -> &'a mut W {
                    self.variant(RTXCHFR_A::NOT_FLUSH)
                }
                #[doc = "Flush an indiviadual FIFO"]
                #[inline(always)]
                pub fn flush(self) -> &'a mut W {
                    self.variant(RTXCHFR_A::FLUSH)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - Transmit channel FIFO reset"]
                #[inline(always)]
                pub fn rtxchfr(&self) -> RTXCHFR_R {
                    RTXCHFR_R::new((self.bits & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - Transmit channel FIFO reset"]
                #[inline(always)]
                pub fn rtxchfr(&mut self) -> RTXCHFR_W {
                    RTXCHFR_W { w: self }
                }
            }
        }
        #[doc = "_RESERVED0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [_reserved](_reserved) module"]
        pub type _RESERVED = crate::Reg<u32, __RESERVED>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct __RESERVED;
        #[doc = "`read()` method returns [_reserved::R](_reserved::R) reader structure"]
        impl crate::Readable for _RESERVED {}
        #[doc = "`write(|w| ..)` method takes [_reserved::W](_reserved::W) writer structure"]
        impl crate::Writable for _RESERVED {}
        #[doc = "_RESERVED0"]
        pub mod _reserved {
            #[doc = "Reader of register _reserved%s"]
            pub type R = crate::R<u32, super::_RESERVED>;
            #[doc = "Writer for register _reserved%s"]
            pub type W = crate::W<u32, super::_RESERVED>;
            #[doc = "Register _reserved%s `reset()`'s with value 0"]
            impl crate::ResetValue for super::_RESERVED {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
    }
    #[doc = "Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ier](ier) module"]
    pub type IER = crate::Reg<u32, _IER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IER;
    #[doc = "`read()` method returns [ier::R](ier::R) reader structure"]
    impl crate::Readable for IER {}
    #[doc = "`write(|w| ..)` method takes [ier::W](ier::W) writer structure"]
    impl crate::Writable for IER {}
    #[doc = "Enable Register"]
    pub mod ier {
        #[doc = "Reader of register ier"]
        pub type R = crate::R<u32, super::IER>;
        #[doc = "Writer for register ier"]
        pub type W = crate::W<u32, super::IER>;
        #[doc = "Register ier `reset()`'s with value 0"]
        impl crate::ResetValue for super::IER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ien`"]
        pub type IEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ien`"]
        pub struct IEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - I2S Enable"]
            #[inline(always)]
            pub fn ien(&self) -> IEN_R {
                IEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - I2S Enable"]
            #[inline(always)]
            pub fn ien(&mut self) -> IEN_W {
                IEN_W { w: self }
            }
        }
    }
    #[doc = "Receiver Block Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [irer](irer) module"]
    pub type IRER = crate::Reg<u32, _IRER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IRER;
    #[doc = "`read()` method returns [irer::R](irer::R) reader structure"]
    impl crate::Readable for IRER {}
    #[doc = "`write(|w| ..)` method takes [irer::W](irer::W) writer structure"]
    impl crate::Writable for IRER {}
    #[doc = "Receiver Block Enable Register"]
    pub mod irer {
        #[doc = "Reader of register irer"]
        pub type R = crate::R<u32, super::IRER>;
        #[doc = "Writer for register irer"]
        pub type W = crate::W<u32, super::IRER>;
        #[doc = "Register irer `reset()`'s with value 0"]
        impl crate::ResetValue for super::IRER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rxen`"]
        pub type RXEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rxen`"]
        pub struct RXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Receiver block enable"]
            #[inline(always)]
            pub fn rxen(&self) -> RXEN_R {
                RXEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Receiver block enable"]
            #[inline(always)]
            pub fn rxen(&mut self) -> RXEN_W {
                RXEN_W { w: self }
            }
        }
    }
    #[doc = "Transmitter Block Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iter](iter) module"]
    pub type ITER = crate::Reg<u32, _ITER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ITER;
    #[doc = "`read()` method returns [iter::R](iter::R) reader structure"]
    impl crate::Readable for ITER {}
    #[doc = "`write(|w| ..)` method takes [iter::W](iter::W) writer structure"]
    impl crate::Writable for ITER {}
    #[doc = "Transmitter Block Enable Register"]
    pub mod iter {
        #[doc = "Reader of register iter"]
        pub type R = crate::R<u32, super::ITER>;
        #[doc = "Writer for register iter"]
        pub type W = crate::W<u32, super::ITER>;
        #[doc = "Register iter `reset()`'s with value 0"]
        impl crate::ResetValue for super::ITER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `txen`"]
        pub type TXEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `txen`"]
        pub struct TXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline(always)]
            pub fn txen(&self) -> TXEN_R {
                TXEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline(always)]
            pub fn txen(&mut self) -> TXEN_W {
                TXEN_W { w: self }
            }
        }
    }
    #[doc = "Clock Generation enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cer](cer) module"]
    pub type CER = crate::Reg<u32, _CER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CER;
    #[doc = "`read()` method returns [cer::R](cer::R) reader structure"]
    impl crate::Readable for CER {}
    #[doc = "`write(|w| ..)` method takes [cer::W](cer::W) writer structure"]
    impl crate::Writable for CER {}
    #[doc = "Clock Generation enable"]
    pub mod cer {
        #[doc = "Reader of register cer"]
        pub type R = crate::R<u32, super::CER>;
        #[doc = "Writer for register cer"]
        pub type W = crate::W<u32, super::CER>;
        #[doc = "Register cer `reset()`'s with value 0"]
        impl crate::ResetValue for super::CER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `clken`"]
        pub type CLKEN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `clken`"]
        pub struct CLKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transmitter block enable"]
            #[inline(always)]
            pub fn clken(&mut self) -> CLKEN_W {
                CLKEN_W { w: self }
            }
        }
    }
    #[doc = "Clock Configuration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccr](ccr) module"]
    pub type CCR = crate::Reg<u32, _CCR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCR;
    #[doc = "`read()` method returns [ccr::R](ccr::R) reader structure"]
    impl crate::Readable for CCR {}
    #[doc = "`write(|w| ..)` method takes [ccr::W](ccr::W) writer structure"]
    impl crate::Writable for CCR {}
    #[doc = "Clock Configuration Register"]
    pub mod ccr {
        #[doc = "Reader of register ccr"]
        pub type R = crate::R<u32, super::CCR>;
        #[doc = "Writer for register ccr"]
        pub type W = crate::W<u32, super::CCR>;
        #[doc = "Register ccr `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Gating of sclk\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CLK_GATE_A {
            #[doc = "0: Clock gating is disabled"]
            NO = 0,
            #[doc = "1: Gating after 12 sclk cycles"]
            CYCLES12 = 1,
            #[doc = "2: Gating after 16 sclk cycles"]
            CYCLES16 = 2,
            #[doc = "3: Gating after 20 sclk cycles"]
            CYCLES20 = 3,
            #[doc = "4: Gating after 24 sclk cycles"]
            CYCLES24 = 4,
        }
        impl From<CLK_GATE_A> for u8 {
            #[inline(always)]
            fn from(variant: CLK_GATE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `clk_gate`"]
        pub type CLK_GATE_R = crate::R<u8, CLK_GATE_A>;
        impl CLK_GATE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CLK_GATE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CLK_GATE_A::NO),
                    1 => Val(CLK_GATE_A::CYCLES12),
                    2 => Val(CLK_GATE_A::CYCLES16),
                    3 => Val(CLK_GATE_A::CYCLES20),
                    4 => Val(CLK_GATE_A::CYCLES24),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `NO`"]
            #[inline(always)]
            pub fn is_no(&self) -> bool {
                *self == CLK_GATE_A::NO
            }
            #[doc = "Checks if the value of the field is `CYCLES12`"]
            #[inline(always)]
            pub fn is_cycles12(&self) -> bool {
                *self == CLK_GATE_A::CYCLES12
            }
            #[doc = "Checks if the value of the field is `CYCLES16`"]
            #[inline(always)]
            pub fn is_cycles16(&self) -> bool {
                *self == CLK_GATE_A::CYCLES16
            }
            #[doc = "Checks if the value of the field is `CYCLES20`"]
            #[inline(always)]
            pub fn is_cycles20(&self) -> bool {
                *self == CLK_GATE_A::CYCLES20
            }
            #[doc = "Checks if the value of the field is `CYCLES24`"]
            #[inline(always)]
            pub fn is_cycles24(&self) -> bool {
                *self == CLK_GATE_A::CYCLES24
            }
        }
        #[doc = "Write proxy for field `clk_gate`"]
        pub struct CLK_GATE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLK_GATE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_GATE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Clock gating is disabled"]
            #[inline(always)]
            pub fn no(self) -> &'a mut W {
                self.variant(CLK_GATE_A::NO)
            }
            #[doc = "Gating after 12 sclk cycles"]
            #[inline(always)]
            pub fn cycles12(self) -> &'a mut W {
                self.variant(CLK_GATE_A::CYCLES12)
            }
            #[doc = "Gating after 16 sclk cycles"]
            #[inline(always)]
            pub fn cycles16(self) -> &'a mut W {
                self.variant(CLK_GATE_A::CYCLES16)
            }
            #[doc = "Gating after 20 sclk cycles"]
            #[inline(always)]
            pub fn cycles20(self) -> &'a mut W {
                self.variant(CLK_GATE_A::CYCLES20)
            }
            #[doc = "Gating after 24 sclk cycles"]
            #[inline(always)]
            pub fn cycles24(self) -> &'a mut W {
                self.variant(CLK_GATE_A::CYCLES24)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "The number of sclk cycles for which the word select line stayd in the left aligned or right aligned mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CLK_WORD_SIZE_A {
            #[doc = "0: 16 sclk cycles"]
            CYCLES16 = 0,
            #[doc = "1: 24 sclk cycles"]
            CYCLES24 = 1,
            #[doc = "2: 32 sclk cycles"]
            CYCLES32 = 2,
        }
        impl From<CLK_WORD_SIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: CLK_WORD_SIZE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `clk_word_size`"]
        pub type CLK_WORD_SIZE_R = crate::R<u8, CLK_WORD_SIZE_A>;
        impl CLK_WORD_SIZE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CLK_WORD_SIZE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CLK_WORD_SIZE_A::CYCLES16),
                    1 => Val(CLK_WORD_SIZE_A::CYCLES24),
                    2 => Val(CLK_WORD_SIZE_A::CYCLES32),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `CYCLES16`"]
            #[inline(always)]
            pub fn is_cycles16(&self) -> bool {
                *self == CLK_WORD_SIZE_A::CYCLES16
            }
            #[doc = "Checks if the value of the field is `CYCLES24`"]
            #[inline(always)]
            pub fn is_cycles24(&self) -> bool {
                *self == CLK_WORD_SIZE_A::CYCLES24
            }
            #[doc = "Checks if the value of the field is `CYCLES32`"]
            #[inline(always)]
            pub fn is_cycles32(&self) -> bool {
                *self == CLK_WORD_SIZE_A::CYCLES32
            }
        }
        #[doc = "Write proxy for field `clk_word_size`"]
        pub struct CLK_WORD_SIZE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLK_WORD_SIZE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_WORD_SIZE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "16 sclk cycles"]
            #[inline(always)]
            pub fn cycles16(self) -> &'a mut W {
                self.variant(CLK_WORD_SIZE_A::CYCLES16)
            }
            #[doc = "24 sclk cycles"]
            #[inline(always)]
            pub fn cycles24(self) -> &'a mut W {
                self.variant(CLK_WORD_SIZE_A::CYCLES24)
            }
            #[doc = "32 sclk cycles"]
            #[inline(always)]
            pub fn cycles32(self) -> &'a mut W {
                self.variant(CLK_WORD_SIZE_A::CYCLES32)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 3)) | (((value as u32) & 0x03) << 3);
                self.w
            }
        }
        #[doc = "Alignment mode setting\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ALIGN_MODE_A {
            #[doc = "1: Standard I2S format"]
            STANDARD = 1,
            #[doc = "2: Right aligned format"]
            RIGHT = 2,
            #[doc = "4: Left aligned format"]
            LEFT = 4,
        }
        impl From<ALIGN_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: ALIGN_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `align_mode`"]
        pub type ALIGN_MODE_R = crate::R<u8, ALIGN_MODE_A>;
        impl ALIGN_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, ALIGN_MODE_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(ALIGN_MODE_A::STANDARD),
                    2 => Val(ALIGN_MODE_A::RIGHT),
                    4 => Val(ALIGN_MODE_A::LEFT),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == ALIGN_MODE_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `RIGHT`"]
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                *self == ALIGN_MODE_A::RIGHT
            }
            #[doc = "Checks if the value of the field is `LEFT`"]
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                *self == ALIGN_MODE_A::LEFT
            }
        }
        #[doc = "Write proxy for field `align_mode`"]
        pub struct ALIGN_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALIGN_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALIGN_MODE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Standard I2S format"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(ALIGN_MODE_A::STANDARD)
            }
            #[doc = "Right aligned format"]
            #[inline(always)]
            pub fn right(self) -> &'a mut W {
                self.variant(ALIGN_MODE_A::RIGHT)
            }
            #[doc = "Left aligned format"]
            #[inline(always)]
            pub fn left(self) -> &'a mut W {
                self.variant(ALIGN_MODE_A::LEFT)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 5)) | (((value as u32) & 0x07) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `dma_tx_en`"]
        pub type DMA_TX_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_tx_en`"]
        pub struct DMA_TX_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_TX_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `dma_rx_en`"]
        pub type DMA_RX_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_rx_en`"]
        pub struct DMA_RX_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_RX_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `dma_divide_16`"]
        pub type DMA_DIVIDE_16_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_divide_16`"]
        pub struct DMA_DIVIDE_16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_DIVIDE_16_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `sign_expand_en`"]
        pub type SIGN_EXPAND_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sign_expand_en`"]
        pub struct SIGN_EXPAND_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SIGN_EXPAND_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Gating of sclk"]
            #[inline(always)]
            pub fn clk_gate(&self) -> CLK_GATE_R {
                CLK_GATE_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 3:4 - The number of sclk cycles for which the word select line stayd in the left aligned or right aligned mode"]
            #[inline(always)]
            pub fn clk_word_size(&self) -> CLK_WORD_SIZE_R {
                CLK_WORD_SIZE_R::new(((self.bits >> 3) & 0x03) as u8)
            }
            #[doc = "Bits 5:7 - Alignment mode setting"]
            #[inline(always)]
            pub fn align_mode(&self) -> ALIGN_MODE_R {
                ALIGN_MODE_R::new(((self.bits >> 5) & 0x07) as u8)
            }
            #[doc = "Bit 8 - DMA transmit enable control"]
            #[inline(always)]
            pub fn dma_tx_en(&self) -> DMA_TX_EN_R {
                DMA_TX_EN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - DMA receive enable control"]
            #[inline(always)]
            pub fn dma_rx_en(&self) -> DMA_RX_EN_R {
                DMA_RX_EN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - Split 32bit data to two 16 bit data and filled in left and right channel. Used with dma_tx_en or dma_rx_en"]
            #[inline(always)]
            pub fn dma_divide_16(&self) -> DMA_DIVIDE_16_R {
                DMA_DIVIDE_16_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - SIGN_EXPAND_EN"]
            #[inline(always)]
            pub fn sign_expand_en(&self) -> SIGN_EXPAND_EN_R {
                SIGN_EXPAND_EN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Gating of sclk"]
            #[inline(always)]
            pub fn clk_gate(&mut self) -> CLK_GATE_W {
                CLK_GATE_W { w: self }
            }
            #[doc = "Bits 3:4 - The number of sclk cycles for which the word select line stayd in the left aligned or right aligned mode"]
            #[inline(always)]
            pub fn clk_word_size(&mut self) -> CLK_WORD_SIZE_W {
                CLK_WORD_SIZE_W { w: self }
            }
            #[doc = "Bits 5:7 - Alignment mode setting"]
            #[inline(always)]
            pub fn align_mode(&mut self) -> ALIGN_MODE_W {
                ALIGN_MODE_W { w: self }
            }
            #[doc = "Bit 8 - DMA transmit enable control"]
            #[inline(always)]
            pub fn dma_tx_en(&mut self) -> DMA_TX_EN_W {
                DMA_TX_EN_W { w: self }
            }
            #[doc = "Bit 9 - DMA receive enable control"]
            #[inline(always)]
            pub fn dma_rx_en(&mut self) -> DMA_RX_EN_W {
                DMA_RX_EN_W { w: self }
            }
            #[doc = "Bit 10 - Split 32bit data to two 16 bit data and filled in left and right channel. Used with dma_tx_en or dma_rx_en"]
            #[inline(always)]
            pub fn dma_divide_16(&mut self) -> DMA_DIVIDE_16_W {
                DMA_DIVIDE_16_W { w: self }
            }
            #[doc = "Bit 11 - SIGN_EXPAND_EN"]
            #[inline(always)]
            pub fn sign_expand_en(&mut self) -> SIGN_EXPAND_EN_W {
                SIGN_EXPAND_EN_W { w: self }
            }
        }
    }
    #[doc = "Receiver Block FIFO Reset Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxffr](rxffr) module"]
    pub type RXFFR = crate::Reg<u32, _RXFFR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXFFR;
    #[doc = "`read()` method returns [rxffr::R](rxffr::R) reader structure"]
    impl crate::Readable for RXFFR {}
    #[doc = "`write(|w| ..)` method takes [rxffr::W](rxffr::W) writer structure"]
    impl crate::Writable for RXFFR {}
    #[doc = "Receiver Block FIFO Reset Register"]
    pub mod rxffr {
        #[doc = "Reader of register rxffr"]
        pub type R = crate::R<u32, super::RXFFR>;
        #[doc = "Writer for register rxffr"]
        pub type W = crate::W<u32, super::RXFFR>;
        #[doc = "Register rxffr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXFFR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Receiver FIFO reset\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXFFR_A {
            #[doc = "0: Not flush FIFO"]
            NOT_FLUSH = 0,
            #[doc = "1: Flush FIFO"]
            FLUSH = 1,
        }
        impl From<RXFFR_A> for bool {
            #[inline(always)]
            fn from(variant: RXFFR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `rxffr`"]
        pub type RXFFR_R = crate::R<bool, RXFFR_A>;
        impl RXFFR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RXFFR_A {
                match self.bits {
                    false => RXFFR_A::NOT_FLUSH,
                    true => RXFFR_A::FLUSH,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_FLUSH`"]
            #[inline(always)]
            pub fn is_not_flush(&self) -> bool {
                *self == RXFFR_A::NOT_FLUSH
            }
            #[doc = "Checks if the value of the field is `FLUSH`"]
            #[inline(always)]
            pub fn is_flush(&self) -> bool {
                *self == RXFFR_A::FLUSH
            }
        }
        #[doc = "Write proxy for field `rxffr`"]
        pub struct RXFFR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXFFR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXFFR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Not flush FIFO"]
            #[inline(always)]
            pub fn not_flush(self) -> &'a mut W {
                self.variant(RXFFR_A::NOT_FLUSH)
            }
            #[doc = "Flush FIFO"]
            #[inline(always)]
            pub fn flush(self) -> &'a mut W {
                self.variant(RXFFR_A::FLUSH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Receiver FIFO reset"]
            #[inline(always)]
            pub fn rxffr(&self) -> RXFFR_R {
                RXFFR_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Receiver FIFO reset"]
            #[inline(always)]
            pub fn rxffr(&mut self) -> RXFFR_W {
                RXFFR_W { w: self }
            }
        }
    }
    #[doc = "Transmitter Block FIFO Reset Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txffr](txffr) module"]
    pub type TXFFR = crate::Reg<u32, _TXFFR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXFFR;
    #[doc = "`read()` method returns [txffr::R](txffr::R) reader structure"]
    impl crate::Readable for TXFFR {}
    #[doc = "`write(|w| ..)` method takes [txffr::W](txffr::W) writer structure"]
    impl crate::Writable for TXFFR {}
    #[doc = "Transmitter Block FIFO Reset Register"]
    pub mod txffr {
        #[doc = "Reader of register txffr"]
        pub type R = crate::R<u32, super::TXFFR>;
        #[doc = "Writer for register txffr"]
        pub type W = crate::W<u32, super::TXFFR>;
        #[doc = "Register txffr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXFFR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Transmitter FIFO reset"]
        pub type RXFFR_A = super::rxffr::RXFFR_A;
        #[doc = "Reader of field `rxffr`"]
        pub type RXFFR_R = crate::R<bool, RXFFR_A>;
        #[doc = "Write proxy for field `rxffr`"]
        pub struct RXFFR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXFFR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXFFR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Not flush FIFO"]
            #[inline(always)]
            pub fn not_flush(self) -> &'a mut W {
                self.variant(RXFFR_A::NOT_FLUSH)
            }
            #[doc = "Flush FIFO"]
            #[inline(always)]
            pub fn flush(self) -> &'a mut W {
                self.variant(RXFFR_A::FLUSH)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Transmitter FIFO reset"]
            #[inline(always)]
            pub fn rxffr(&self) -> RXFFR_R {
                RXFFR_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Transmitter FIFO reset"]
            #[inline(always)]
            pub fn rxffr(&mut self) -> RXFFR_W {
                RXFFR_W { w: self }
            }
        }
    }
    #[doc = "Receiver Block DMA Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxdma](rxdma) module"]
    pub type RXDMA = crate::Reg<u32, _RXDMA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXDMA;
    #[doc = "`read()` method returns [rxdma::R](rxdma::R) reader structure"]
    impl crate::Readable for RXDMA {}
    #[doc = "`write(|w| ..)` method takes [rxdma::W](rxdma::W) writer structure"]
    impl crate::Writable for RXDMA {}
    #[doc = "Receiver Block DMA Register"]
    pub mod rxdma {
        #[doc = "Reader of register rxdma"]
        pub type R = crate::R<u32, super::RXDMA>;
        #[doc = "Writer for register rxdma"]
        pub type W = crate::W<u32, super::RXDMA>;
        #[doc = "Register rxdma `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXDMA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Reset Receiver Block DMA Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rrxdma](rrxdma) module"]
    pub type RRXDMA = crate::Reg<u32, _RRXDMA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RRXDMA;
    #[doc = "`read()` method returns [rrxdma::R](rrxdma::R) reader structure"]
    impl crate::Readable for RRXDMA {}
    #[doc = "`write(|w| ..)` method takes [rrxdma::W](rrxdma::W) writer structure"]
    impl crate::Writable for RRXDMA {}
    #[doc = "Reset Receiver Block DMA Register"]
    pub mod rrxdma {
        #[doc = "Reader of register rrxdma"]
        pub type R = crate::R<u32, super::RRXDMA>;
        #[doc = "Writer for register rrxdma"]
        pub type W = crate::W<u32, super::RRXDMA>;
        #[doc = "Register rrxdma `reset()`'s with value 0"]
        impl crate::ResetValue for super::RRXDMA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Transmitter Block DMA Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txdma](txdma) module"]
    pub type TXDMA = crate::Reg<u32, _TXDMA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXDMA;
    #[doc = "`read()` method returns [txdma::R](txdma::R) reader structure"]
    impl crate::Readable for TXDMA {}
    #[doc = "`write(|w| ..)` method takes [txdma::W](txdma::W) writer structure"]
    impl crate::Writable for TXDMA {}
    #[doc = "Transmitter Block DMA Register"]
    pub mod txdma {
        #[doc = "Reader of register txdma"]
        pub type R = crate::R<u32, super::TXDMA>;
        #[doc = "Writer for register txdma"]
        pub type W = crate::W<u32, super::TXDMA>;
        #[doc = "Register txdma `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXDMA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Reset Transmitter Block DMA Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rtxdma](rtxdma) module"]
    pub type RTXDMA = crate::Reg<u32, _RTXDMA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RTXDMA;
    #[doc = "`read()` method returns [rtxdma::R](rtxdma::R) reader structure"]
    impl crate::Readable for RTXDMA {}
    #[doc = "`write(|w| ..)` method takes [rtxdma::W](rtxdma::W) writer structure"]
    impl crate::Writable for RTXDMA {}
    #[doc = "Reset Transmitter Block DMA Register"]
    pub mod rtxdma {
        #[doc = "Reader of register rtxdma"]
        pub type R = crate::R<u32, super::RTXDMA>;
        #[doc = "Writer for register rtxdma"]
        pub type W = crate::W<u32, super::RTXDMA>;
        #[doc = "Register rtxdma `reset()`'s with value 0"]
        impl crate::ResetValue for super::RTXDMA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Parameter Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [i2s_comp_param_2](i2s_comp_param_2) module"]
    pub type I2S_COMP_PARAM_2 = crate::Reg<u32, _I2S_COMP_PARAM_2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _I2S_COMP_PARAM_2;
    #[doc = "`read()` method returns [i2s_comp_param_2::R](i2s_comp_param_2::R) reader structure"]
    impl crate::Readable for I2S_COMP_PARAM_2 {}
    #[doc = "`write(|w| ..)` method takes [i2s_comp_param_2::W](i2s_comp_param_2::W) writer structure"]
    impl crate::Writable for I2S_COMP_PARAM_2 {}
    #[doc = "Component Parameter Register 2"]
    pub mod i2s_comp_param_2 {
        #[doc = "Reader of register i2s_comp_param_2"]
        pub type R = crate::R<u32, super::I2S_COMP_PARAM_2>;
        #[doc = "Writer for register i2s_comp_param_2"]
        pub type W = crate::W<u32, super::I2S_COMP_PARAM_2>;
        #[doc = "Register i2s_comp_param_2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::I2S_COMP_PARAM_2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Parameter Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [i2s_comp_param_1](i2s_comp_param_1) module"]
    pub type I2S_COMP_PARAM_1 = crate::Reg<u32, _I2S_COMP_PARAM_1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _I2S_COMP_PARAM_1;
    #[doc = "`read()` method returns [i2s_comp_param_1::R](i2s_comp_param_1::R) reader structure"]
    impl crate::Readable for I2S_COMP_PARAM_1 {}
    #[doc = "`write(|w| ..)` method takes [i2s_comp_param_1::W](i2s_comp_param_1::W) writer structure"]
    impl crate::Writable for I2S_COMP_PARAM_1 {}
    #[doc = "Component Parameter Register 1"]
    pub mod i2s_comp_param_1 {
        #[doc = "Reader of register i2s_comp_param_1"]
        pub type R = crate::R<u32, super::I2S_COMP_PARAM_1>;
        #[doc = "Writer for register i2s_comp_param_1"]
        pub type W = crate::W<u32, super::I2S_COMP_PARAM_1>;
        #[doc = "Register i2s_comp_param_1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::I2S_COMP_PARAM_1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Version Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [i2s_comp_version_1](i2s_comp_version_1) module"]
    pub type I2S_COMP_VERSION_1 = crate::Reg<u32, _I2S_COMP_VERSION_1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _I2S_COMP_VERSION_1;
    #[doc = "`read()` method returns [i2s_comp_version_1::R](i2s_comp_version_1::R) reader structure"]
    impl crate::Readable for I2S_COMP_VERSION_1 {}
    #[doc = "`write(|w| ..)` method takes [i2s_comp_version_1::W](i2s_comp_version_1::W) writer structure"]
    impl crate::Writable for I2S_COMP_VERSION_1 {}
    #[doc = "Component Version Register"]
    pub mod i2s_comp_version_1 {
        #[doc = "Reader of register i2s_comp_version_1"]
        pub type R = crate::R<u32, super::I2S_COMP_VERSION_1>;
        #[doc = "Writer for register i2s_comp_version_1"]
        pub type W = crate::W<u32, super::I2S_COMP_VERSION_1>;
        #[doc = "Register i2s_comp_version_1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::I2S_COMP_VERSION_1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Type Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [i2s_comp_type](i2s_comp_type) module"]
    pub type I2S_COMP_TYPE = crate::Reg<u32, _I2S_COMP_TYPE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _I2S_COMP_TYPE;
    #[doc = "`read()` method returns [i2s_comp_type::R](i2s_comp_type::R) reader structure"]
    impl crate::Readable for I2S_COMP_TYPE {}
    #[doc = "`write(|w| ..)` method takes [i2s_comp_type::W](i2s_comp_type::W) writer structure"]
    impl crate::Writable for I2S_COMP_TYPE {}
    #[doc = "Component Type Register"]
    pub mod i2s_comp_type {
        #[doc = "Reader of register i2s_comp_type"]
        pub type R = crate::R<u32, super::I2S_COMP_TYPE>;
        #[doc = "Writer for register i2s_comp_type"]
        pub type W = crate::W<u32, super::I2S_COMP_TYPE>;
        #[doc = "Register i2s_comp_type `reset()`'s with value 0"]
        impl crate::ResetValue for super::I2S_COMP_TYPE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Audio Processor"]
pub struct APU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for APU {}
impl APU {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const apu::RegisterBlock {
        0x5025_0200 as *const _
    }
}
impl Deref for APU {
    type Target = apu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*APU::ptr() }
    }
}
#[doc = "Audio Processor"]
pub mod apu {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Channel Config Register"]
        pub ch_cfg: CH_CFG,
        #[doc = "0x04 - Control Register"]
        pub ctl: CTL,
        #[doc = "0x08 - Direction Sample Buffer Read Index Configure Register (16 directions * 2 values * 4 indices)"]
        pub dir_bidx: [DIR_BIDX; 32],
        #[doc = "0x88 - FIR0 pre-filter coefficients"]
        pub pre_fir0_coef: [PRE_FIR0_COEF; 9],
        #[doc = "0xac - FIR0 post-filter coefficients"]
        pub post_fir0_coef: [POST_FIR0_COEF; 9],
        #[doc = "0xd0 - FIR1 pre-filter coeffecients"]
        pub pre_fir1_coef: [PRE_FIR1_COEF; 9],
        #[doc = "0xf4 - FIR1 post-filter coefficients"]
        pub post_fir1_coef: [POST_FIR1_COEF; 9],
        #[doc = "0x118 - Downsize Config Register"]
        pub dwsz_cfg: DWSZ_CFG,
        #[doc = "0x11c - FFT Config Register"]
        pub fft_cfg: FFT_CFG,
        #[doc = "0x120 - Read register for DMA to sample-out buffers"]
        pub sobuf_dma_rdata: SOBUF_DMA_RDATA,
        #[doc = "0x124 - Read register for DMA to voice-out buffers"]
        pub vobuf_dma_rdata: VOBUF_DMA_RDATA,
        #[doc = "0x128 - Interrupt Status Register"]
        pub int_stat: INT_STAT,
        #[doc = "0x12c - Interrupt Mask Register"]
        pub int_mask: INT_MASK,
        #[doc = "0x130 - Saturation Counter"]
        pub sat_counter: SAT_COUNTER,
        #[doc = "0x134 - Saturation Limits"]
        pub sat_limits: SAT_LIMITS,
    }
    #[doc = "Channel Config Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ch_cfg](ch_cfg) module"]
    pub type CH_CFG = crate::Reg<u32, _CH_CFG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CH_CFG;
    #[doc = "`read()` method returns [ch_cfg::R](ch_cfg::R) reader structure"]
    impl crate::Readable for CH_CFG {}
    #[doc = "`write(|w| ..)` method takes [ch_cfg::W](ch_cfg::W) writer structure"]
    impl crate::Writable for CH_CFG {}
    #[doc = "Channel Config Register"]
    pub mod ch_cfg {
        #[doc = "Reader of register ch_cfg"]
        pub type R = crate::R<u32, super::CH_CFG>;
        #[doc = "Writer for register ch_cfg"]
        pub type W = crate::W<u32, super::CH_CFG>;
        #[doc = "Register ch_cfg `reset()`'s with value 0"]
        impl crate::ResetValue for super::CH_CFG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `sound_ch_en`"]
        pub type SOUND_CH_EN_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `sound_ch_en`"]
        pub struct SOUND_CH_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SOUND_CH_EN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `target_dir`"]
        pub type TARGET_DIR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `target_dir`"]
        pub struct TARGET_DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TARGET_DIR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `audio_gain`"]
        pub type AUDIO_GAIN_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `audio_gain`"]
        pub struct AUDIO_GAIN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AUDIO_GAIN_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07ff << 12)) | (((value as u32) & 0x07ff) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `data_src_mode`"]
        pub type DATA_SRC_MODE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `data_src_mode`"]
        pub struct DATA_SRC_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_SRC_MODE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_sound_ch_en`"]
        pub struct WE_SOUND_CH_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_SOUND_CH_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | (((value as u32) & 0x01) << 28);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_target_dir`"]
        pub struct WE_TARGET_DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_TARGET_DIR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_audio_gain`"]
        pub struct WE_AUDIO_GAIN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_AUDIO_GAIN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_data_src_mode`"]
        pub struct WE_DATA_SRC_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_DATA_SRC_MODE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - BF unit sound channel enable control bits"]
            #[inline(always)]
            pub fn sound_ch_en(&self) -> SOUND_CH_EN_R {
                SOUND_CH_EN_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:11 - Target direction select for valid voice output"]
            #[inline(always)]
            pub fn target_dir(&self) -> TARGET_DIR_R {
                TARGET_DIR_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:22 - Audio sample gain factor"]
            #[inline(always)]
            pub fn audio_gain(&self) -> AUDIO_GAIN_R {
                AUDIO_GAIN_R::new(((self.bits >> 12) & 0x07ff) as u16)
            }
            #[doc = "Bit 24 - Audio data source configure parameter"]
            #[inline(always)]
            pub fn data_src_mode(&self) -> DATA_SRC_MODE_R {
                DATA_SRC_MODE_R::new(((self.bits >> 24) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - BF unit sound channel enable control bits"]
            #[inline(always)]
            pub fn sound_ch_en(&mut self) -> SOUND_CH_EN_W {
                SOUND_CH_EN_W { w: self }
            }
            #[doc = "Bits 8:11 - Target direction select for valid voice output"]
            #[inline(always)]
            pub fn target_dir(&mut self) -> TARGET_DIR_W {
                TARGET_DIR_W { w: self }
            }
            #[doc = "Bits 12:22 - Audio sample gain factor"]
            #[inline(always)]
            pub fn audio_gain(&mut self) -> AUDIO_GAIN_W {
                AUDIO_GAIN_W { w: self }
            }
            #[doc = "Bit 24 - Audio data source configure parameter"]
            #[inline(always)]
            pub fn data_src_mode(&mut self) -> DATA_SRC_MODE_W {
                DATA_SRC_MODE_W { w: self }
            }
            #[doc = "Bit 28 - Write enable for sound_ch_en parameter"]
            #[inline(always)]
            pub fn we_sound_ch_en(&mut self) -> WE_SOUND_CH_EN_W {
                WE_SOUND_CH_EN_W { w: self }
            }
            #[doc = "Bit 29 - Write enable for target_dir parameter"]
            #[inline(always)]
            pub fn we_target_dir(&mut self) -> WE_TARGET_DIR_W {
                WE_TARGET_DIR_W { w: self }
            }
            #[doc = "Bit 30 - Write enable for audio_gain parameter"]
            #[inline(always)]
            pub fn we_audio_gain(&mut self) -> WE_AUDIO_GAIN_W {
                WE_AUDIO_GAIN_W { w: self }
            }
            #[doc = "Bit 31 - Write enable for data_out_mode parameter"]
            #[inline(always)]
            pub fn we_data_src_mode(&mut self) -> WE_DATA_SRC_MODE_W {
                WE_DATA_SRC_MODE_W { w: self }
            }
        }
    }
    #[doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ctl](ctl) module"]
    pub type CTL = crate::Reg<u32, _CTL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CTL;
    #[doc = "`read()` method returns [ctl::R](ctl::R) reader structure"]
    impl crate::Readable for CTL {}
    #[doc = "`write(|w| ..)` method takes [ctl::W](ctl::W) writer structure"]
    impl crate::Writable for CTL {}
    #[doc = "Control Register"]
    pub mod ctl {
        #[doc = "Reader of register ctl"]
        pub type R = crate::R<u32, super::CTL>;
        #[doc = "Writer for register ctl"]
        pub type W = crate::W<u32, super::CTL>;
        #[doc = "Register ctl `reset()`'s with value 0"]
        impl crate::ResetValue for super::CTL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dir_search_en`"]
        pub type DIR_SEARCH_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dir_search_en`"]
        pub struct DIR_SEARCH_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_SEARCH_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `search_path_reset`"]
        pub type SEARCH_PATH_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `search_path_reset`"]
        pub struct SEARCH_PATH_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SEARCH_PATH_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `stream_gen_en`"]
        pub type STREAM_GEN_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `stream_gen_en`"]
        pub struct STREAM_GEN_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STREAM_GEN_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `voice_gen_path_reset`"]
        pub type VOICE_GEN_PATH_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `voice_gen_path_reset`"]
        pub struct VOICE_GEN_PATH_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VOICE_GEN_PATH_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `update_voice_dir`"]
        pub type UPDATE_VOICE_DIR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `update_voice_dir`"]
        pub struct UPDATE_VOICE_DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UPDATE_VOICE_DIR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_dir_search_en`"]
        pub struct WE_DIR_SEARCH_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_DIR_SEARCH_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_search_path_rst`"]
        pub struct WE_SEARCH_PATH_RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_SEARCH_PATH_RST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_stream_gen`"]
        pub struct WE_STREAM_GEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_STREAM_GEN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_voice_gen_path_rst`"]
        pub struct WE_VOICE_GEN_PATH_RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_VOICE_GEN_PATH_RST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Write proxy for field `we_update_voice_dir`"]
        pub struct WE_UPDATE_VOICE_DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WE_UPDATE_VOICE_DIR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Sound direction searching enable bit"]
            #[inline(always)]
            pub fn dir_search_en(&self) -> DIR_SEARCH_EN_R {
                DIR_SEARCH_EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Reset all control logic on direction search processing path"]
            #[inline(always)]
            pub fn search_path_reset(&self) -> SEARCH_PATH_RESET_R {
                SEARCH_PATH_RESET_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 4 - Valid voice sample stream generation enable bit"]
            #[inline(always)]
            pub fn stream_gen_en(&self) -> STREAM_GEN_EN_R {
                STREAM_GEN_EN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Reset all control logic on voice stream generating path"]
            #[inline(always)]
            pub fn voice_gen_path_reset(&self) -> VOICE_GEN_PATH_RESET_R {
                VOICE_GEN_PATH_RESET_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Switch to a new voice source direction"]
            #[inline(always)]
            pub fn update_voice_dir(&self) -> UPDATE_VOICE_DIR_R {
                UPDATE_VOICE_DIR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Sound direction searching enable bit"]
            #[inline(always)]
            pub fn dir_search_en(&mut self) -> DIR_SEARCH_EN_W {
                DIR_SEARCH_EN_W { w: self }
            }
            #[doc = "Bit 1 - Reset all control logic on direction search processing path"]
            #[inline(always)]
            pub fn search_path_reset(&mut self) -> SEARCH_PATH_RESET_W {
                SEARCH_PATH_RESET_W { w: self }
            }
            #[doc = "Bit 4 - Valid voice sample stream generation enable bit"]
            #[inline(always)]
            pub fn stream_gen_en(&mut self) -> STREAM_GEN_EN_W {
                STREAM_GEN_EN_W { w: self }
            }
            #[doc = "Bit 5 - Reset all control logic on voice stream generating path"]
            #[inline(always)]
            pub fn voice_gen_path_reset(&mut self) -> VOICE_GEN_PATH_RESET_W {
                VOICE_GEN_PATH_RESET_W { w: self }
            }
            #[doc = "Bit 6 - Switch to a new voice source direction"]
            #[inline(always)]
            pub fn update_voice_dir(&mut self) -> UPDATE_VOICE_DIR_W {
                UPDATE_VOICE_DIR_W { w: self }
            }
            #[doc = "Bit 8 - Write enable for we_dir_search_en parameter"]
            #[inline(always)]
            pub fn we_dir_search_en(&mut self) -> WE_DIR_SEARCH_EN_W {
                WE_DIR_SEARCH_EN_W { w: self }
            }
            #[doc = "Bit 9 - Write enable for we_search_path_rst parameter"]
            #[inline(always)]
            pub fn we_search_path_rst(&mut self) -> WE_SEARCH_PATH_RST_W {
                WE_SEARCH_PATH_RST_W { w: self }
            }
            #[doc = "Bit 10 - Write enable for we_stream_gen parameter"]
            #[inline(always)]
            pub fn we_stream_gen(&mut self) -> WE_STREAM_GEN_W {
                WE_STREAM_GEN_W { w: self }
            }
            #[doc = "Bit 11 - Write enable for we_voice_gen_path_rst parameter"]
            #[inline(always)]
            pub fn we_voice_gen_path_rst(&mut self) -> WE_VOICE_GEN_PATH_RST_W {
                WE_VOICE_GEN_PATH_RST_W { w: self }
            }
            #[doc = "Bit 12 - Write enable for we_update_voice_dir parameter"]
            #[inline(always)]
            pub fn we_update_voice_dir(&mut self) -> WE_UPDATE_VOICE_DIR_W {
                WE_UPDATE_VOICE_DIR_W { w: self }
            }
        }
    }
    #[doc = "Direction Sample Buffer Read Index Configure Register (16 directions * 2 values * 4 indices)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dir_bidx](dir_bidx) module"]
    pub type DIR_BIDX = crate::Reg<u32, _DIR_BIDX>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DIR_BIDX;
    #[doc = "`read()` method returns [dir_bidx::R](dir_bidx::R) reader structure"]
    impl crate::Readable for DIR_BIDX {}
    #[doc = "`write(|w| ..)` method takes [dir_bidx::W](dir_bidx::W) writer structure"]
    impl crate::Writable for DIR_BIDX {}
    #[doc = "Direction Sample Buffer Read Index Configure Register (16 directions * 2 values * 4 indices)"]
    pub mod dir_bidx {
        #[doc = "Reader of register dir_bidx[%s]"]
        pub type R = crate::R<u32, super::DIR_BIDX>;
        #[doc = "Writer for register dir_bidx[%s]"]
        pub type W = crate::W<u32, super::DIR_BIDX>;
        #[doc = "Register dir_bidx[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::DIR_BIDX {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of fields `rd_idx(0-3)`"]
        pub type RD_IDX_R = crate::R<u8, u8>;
        #[doc = "Write proxy for fields `rd_idx(0-3)`"]
        pub struct RD_IDX_W<'a> {
            w: &'a mut W,
            offset: usize,
        }
        impl<'a> RD_IDX_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << self.offset))
                    | (((value as u32) & 0x3f) << self.offset);
                self.w
            }
        }
        impl R {
            #[doc = "rd_idx(0-3)"]
            #[inline(always)]
            pub unsafe fn rd_idx(&self, n: usize) -> RD_IDX_R {
                RD_IDX_R::new(((self.bits >> n * 8) & 0x3f) as u8)
            }
            #[doc = "Bits 0:5 - rd_idx0"]
            #[inline(always)]
            pub fn rd_idx0(&self) -> RD_IDX_R {
                RD_IDX_R::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bits 8:13 - rd_idx1"]
            #[inline(always)]
            pub fn rd_idx1(&self) -> RD_IDX_R {
                RD_IDX_R::new(((self.bits >> 8) & 0x3f) as u8)
            }
            #[doc = "Bits 16:21 - rd_idx2"]
            #[inline(always)]
            pub fn rd_idx2(&self) -> RD_IDX_R {
                RD_IDX_R::new(((self.bits >> 16) & 0x3f) as u8)
            }
            #[doc = "Bits 24:29 - rd_idx3"]
            #[inline(always)]
            pub fn rd_idx3(&self) -> RD_IDX_R {
                RD_IDX_R::new(((self.bits >> 24) & 0x3f) as u8)
            }
        }
        impl W {
            #[doc = "rd_idx(0-3)"]
            #[inline(always)]
            pub unsafe fn rd_idx(&mut self, n: usize) -> RD_IDX_W {
                RD_IDX_W {
                    w: self,
                    offset: n * 8,
                }
            }
            #[doc = "Bits 0:5 - rd_idx0"]
            #[inline(always)]
            pub fn rd_idx0(&mut self) -> RD_IDX_W {
                RD_IDX_W { w: self, offset: 0 }
            }
            #[doc = "Bits 8:13 - rd_idx1"]
            #[inline(always)]
            pub fn rd_idx1(&mut self) -> RD_IDX_W {
                RD_IDX_W { w: self, offset: 8 }
            }
            #[doc = "Bits 16:21 - rd_idx2"]
            #[inline(always)]
            pub fn rd_idx2(&mut self) -> RD_IDX_W {
                RD_IDX_W {
                    w: self,
                    offset: 16,
                }
            }
            #[doc = "Bits 24:29 - rd_idx3"]
            #[inline(always)]
            pub fn rd_idx3(&mut self) -> RD_IDX_W {
                RD_IDX_W {
                    w: self,
                    offset: 24,
                }
            }
        }
    }
    #[doc = "FIR0 pre-filter coefficients\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pre_fir0_coef](pre_fir0_coef) module"]
    pub type PRE_FIR0_COEF = crate::Reg<u32, _PRE_FIR0_COEF>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRE_FIR0_COEF;
    #[doc = "`read()` method returns [pre_fir0_coef::R](pre_fir0_coef::R) reader structure"]
    impl crate::Readable for PRE_FIR0_COEF {}
    #[doc = "`write(|w| ..)` method takes [pre_fir0_coef::W](pre_fir0_coef::W) writer structure"]
    impl crate::Writable for PRE_FIR0_COEF {}
    #[doc = "FIR0 pre-filter coefficients"]
    pub mod pre_fir0_coef {
        #[doc = "Reader of register pre_fir0_coef[%s]"]
        pub type R = crate::R<u32, super::PRE_FIR0_COEF>;
        #[doc = "Writer for register pre_fir0_coef[%s]"]
        pub type W = crate::W<u32, super::PRE_FIR0_COEF>;
        #[doc = "Register pre_fir0_coef[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::PRE_FIR0_COEF {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `tap0`"]
        pub type TAP0_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap0`"]
        pub struct TAP0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `tap1`"]
        pub type TAP1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap1`"]
        pub struct TAP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&self) -> TAP0_R {
                TAP0_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&self) -> TAP1_R {
                TAP1_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&mut self) -> TAP0_W {
                TAP0_W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&mut self) -> TAP1_W {
                TAP1_W { w: self }
            }
        }
    }
    #[doc = "FIR0 post-filter coefficients\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [post_fir0_coef](post_fir0_coef) module"]
    pub type POST_FIR0_COEF = crate::Reg<u32, _POST_FIR0_COEF>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _POST_FIR0_COEF;
    #[doc = "`read()` method returns [post_fir0_coef::R](post_fir0_coef::R) reader structure"]
    impl crate::Readable for POST_FIR0_COEF {}
    #[doc = "`write(|w| ..)` method takes [post_fir0_coef::W](post_fir0_coef::W) writer structure"]
    impl crate::Writable for POST_FIR0_COEF {}
    #[doc = "FIR0 post-filter coefficients"]
    pub mod post_fir0_coef {
        #[doc = "Reader of register post_fir0_coef[%s]"]
        pub type R = crate::R<u32, super::POST_FIR0_COEF>;
        #[doc = "Writer for register post_fir0_coef[%s]"]
        pub type W = crate::W<u32, super::POST_FIR0_COEF>;
        #[doc = "Register post_fir0_coef[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::POST_FIR0_COEF {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `tap0`"]
        pub type TAP0_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap0`"]
        pub struct TAP0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `tap1`"]
        pub type TAP1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap1`"]
        pub struct TAP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&self) -> TAP0_R {
                TAP0_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&self) -> TAP1_R {
                TAP1_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&mut self) -> TAP0_W {
                TAP0_W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&mut self) -> TAP1_W {
                TAP1_W { w: self }
            }
        }
    }
    #[doc = "FIR1 pre-filter coeffecients\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pre_fir1_coef](pre_fir1_coef) module"]
    pub type PRE_FIR1_COEF = crate::Reg<u32, _PRE_FIR1_COEF>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PRE_FIR1_COEF;
    #[doc = "`read()` method returns [pre_fir1_coef::R](pre_fir1_coef::R) reader structure"]
    impl crate::Readable for PRE_FIR1_COEF {}
    #[doc = "`write(|w| ..)` method takes [pre_fir1_coef::W](pre_fir1_coef::W) writer structure"]
    impl crate::Writable for PRE_FIR1_COEF {}
    #[doc = "FIR1 pre-filter coeffecients"]
    pub mod pre_fir1_coef {
        #[doc = "Reader of register pre_fir1_coef[%s]"]
        pub type R = crate::R<u32, super::PRE_FIR1_COEF>;
        #[doc = "Writer for register pre_fir1_coef[%s]"]
        pub type W = crate::W<u32, super::PRE_FIR1_COEF>;
        #[doc = "Register pre_fir1_coef[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::PRE_FIR1_COEF {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `tap0`"]
        pub type TAP0_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap0`"]
        pub struct TAP0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `tap1`"]
        pub type TAP1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap1`"]
        pub struct TAP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&self) -> TAP0_R {
                TAP0_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&self) -> TAP1_R {
                TAP1_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&mut self) -> TAP0_W {
                TAP0_W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&mut self) -> TAP1_W {
                TAP1_W { w: self }
            }
        }
    }
    #[doc = "FIR1 post-filter coefficients\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [post_fir1_coef](post_fir1_coef) module"]
    pub type POST_FIR1_COEF = crate::Reg<u32, _POST_FIR1_COEF>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _POST_FIR1_COEF;
    #[doc = "`read()` method returns [post_fir1_coef::R](post_fir1_coef::R) reader structure"]
    impl crate::Readable for POST_FIR1_COEF {}
    #[doc = "`write(|w| ..)` method takes [post_fir1_coef::W](post_fir1_coef::W) writer structure"]
    impl crate::Writable for POST_FIR1_COEF {}
    #[doc = "FIR1 post-filter coefficients"]
    pub mod post_fir1_coef {
        #[doc = "Reader of register post_fir1_coef[%s]"]
        pub type R = crate::R<u32, super::POST_FIR1_COEF>;
        #[doc = "Writer for register post_fir1_coef[%s]"]
        pub type W = crate::W<u32, super::POST_FIR1_COEF>;
        #[doc = "Register post_fir1_coef[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::POST_FIR1_COEF {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `tap0`"]
        pub type TAP0_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap0`"]
        pub struct TAP0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `tap1`"]
        pub type TAP1_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tap1`"]
        pub struct TAP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAP1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&self) -> TAP0_R {
                TAP0_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&self) -> TAP1_R {
                TAP1_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Tap 0"]
            #[inline(always)]
            pub fn tap0(&mut self) -> TAP0_W {
                TAP0_W { w: self }
            }
            #[doc = "Bits 16:31 - Tap 1"]
            #[inline(always)]
            pub fn tap1(&mut self) -> TAP1_W {
                TAP1_W { w: self }
            }
        }
    }
    #[doc = "Downsize Config Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dwsz_cfg](dwsz_cfg) module"]
    pub type DWSZ_CFG = crate::Reg<u32, _DWSZ_CFG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DWSZ_CFG;
    #[doc = "`read()` method returns [dwsz_cfg::R](dwsz_cfg::R) reader structure"]
    impl crate::Readable for DWSZ_CFG {}
    #[doc = "`write(|w| ..)` method takes [dwsz_cfg::W](dwsz_cfg::W) writer structure"]
    impl crate::Writable for DWSZ_CFG {}
    #[doc = "Downsize Config Register"]
    pub mod dwsz_cfg {
        #[doc = "Reader of register dwsz_cfg"]
        pub type R = crate::R<u32, super::DWSZ_CFG>;
        #[doc = "Writer for register dwsz_cfg"]
        pub type W = crate::W<u32, super::DWSZ_CFG>;
        #[doc = "Register dwsz_cfg `reset()`'s with value 0"]
        impl crate::ResetValue for super::DWSZ_CFG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dir_dwn_siz_rate`"]
        pub type DIR_DWN_SIZ_RATE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `dir_dwn_siz_rate`"]
        pub struct DIR_DWN_SIZ_RATE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_DWN_SIZ_RATE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `voc_dwn_siz_rate`"]
        pub type VOC_DWN_SIZ_RATE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `voc_dwn_siz_rate`"]
        pub struct VOC_DWN_SIZ_RATE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VOC_DWN_SIZ_RATE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `smpl_shift_bits`"]
        pub type SMPL_SHIFT_BITS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `smpl_shift_bits`"]
        pub struct SMPL_SHIFT_BITS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMPL_SHIFT_BITS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - Down-sizing ratio used for direction searching"]
            #[inline(always)]
            pub fn dir_dwn_siz_rate(&self) -> DIR_DWN_SIZ_RATE_R {
                DIR_DWN_SIZ_RATE_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Down-sizing ratio used for voice stream generation"]
            #[inline(always)]
            pub fn voc_dwn_siz_rate(&self) -> VOC_DWN_SIZ_RATE_R {
                VOC_DWN_SIZ_RATE_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:12 - Sample precision reduction when the source sound sample precision is 20/24/32 bits"]
            #[inline(always)]
            pub fn smpl_shift_bits(&self) -> SMPL_SHIFT_BITS_R {
                SMPL_SHIFT_BITS_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Down-sizing ratio used for direction searching"]
            #[inline(always)]
            pub fn dir_dwn_siz_rate(&mut self) -> DIR_DWN_SIZ_RATE_W {
                DIR_DWN_SIZ_RATE_W { w: self }
            }
            #[doc = "Bits 4:7 - Down-sizing ratio used for voice stream generation"]
            #[inline(always)]
            pub fn voc_dwn_siz_rate(&mut self) -> VOC_DWN_SIZ_RATE_W {
                VOC_DWN_SIZ_RATE_W { w: self }
            }
            #[doc = "Bits 8:12 - Sample precision reduction when the source sound sample precision is 20/24/32 bits"]
            #[inline(always)]
            pub fn smpl_shift_bits(&mut self) -> SMPL_SHIFT_BITS_W {
                SMPL_SHIFT_BITS_W { w: self }
            }
        }
    }
    #[doc = "FFT Config Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fft_cfg](fft_cfg) module"]
    pub type FFT_CFG = crate::Reg<u32, _FFT_CFG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FFT_CFG;
    #[doc = "`read()` method returns [fft_cfg::R](fft_cfg::R) reader structure"]
    impl crate::Readable for FFT_CFG {}
    #[doc = "`write(|w| ..)` method takes [fft_cfg::W](fft_cfg::W) writer structure"]
    impl crate::Writable for FFT_CFG {}
    #[doc = "FFT Config Register"]
    pub mod fft_cfg {
        #[doc = "Reader of register fft_cfg"]
        pub type R = crate::R<u32, super::FFT_CFG>;
        #[doc = "Writer for register fft_cfg"]
        pub type W = crate::W<u32, super::FFT_CFG>;
        #[doc = "Register fft_cfg `reset()`'s with value 0"]
        impl crate::ResetValue for super::FFT_CFG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Read register for DMA to sample-out buffers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sobuf_dma_rdata](sobuf_dma_rdata) module"]
    pub type SOBUF_DMA_RDATA = crate::Reg<u32, _SOBUF_DMA_RDATA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SOBUF_DMA_RDATA;
    #[doc = "`read()` method returns [sobuf_dma_rdata::R](sobuf_dma_rdata::R) reader structure"]
    impl crate::Readable for SOBUF_DMA_RDATA {}
    #[doc = "`write(|w| ..)` method takes [sobuf_dma_rdata::W](sobuf_dma_rdata::W) writer structure"]
    impl crate::Writable for SOBUF_DMA_RDATA {}
    #[doc = "Read register for DMA to sample-out buffers"]
    pub mod sobuf_dma_rdata {
        #[doc = "Reader of register sobuf_dma_rdata"]
        pub type R = crate::R<u32, super::SOBUF_DMA_RDATA>;
        #[doc = "Writer for register sobuf_dma_rdata"]
        pub type W = crate::W<u32, super::SOBUF_DMA_RDATA>;
        #[doc = "Register sobuf_dma_rdata `reset()`'s with value 0"]
        impl crate::ResetValue for super::SOBUF_DMA_RDATA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Read register for DMA to voice-out buffers\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [vobuf_dma_rdata](vobuf_dma_rdata) module"]
    pub type VOBUF_DMA_RDATA = crate::Reg<u32, _VOBUF_DMA_RDATA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _VOBUF_DMA_RDATA;
    #[doc = "`read()` method returns [vobuf_dma_rdata::R](vobuf_dma_rdata::R) reader structure"]
    impl crate::Readable for VOBUF_DMA_RDATA {}
    #[doc = "`write(|w| ..)` method takes [vobuf_dma_rdata::W](vobuf_dma_rdata::W) writer structure"]
    impl crate::Writable for VOBUF_DMA_RDATA {}
    #[doc = "Read register for DMA to voice-out buffers"]
    pub mod vobuf_dma_rdata {
        #[doc = "Reader of register vobuf_dma_rdata"]
        pub type R = crate::R<u32, super::VOBUF_DMA_RDATA>;
        #[doc = "Writer for register vobuf_dma_rdata"]
        pub type W = crate::W<u32, super::VOBUF_DMA_RDATA>;
        #[doc = "Register vobuf_dma_rdata `reset()`'s with value 0"]
        impl crate::ResetValue for super::VOBUF_DMA_RDATA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int_stat](int_stat) module"]
    pub type INT_STAT = crate::Reg<u32, _INT_STAT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INT_STAT;
    #[doc = "`read()` method returns [int_stat::R](int_stat::R) reader structure"]
    impl crate::Readable for INT_STAT {}
    #[doc = "`write(|w| ..)` method takes [int_stat::W](int_stat::W) writer structure"]
    impl crate::Writable for INT_STAT {}
    #[doc = "Interrupt Status Register"]
    pub mod int_stat {
        #[doc = "Reader of register int_stat"]
        pub type R = crate::R<u32, super::INT_STAT>;
        #[doc = "Writer for register int_stat"]
        pub type W = crate::W<u32, super::INT_STAT>;
        #[doc = "Register int_stat `reset()`'s with value 0"]
        impl crate::ResetValue for super::INT_STAT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dir_search_data_rdy`"]
        pub type DIR_SEARCH_DATA_RDY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dir_search_data_rdy`"]
        pub struct DIR_SEARCH_DATA_RDY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_SEARCH_DATA_RDY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `voc_buf_data_rdy`"]
        pub type VOC_BUF_DATA_RDY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `voc_buf_data_rdy`"]
        pub struct VOC_BUF_DATA_RDY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VOC_BUF_DATA_RDY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline(always)]
            pub fn dir_search_data_rdy(&self) -> DIR_SEARCH_DATA_RDY_R {
                DIR_SEARCH_DATA_RDY_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline(always)]
            pub fn voc_buf_data_rdy(&self) -> VOC_BUF_DATA_RDY_R {
                VOC_BUF_DATA_RDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline(always)]
            pub fn dir_search_data_rdy(&mut self) -> DIR_SEARCH_DATA_RDY_W {
                DIR_SEARCH_DATA_RDY_W { w: self }
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline(always)]
            pub fn voc_buf_data_rdy(&mut self) -> VOC_BUF_DATA_RDY_W {
                VOC_BUF_DATA_RDY_W { w: self }
            }
        }
    }
    #[doc = "Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [int_mask](int_mask) module"]
    pub type INT_MASK = crate::Reg<u32, _INT_MASK>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INT_MASK;
    #[doc = "`read()` method returns [int_mask::R](int_mask::R) reader structure"]
    impl crate::Readable for INT_MASK {}
    #[doc = "`write(|w| ..)` method takes [int_mask::W](int_mask::W) writer structure"]
    impl crate::Writable for INT_MASK {}
    #[doc = "Interrupt Mask Register"]
    pub mod int_mask {
        #[doc = "Reader of register int_mask"]
        pub type R = crate::R<u32, super::INT_MASK>;
        #[doc = "Writer for register int_mask"]
        pub type W = crate::W<u32, super::INT_MASK>;
        #[doc = "Register int_mask `reset()`'s with value 0"]
        impl crate::ResetValue for super::INT_MASK {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dir_search_data_rdy`"]
        pub type DIR_SEARCH_DATA_RDY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dir_search_data_rdy`"]
        pub struct DIR_SEARCH_DATA_RDY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_SEARCH_DATA_RDY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `voc_buf_data_rdy`"]
        pub type VOC_BUF_DATA_RDY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `voc_buf_data_rdy`"]
        pub struct VOC_BUF_DATA_RDY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VOC_BUF_DATA_RDY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline(always)]
            pub fn dir_search_data_rdy(&self) -> DIR_SEARCH_DATA_RDY_R {
                DIR_SEARCH_DATA_RDY_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline(always)]
            pub fn voc_buf_data_rdy(&self) -> VOC_BUF_DATA_RDY_R {
                VOC_BUF_DATA_RDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Sound direction searching data ready interrupt event"]
            #[inline(always)]
            pub fn dir_search_data_rdy(&mut self) -> DIR_SEARCH_DATA_RDY_W {
                DIR_SEARCH_DATA_RDY_W { w: self }
            }
            #[doc = "Bit 1 - Voice output stream buffer data ready interrupt event"]
            #[inline(always)]
            pub fn voc_buf_data_rdy(&mut self) -> VOC_BUF_DATA_RDY_W {
                VOC_BUF_DATA_RDY_W { w: self }
            }
        }
    }
    #[doc = "Saturation Counter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sat_counter](sat_counter) module"]
    pub type SAT_COUNTER = crate::Reg<u32, _SAT_COUNTER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SAT_COUNTER;
    #[doc = "`read()` method returns [sat_counter::R](sat_counter::R) reader structure"]
    impl crate::Readable for SAT_COUNTER {}
    #[doc = "`write(|w| ..)` method takes [sat_counter::W](sat_counter::W) writer structure"]
    impl crate::Writable for SAT_COUNTER {}
    #[doc = "Saturation Counter"]
    pub mod sat_counter {
        #[doc = "Reader of register sat_counter"]
        pub type R = crate::R<u32, super::SAT_COUNTER>;
        #[doc = "Writer for register sat_counter"]
        pub type W = crate::W<u32, super::SAT_COUNTER>;
        #[doc = "Register sat_counter `reset()`'s with value 0"]
        impl crate::ResetValue for super::SAT_COUNTER {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `counter`"]
        pub type COUNTER_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `counter`"]
        pub struct COUNTER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNTER_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `total`"]
        pub type TOTAL_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `total`"]
        pub struct TOTAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TOTAL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Counter"]
            #[inline(always)]
            pub fn counter(&self) -> COUNTER_R {
                COUNTER_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Total"]
            #[inline(always)]
            pub fn total(&self) -> TOTAL_R {
                TOTAL_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Counter"]
            #[inline(always)]
            pub fn counter(&mut self) -> COUNTER_W {
                COUNTER_W { w: self }
            }
            #[doc = "Bits 16:31 - Total"]
            #[inline(always)]
            pub fn total(&mut self) -> TOTAL_W {
                TOTAL_W { w: self }
            }
        }
    }
    #[doc = "Saturation Limits\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sat_limits](sat_limits) module"]
    pub type SAT_LIMITS = crate::Reg<u32, _SAT_LIMITS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SAT_LIMITS;
    #[doc = "`read()` method returns [sat_limits::R](sat_limits::R) reader structure"]
    impl crate::Readable for SAT_LIMITS {}
    #[doc = "`write(|w| ..)` method takes [sat_limits::W](sat_limits::W) writer structure"]
    impl crate::Writable for SAT_LIMITS {}
    #[doc = "Saturation Limits"]
    pub mod sat_limits {
        #[doc = "Reader of register sat_limits"]
        pub type R = crate::R<u32, super::SAT_LIMITS>;
        #[doc = "Writer for register sat_limits"]
        pub type W = crate::W<u32, super::SAT_LIMITS>;
        #[doc = "Register sat_limits `reset()`'s with value 0"]
        impl crate::ResetValue for super::SAT_LIMITS {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `upper`"]
        pub type UPPER_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `upper`"]
        pub struct UPPER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UPPER_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `bottom`"]
        pub type BOTTOM_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `bottom`"]
        pub struct BOTTOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BOTTOM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - Upper limit"]
            #[inline(always)]
            pub fn upper(&self) -> UPPER_R {
                UPPER_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Bottom limit"]
            #[inline(always)]
            pub fn bottom(&self) -> BOTTOM_R {
                BOTTOM_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Upper limit"]
            #[inline(always)]
            pub fn upper(&mut self) -> UPPER_W {
                UPPER_W { w: self }
            }
            #[doc = "Bits 16:31 - Bottom limit"]
            #[inline(always)]
            pub fn bottom(&mut self) -> BOTTOM_W {
                BOTTOM_W { w: self }
            }
        }
    }
}
#[doc = "Inter-Integrated Sound Interface 1"]
pub struct I2S1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2S1 {}
impl I2S1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        0x5026_0000 as *const _
    }
}
impl Deref for I2S1 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2S1::ptr() }
    }
}
#[doc = "Inter-Integrated Sound Interface 2"]
pub struct I2S2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2S2 {}
impl I2S2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        0x5027_0000 as *const _
    }
}
impl Deref for I2S2 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2S2::ptr() }
    }
}
#[doc = "Inter-Integrated Circuit Bus 0"]
pub struct I2C0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C0 {}
impl I2C0 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        0x5028_0000 as *const _
    }
}
impl Deref for I2C0 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C0::ptr() }
    }
}
#[doc = "Inter-Integrated Circuit Bus 0"]
pub mod i2c0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register"]
        pub con: CON,
        #[doc = "0x04 - Target Address Register"]
        pub tar: TAR,
        #[doc = "0x08 - Slave Address Register"]
        pub sar: SAR,
        _reserved3: [u8; 4usize],
        #[doc = "0x10 - Data Buffer and Command Register"]
        pub data_cmd: DATA_CMD,
        #[doc = "0x14 - Standard Speed Clock SCL High Count Register"]
        pub ss_scl_hcnt: SS_SCL_HCNT,
        #[doc = "0x18 - Standard Speed Clock SCL Low Count Register"]
        pub ss_scl_lcnt: SS_SCL_LCNT,
        _reserved6: [u8; 16usize],
        #[doc = "0x2c - Interrupt Status Register"]
        pub intr_stat: INTR_STAT,
        #[doc = "0x30 - Interrupt Mask Register"]
        pub intr_mask: INTR_MASK,
        #[doc = "0x34 - Raw Interrupt Status Register"]
        pub raw_intr_stat: RAW_INTR_STAT,
        #[doc = "0x38 - Receive FIFO Threshold Register"]
        pub rx_tl: RX_TL,
        #[doc = "0x3c - Transmit FIFO Threshold Register"]
        pub tx_tl: TX_TL,
        #[doc = "0x40 - Clear Combined and Individual Interrupt Register"]
        pub clr_intr: CLR_INTR,
        #[doc = "0x44 - Clear RX_UNDER Interrupt Register"]
        pub clr_rx_under: CLR_RX_UNDER,
        #[doc = "0x48 - Clear RX_OVER Interrupt Register"]
        pub clr_rx_over: CLR_RX_OVER,
        #[doc = "0x4c - Clear TX_OVER Interrupt Register"]
        pub clr_tx_over: CLR_TX_OVER,
        #[doc = "0x50 - Clear RD_REQ Interrupt Register"]
        pub clr_rd_req: CLR_RD_REQ,
        #[doc = "0x54 - Clear TX_ABRT Interrupt Register"]
        pub clr_tx_abrt: CLR_TX_ABRT,
        #[doc = "0x58 - Clear RX_DONE Interrupt Register"]
        pub clr_rx_done: CLR_RX_DONE,
        #[doc = "0x5c - Clear ACTIVITY Interrupt Register"]
        pub clr_activity: CLR_ACTIVITY,
        #[doc = "0x60 - Clear STOP_DET Interrupt Register"]
        pub clr_stop_det: CLR_STOP_DET,
        #[doc = "0x64 - Clear START_DET Interrupt Register"]
        pub clr_start_det: CLR_START_DET,
        #[doc = "0x68 - I2C Clear GEN_CALL Interrupt Register"]
        pub clr_gen_call: CLR_GEN_CALL,
        #[doc = "0x6c - Enable Register"]
        pub enable: ENABLE,
        #[doc = "0x70 - Status Register"]
        pub status: STATUS,
        #[doc = "0x74 - Transmit FIFO Level Register"]
        pub txflr: TXFLR,
        #[doc = "0x78 - Receive FIFO Level Register"]
        pub rxflr: RXFLR,
        #[doc = "0x7c - SDA Hold Time Length Register"]
        pub sda_hold: SDA_HOLD,
        #[doc = "0x80 - Transmit Abort Source Register"]
        pub tx_abrt_source: TX_ABRT_SOURCE,
        _reserved28: [u8; 4usize],
        #[doc = "0x88 - I2C DMA Control Register"]
        pub dma_cr: DMA_CR,
        #[doc = "0x8c - DMA Transmit Data Level Register"]
        pub dma_tdlr: DMA_TDLR,
        #[doc = "0x90 - DMA Receive Data Level Register"]
        pub dma_rdlr: DMA_RDLR,
        #[doc = "0x94 - SDA Setup Register"]
        pub sda_setup: SDA_SETUP,
        #[doc = "0x98 - ACK General Call Register"]
        pub general_call: GENERAL_CALL,
        #[doc = "0x9c - Enable Status Register"]
        pub enable_status: ENABLE_STATUS,
        #[doc = "0xa0 - SS, FS or FM+ spike suppression limit"]
        pub fs_spklen: FS_SPKLEN,
        _reserved35: [u8; 80usize],
        #[doc = "0xf4 - Component Parameter Register 1"]
        pub comp_param_1: COMP_PARAM_1,
        #[doc = "0xf8 - Component Version Register"]
        pub comp_version: COMP_VERSION,
        #[doc = "0xfc - Component Type Register"]
        pub comp_type: COMP_TYPE,
    }
    #[doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [con](con) module"]
    pub type CON = crate::Reg<u32, _CON>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CON;
    #[doc = "`read()` method returns [con::R](con::R) reader structure"]
    impl crate::Readable for CON {}
    #[doc = "`write(|w| ..)` method takes [con::W](con::W) writer structure"]
    impl crate::Writable for CON {}
    #[doc = "Control Register"]
    pub mod con {
        #[doc = "Reader of register con"]
        pub type R = crate::R<u32, super::CON>;
        #[doc = "Writer for register con"]
        pub type W = crate::W<u32, super::CON>;
        #[doc = "Register con `reset()`'s with value 0"]
        impl crate::ResetValue for super::CON {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `master_mode`"]
        pub type MASTER_MODE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `master_mode`"]
        pub struct MASTER_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MASTER_MODE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Speed\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SPEED_A {
            #[doc = "0: STANDARD"]
            STANDARD = 0,
            #[doc = "1: FAST"]
            FAST = 1,
            #[doc = "2: HIGHSPEED"]
            HIGHSPEED = 2,
        }
        impl From<SPEED_A> for u8 {
            #[inline(always)]
            fn from(variant: SPEED_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `speed`"]
        pub type SPEED_R = crate::R<u8, SPEED_A>;
        impl SPEED_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, SPEED_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(SPEED_A::STANDARD),
                    1 => Val(SPEED_A::FAST),
                    2 => Val(SPEED_A::HIGHSPEED),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD`"]
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                *self == SPEED_A::STANDARD
            }
            #[doc = "Checks if the value of the field is `FAST`"]
            #[inline(always)]
            pub fn is_fast(&self) -> bool {
                *self == SPEED_A::FAST
            }
            #[doc = "Checks if the value of the field is `HIGHSPEED`"]
            #[inline(always)]
            pub fn is_highspeed(&self) -> bool {
                *self == SPEED_A::HIGHSPEED
            }
        }
        #[doc = "Write proxy for field `speed`"]
        pub struct SPEED_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPEED_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPEED_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "STANDARD"]
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(SPEED_A::STANDARD)
            }
            #[doc = "FAST"]
            #[inline(always)]
            pub fn fast(self) -> &'a mut W {
                self.variant(SPEED_A::FAST)
            }
            #[doc = "HIGHSPEED"]
            #[inline(always)]
            pub fn highspeed(self) -> &'a mut W {
                self.variant(SPEED_A::HIGHSPEED)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 1)) | (((value as u32) & 0x03) << 1);
                self.w
            }
        }
        #[doc = "Slave address width\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_SLAVE_WIDTH_A {
            #[doc = "0: 7-bit address"]
            B7 = 0,
            #[doc = "1: 10-bit address"]
            B10 = 1,
        }
        impl From<ADDR_SLAVE_WIDTH_A> for bool {
            #[inline(always)]
            fn from(variant: ADDR_SLAVE_WIDTH_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `addr_slave_width`"]
        pub type ADDR_SLAVE_WIDTH_R = crate::R<bool, ADDR_SLAVE_WIDTH_A>;
        impl ADDR_SLAVE_WIDTH_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDR_SLAVE_WIDTH_A {
                match self.bits {
                    false => ADDR_SLAVE_WIDTH_A::B7,
                    true => ADDR_SLAVE_WIDTH_A::B10,
                }
            }
            #[doc = "Checks if the value of the field is `B7`"]
            #[inline(always)]
            pub fn is_b7(&self) -> bool {
                *self == ADDR_SLAVE_WIDTH_A::B7
            }
            #[doc = "Checks if the value of the field is `B10`"]
            #[inline(always)]
            pub fn is_b10(&self) -> bool {
                *self == ADDR_SLAVE_WIDTH_A::B10
            }
        }
        #[doc = "Write proxy for field `addr_slave_width`"]
        pub struct ADDR_SLAVE_WIDTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDR_SLAVE_WIDTH_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDR_SLAVE_WIDTH_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "7-bit address"]
            #[inline(always)]
            pub fn b7(self) -> &'a mut W {
                self.variant(ADDR_SLAVE_WIDTH_A::B7)
            }
            #[doc = "10-bit address"]
            #[inline(always)]
            pub fn b10(self) -> &'a mut W {
                self.variant(ADDR_SLAVE_WIDTH_A::B10)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `restart_en`"]
        pub type RESTART_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `restart_en`"]
        pub struct RESTART_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESTART_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `slave_disable`"]
        pub type SLAVE_DISABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slave_disable`"]
        pub struct SLAVE_DISABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLAVE_DISABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `stop_det`"]
        pub type STOP_DET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `stop_det`"]
        pub struct STOP_DET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_DET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `tx_empty`"]
        pub type TX_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_empty`"]
        pub struct TX_EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Master Mode"]
            #[inline(always)]
            pub fn master_mode(&self) -> MASTER_MODE_R {
                MASTER_MODE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 1:2 - Speed"]
            #[inline(always)]
            pub fn speed(&self) -> SPEED_R {
                SPEED_R::new(((self.bits >> 1) & 0x03) as u8)
            }
            #[doc = "Bit 3 - Slave address width"]
            #[inline(always)]
            pub fn addr_slave_width(&self) -> ADDR_SLAVE_WIDTH_R {
                ADDR_SLAVE_WIDTH_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 5 - Enable Restart"]
            #[inline(always)]
            pub fn restart_en(&self) -> RESTART_EN_R {
                RESTART_EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - Disable Slave"]
            #[inline(always)]
            pub fn slave_disable(&self) -> SLAVE_DISABLE_R {
                SLAVE_DISABLE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - STOP_DET_IFADDRESSED"]
            #[inline(always)]
            pub fn stop_det(&self) -> STOP_DET_R {
                STOP_DET_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - TX_EMPTY_CTRL"]
            #[inline(always)]
            pub fn tx_empty(&self) -> TX_EMPTY_R {
                TX_EMPTY_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Master Mode"]
            #[inline(always)]
            pub fn master_mode(&mut self) -> MASTER_MODE_W {
                MASTER_MODE_W { w: self }
            }
            #[doc = "Bits 1:2 - Speed"]
            #[inline(always)]
            pub fn speed(&mut self) -> SPEED_W {
                SPEED_W { w: self }
            }
            #[doc = "Bit 3 - Slave address width"]
            #[inline(always)]
            pub fn addr_slave_width(&mut self) -> ADDR_SLAVE_WIDTH_W {
                ADDR_SLAVE_WIDTH_W { w: self }
            }
            #[doc = "Bit 5 - Enable Restart"]
            #[inline(always)]
            pub fn restart_en(&mut self) -> RESTART_EN_W {
                RESTART_EN_W { w: self }
            }
            #[doc = "Bit 6 - Disable Slave"]
            #[inline(always)]
            pub fn slave_disable(&mut self) -> SLAVE_DISABLE_W {
                SLAVE_DISABLE_W { w: self }
            }
            #[doc = "Bit 7 - STOP_DET_IFADDRESSED"]
            #[inline(always)]
            pub fn stop_det(&mut self) -> STOP_DET_W {
                STOP_DET_W { w: self }
            }
            #[doc = "Bit 8 - TX_EMPTY_CTRL"]
            #[inline(always)]
            pub fn tx_empty(&mut self) -> TX_EMPTY_W {
                TX_EMPTY_W { w: self }
            }
        }
    }
    #[doc = "Target Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tar](tar) module"]
    pub type TAR = crate::Reg<u32, _TAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TAR;
    #[doc = "`read()` method returns [tar::R](tar::R) reader structure"]
    impl crate::Readable for TAR {}
    #[doc = "`write(|w| ..)` method takes [tar::W](tar::W) writer structure"]
    impl crate::Writable for TAR {}
    #[doc = "Target Address Register"]
    pub mod tar {
        #[doc = "Reader of register tar"]
        pub type R = crate::R<u32, super::TAR>;
        #[doc = "Writer for register tar"]
        pub type W = crate::W<u32, super::TAR>;
        #[doc = "Register tar `reset()`'s with value 0"]
        impl crate::ResetValue for super::TAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `address`"]
        pub type ADDRESS_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `address`"]
        pub struct ADDRESS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDRESS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03ff) | ((value as u32) & 0x03ff);
                self.w
            }
        }
        #[doc = "Reader of field `gc`"]
        pub type GC_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gc`"]
        pub struct GC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GC_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `special`"]
        pub type SPECIAL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `special`"]
        pub struct SPECIAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPECIAL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Master Address\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_MASTER_WIDTH_A {
            #[doc = "0: 7-bit address"]
            B7 = 0,
            #[doc = "1: 10-bit address"]
            B10 = 1,
        }
        impl From<ADDR_MASTER_WIDTH_A> for bool {
            #[inline(always)]
            fn from(variant: ADDR_MASTER_WIDTH_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `addr_master_width`"]
        pub type ADDR_MASTER_WIDTH_R = crate::R<bool, ADDR_MASTER_WIDTH_A>;
        impl ADDR_MASTER_WIDTH_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ADDR_MASTER_WIDTH_A {
                match self.bits {
                    false => ADDR_MASTER_WIDTH_A::B7,
                    true => ADDR_MASTER_WIDTH_A::B10,
                }
            }
            #[doc = "Checks if the value of the field is `B7`"]
            #[inline(always)]
            pub fn is_b7(&self) -> bool {
                *self == ADDR_MASTER_WIDTH_A::B7
            }
            #[doc = "Checks if the value of the field is `B10`"]
            #[inline(always)]
            pub fn is_b10(&self) -> bool {
                *self == ADDR_MASTER_WIDTH_A::B10
            }
        }
        #[doc = "Write proxy for field `addr_master_width`"]
        pub struct ADDR_MASTER_WIDTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDR_MASTER_WIDTH_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDR_MASTER_WIDTH_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "7-bit address"]
            #[inline(always)]
            pub fn b7(self) -> &'a mut W {
                self.variant(ADDR_MASTER_WIDTH_A::B7)
            }
            #[doc = "10-bit address"]
            #[inline(always)]
            pub fn b10(self) -> &'a mut W {
                self.variant(ADDR_MASTER_WIDTH_A::B10)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:9 - Target Address"]
            #[inline(always)]
            pub fn address(&self) -> ADDRESS_R {
                ADDRESS_R::new((self.bits & 0x03ff) as u16)
            }
            #[doc = "Bit 10 - GC_OR_START"]
            #[inline(always)]
            pub fn gc(&self) -> GC_R {
                GC_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - SPECIAL"]
            #[inline(always)]
            pub fn special(&self) -> SPECIAL_R {
                SPECIAL_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - Master Address"]
            #[inline(always)]
            pub fn addr_master_width(&self) -> ADDR_MASTER_WIDTH_R {
                ADDR_MASTER_WIDTH_R::new(((self.bits >> 12) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - Target Address"]
            #[inline(always)]
            pub fn address(&mut self) -> ADDRESS_W {
                ADDRESS_W { w: self }
            }
            #[doc = "Bit 10 - GC_OR_START"]
            #[inline(always)]
            pub fn gc(&mut self) -> GC_W {
                GC_W { w: self }
            }
            #[doc = "Bit 11 - SPECIAL"]
            #[inline(always)]
            pub fn special(&mut self) -> SPECIAL_W {
                SPECIAL_W { w: self }
            }
            #[doc = "Bit 12 - Master Address"]
            #[inline(always)]
            pub fn addr_master_width(&mut self) -> ADDR_MASTER_WIDTH_W {
                ADDR_MASTER_WIDTH_W { w: self }
            }
        }
    }
    #[doc = "Slave Address Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sar](sar) module"]
    pub type SAR = crate::Reg<u32, _SAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SAR;
    #[doc = "`read()` method returns [sar::R](sar::R) reader structure"]
    impl crate::Readable for SAR {}
    #[doc = "`write(|w| ..)` method takes [sar::W](sar::W) writer structure"]
    impl crate::Writable for SAR {}
    #[doc = "Slave Address Register"]
    pub mod sar {
        #[doc = "Reader of register sar"]
        pub type R = crate::R<u32, super::SAR>;
        #[doc = "Writer for register sar"]
        pub type W = crate::W<u32, super::SAR>;
        #[doc = "Register sar `reset()`'s with value 0"]
        impl crate::ResetValue for super::SAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `address`"]
        pub type ADDRESS_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `address`"]
        pub struct ADDRESS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDRESS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03ff) | ((value as u32) & 0x03ff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:9 - Slave Address"]
            #[inline(always)]
            pub fn address(&self) -> ADDRESS_R {
                ADDRESS_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:9 - Slave Address"]
            #[inline(always)]
            pub fn address(&mut self) -> ADDRESS_W {
                ADDRESS_W { w: self }
            }
        }
    }
    #[doc = "Data Buffer and Command Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_cmd](data_cmd) module"]
    pub type DATA_CMD = crate::Reg<u32, _DATA_CMD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DATA_CMD;
    #[doc = "`read()` method returns [data_cmd::R](data_cmd::R) reader structure"]
    impl crate::Readable for DATA_CMD {}
    #[doc = "`write(|w| ..)` method takes [data_cmd::W](data_cmd::W) writer structure"]
    impl crate::Writable for DATA_CMD {}
    #[doc = "Data Buffer and Command Register"]
    pub mod data_cmd {
        #[doc = "Reader of register data_cmd"]
        pub type R = crate::R<u32, super::DATA_CMD>;
        #[doc = "Writer for register data_cmd"]
        pub type W = crate::W<u32, super::DATA_CMD>;
        #[doc = "Register data_cmd `reset()`'s with value 0"]
        impl crate::ResetValue for super::DATA_CMD {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `cmd`"]
        pub type CMD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `cmd`"]
        pub struct CMD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `data`"]
        pub type DATA_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `data`"]
        pub struct DATA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 8 - CMD"]
            #[inline(always)]
            pub fn cmd(&self) -> CMD_R {
                CMD_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bits 0:7 - Data"]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 8 - CMD"]
            #[inline(always)]
            pub fn cmd(&mut self) -> CMD_W {
                CMD_W { w: self }
            }
            #[doc = "Bits 0:7 - Data"]
            #[inline(always)]
            pub fn data(&mut self) -> DATA_W {
                DATA_W { w: self }
            }
        }
    }
    #[doc = "Standard Speed Clock SCL High Count Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ss_scl_hcnt](ss_scl_hcnt) module"]
    pub type SS_SCL_HCNT = crate::Reg<u32, _SS_SCL_HCNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SS_SCL_HCNT;
    #[doc = "`read()` method returns [ss_scl_hcnt::R](ss_scl_hcnt::R) reader structure"]
    impl crate::Readable for SS_SCL_HCNT {}
    #[doc = "`write(|w| ..)` method takes [ss_scl_hcnt::W](ss_scl_hcnt::W) writer structure"]
    impl crate::Writable for SS_SCL_HCNT {}
    #[doc = "Standard Speed Clock SCL High Count Register"]
    pub mod ss_scl_hcnt {
        #[doc = "Reader of register ss_scl_hcnt"]
        pub type R = crate::R<u32, super::SS_SCL_HCNT>;
        #[doc = "Writer for register ss_scl_hcnt"]
        pub type W = crate::W<u32, super::SS_SCL_HCNT>;
        #[doc = "Register ss_scl_hcnt `reset()`'s with value 0"]
        impl crate::ResetValue for super::SS_SCL_HCNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `count`"]
        pub type COUNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `count`"]
        pub struct COUNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - COUNT"]
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - COUNT"]
            #[inline(always)]
            pub fn count(&mut self) -> COUNT_W {
                COUNT_W { w: self }
            }
        }
    }
    #[doc = "Standard Speed Clock SCL Low Count Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ss_scl_lcnt](ss_scl_lcnt) module"]
    pub type SS_SCL_LCNT = crate::Reg<u32, _SS_SCL_LCNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SS_SCL_LCNT;
    #[doc = "`read()` method returns [ss_scl_lcnt::R](ss_scl_lcnt::R) reader structure"]
    impl crate::Readable for SS_SCL_LCNT {}
    #[doc = "`write(|w| ..)` method takes [ss_scl_lcnt::W](ss_scl_lcnt::W) writer structure"]
    impl crate::Writable for SS_SCL_LCNT {}
    #[doc = "Standard Speed Clock SCL Low Count Register"]
    pub mod ss_scl_lcnt {
        #[doc = "Reader of register ss_scl_lcnt"]
        pub type R = crate::R<u32, super::SS_SCL_LCNT>;
        #[doc = "Writer for register ss_scl_lcnt"]
        pub type W = crate::W<u32, super::SS_SCL_LCNT>;
        #[doc = "Register ss_scl_lcnt `reset()`'s with value 0"]
        impl crate::ResetValue for super::SS_SCL_LCNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `count`"]
        pub type COUNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `count`"]
        pub struct COUNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - COUNT"]
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - COUNT"]
            #[inline(always)]
            pub fn count(&mut self) -> COUNT_W {
                COUNT_W { w: self }
            }
        }
    }
    #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_stat](intr_stat) module"]
    pub type INTR_STAT = crate::Reg<u32, _INTR_STAT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTR_STAT;
    #[doc = "`read()` method returns [intr_stat::R](intr_stat::R) reader structure"]
    impl crate::Readable for INTR_STAT {}
    #[doc = "Interrupt Status Register"]
    pub mod intr_stat {
        #[doc = "Reader of register intr_stat"]
        pub type R = crate::R<u32, super::INTR_STAT>;
        #[doc = "Reader of field `rx_under`"]
        pub type RX_UNDER_R = crate::R<bool, bool>;
        #[doc = "Reader of field `rx_over`"]
        pub type RX_OVER_R = crate::R<bool, bool>;
        #[doc = "Reader of field `rx_full`"]
        pub type RX_FULL_R = crate::R<bool, bool>;
        #[doc = "Reader of field `tx_over`"]
        pub type TX_OVER_R = crate::R<bool, bool>;
        #[doc = "Reader of field `tx_empty`"]
        pub type TX_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `rd_req`"]
        pub type RD_REQ_R = crate::R<bool, bool>;
        #[doc = "Reader of field `tx_abrt`"]
        pub type TX_ABRT_R = crate::R<bool, bool>;
        #[doc = "Reader of field `rx_done`"]
        pub type RX_DONE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `activity`"]
        pub type ACTIVITY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `stop_det`"]
        pub type STOP_DET_R = crate::R<bool, bool>;
        #[doc = "Reader of field `start_det`"]
        pub type START_DET_R = crate::R<bool, bool>;
        #[doc = "Reader of field `gen_call`"]
        pub type GEN_CALL_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline(always)]
            pub fn rx_under(&self) -> RX_UNDER_R {
                RX_UNDER_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline(always)]
            pub fn rx_over(&self) -> RX_OVER_R {
                RX_OVER_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline(always)]
            pub fn rx_full(&self) -> RX_FULL_R {
                RX_FULL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline(always)]
            pub fn tx_over(&self) -> TX_OVER_R {
                TX_OVER_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline(always)]
            pub fn tx_empty(&self) -> TX_EMPTY_R {
                TX_EMPTY_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline(always)]
            pub fn rd_req(&self) -> RD_REQ_R {
                RD_REQ_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline(always)]
            pub fn tx_abrt(&self) -> TX_ABRT_R {
                TX_ABRT_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline(always)]
            pub fn rx_done(&self) -> RX_DONE_R {
                RX_DONE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline(always)]
            pub fn activity(&self) -> ACTIVITY_R {
                ACTIVITY_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline(always)]
            pub fn stop_det(&self) -> STOP_DET_R {
                STOP_DET_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline(always)]
            pub fn start_det(&self) -> START_DET_R {
                START_DET_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline(always)]
            pub fn gen_call(&self) -> GEN_CALL_R {
                GEN_CALL_R::new(((self.bits >> 11) & 0x01) != 0)
            }
        }
    }
    #[doc = "Interrupt Mask Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_mask](intr_mask) module"]
    pub type INTR_MASK = crate::Reg<u32, _INTR_MASK>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTR_MASK;
    #[doc = "`read()` method returns [intr_mask::R](intr_mask::R) reader structure"]
    impl crate::Readable for INTR_MASK {}
    #[doc = "`write(|w| ..)` method takes [intr_mask::W](intr_mask::W) writer structure"]
    impl crate::Writable for INTR_MASK {}
    #[doc = "Interrupt Mask Register"]
    pub mod intr_mask {
        #[doc = "Reader of register intr_mask"]
        pub type R = crate::R<u32, super::INTR_MASK>;
        #[doc = "Writer for register intr_mask"]
        pub type W = crate::W<u32, super::INTR_MASK>;
        #[doc = "Register intr_mask `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTR_MASK {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rx_under`"]
        pub type RX_UNDER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_under`"]
        pub struct RX_UNDER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_UNDER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `rx_over`"]
        pub type RX_OVER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_over`"]
        pub struct RX_OVER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_OVER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `rx_full`"]
        pub type RX_FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_full`"]
        pub struct RX_FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `tx_over`"]
        pub type TX_OVER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_over`"]
        pub struct TX_OVER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_OVER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `tx_empty`"]
        pub type TX_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_empty`"]
        pub struct TX_EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `rd_req`"]
        pub type RD_REQ_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rd_req`"]
        pub struct RD_REQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RD_REQ_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `tx_abrt`"]
        pub type TX_ABRT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_abrt`"]
        pub struct TX_ABRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_ABRT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `rx_done`"]
        pub type RX_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_done`"]
        pub struct RX_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `activity`"]
        pub type ACTIVITY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `activity`"]
        pub struct ACTIVITY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACTIVITY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `stop_det`"]
        pub type STOP_DET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `stop_det`"]
        pub struct STOP_DET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_DET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `start_det`"]
        pub type START_DET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `start_det`"]
        pub struct START_DET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> START_DET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `gen_call`"]
        pub type GEN_CALL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gen_call`"]
        pub struct GEN_CALL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GEN_CALL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline(always)]
            pub fn rx_under(&self) -> RX_UNDER_R {
                RX_UNDER_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline(always)]
            pub fn rx_over(&self) -> RX_OVER_R {
                RX_OVER_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline(always)]
            pub fn rx_full(&self) -> RX_FULL_R {
                RX_FULL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline(always)]
            pub fn tx_over(&self) -> TX_OVER_R {
                TX_OVER_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline(always)]
            pub fn tx_empty(&self) -> TX_EMPTY_R {
                TX_EMPTY_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline(always)]
            pub fn rd_req(&self) -> RD_REQ_R {
                RD_REQ_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline(always)]
            pub fn tx_abrt(&self) -> TX_ABRT_R {
                TX_ABRT_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline(always)]
            pub fn rx_done(&self) -> RX_DONE_R {
                RX_DONE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline(always)]
            pub fn activity(&self) -> ACTIVITY_R {
                ACTIVITY_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline(always)]
            pub fn stop_det(&self) -> STOP_DET_R {
                STOP_DET_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline(always)]
            pub fn start_det(&self) -> START_DET_R {
                START_DET_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline(always)]
            pub fn gen_call(&self) -> GEN_CALL_R {
                GEN_CALL_R::new(((self.bits >> 11) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline(always)]
            pub fn rx_under(&mut self) -> RX_UNDER_W {
                RX_UNDER_W { w: self }
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline(always)]
            pub fn rx_over(&mut self) -> RX_OVER_W {
                RX_OVER_W { w: self }
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline(always)]
            pub fn rx_full(&mut self) -> RX_FULL_W {
                RX_FULL_W { w: self }
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline(always)]
            pub fn tx_over(&mut self) -> TX_OVER_W {
                TX_OVER_W { w: self }
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline(always)]
            pub fn tx_empty(&mut self) -> TX_EMPTY_W {
                TX_EMPTY_W { w: self }
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline(always)]
            pub fn rd_req(&mut self) -> RD_REQ_W {
                RD_REQ_W { w: self }
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline(always)]
            pub fn tx_abrt(&mut self) -> TX_ABRT_W {
                TX_ABRT_W { w: self }
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline(always)]
            pub fn rx_done(&mut self) -> RX_DONE_W {
                RX_DONE_W { w: self }
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline(always)]
            pub fn activity(&mut self) -> ACTIVITY_W {
                ACTIVITY_W { w: self }
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline(always)]
            pub fn stop_det(&mut self) -> STOP_DET_W {
                STOP_DET_W { w: self }
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline(always)]
            pub fn start_det(&mut self) -> START_DET_W {
                START_DET_W { w: self }
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline(always)]
            pub fn gen_call(&mut self) -> GEN_CALL_W {
                GEN_CALL_W { w: self }
            }
        }
    }
    #[doc = "Raw Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [raw_intr_stat](raw_intr_stat) module"]
    pub type RAW_INTR_STAT = crate::Reg<u32, _RAW_INTR_STAT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RAW_INTR_STAT;
    #[doc = "`read()` method returns [raw_intr_stat::R](raw_intr_stat::R) reader structure"]
    impl crate::Readable for RAW_INTR_STAT {}
    #[doc = "`write(|w| ..)` method takes [raw_intr_stat::W](raw_intr_stat::W) writer structure"]
    impl crate::Writable for RAW_INTR_STAT {}
    #[doc = "Raw Interrupt Status Register"]
    pub mod raw_intr_stat {
        #[doc = "Reader of register raw_intr_stat"]
        pub type R = crate::R<u32, super::RAW_INTR_STAT>;
        #[doc = "Writer for register raw_intr_stat"]
        pub type W = crate::W<u32, super::RAW_INTR_STAT>;
        #[doc = "Register raw_intr_stat `reset()`'s with value 0"]
        impl crate::ResetValue for super::RAW_INTR_STAT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rx_under`"]
        pub type RX_UNDER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_under`"]
        pub struct RX_UNDER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_UNDER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `rx_over`"]
        pub type RX_OVER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_over`"]
        pub struct RX_OVER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_OVER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `rx_full`"]
        pub type RX_FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_full`"]
        pub struct RX_FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `tx_over`"]
        pub type TX_OVER_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_over`"]
        pub struct TX_OVER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_OVER_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `tx_empty`"]
        pub type TX_EMPTY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_empty`"]
        pub struct TX_EMPTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_EMPTY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `rd_req`"]
        pub type RD_REQ_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rd_req`"]
        pub struct RD_REQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RD_REQ_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `tx_abrt`"]
        pub type TX_ABRT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_abrt`"]
        pub struct TX_ABRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_ABRT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `rx_done`"]
        pub type RX_DONE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rx_done`"]
        pub struct RX_DONE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_DONE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `activity`"]
        pub type ACTIVITY_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `activity`"]
        pub struct ACTIVITY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACTIVITY_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `stop_det`"]
        pub type STOP_DET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `stop_det`"]
        pub struct STOP_DET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_DET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `start_det`"]
        pub type START_DET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `start_det`"]
        pub struct START_DET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> START_DET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `gen_call`"]
        pub type GEN_CALL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gen_call`"]
        pub struct GEN_CALL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GEN_CALL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline(always)]
            pub fn rx_under(&self) -> RX_UNDER_R {
                RX_UNDER_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline(always)]
            pub fn rx_over(&self) -> RX_OVER_R {
                RX_OVER_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline(always)]
            pub fn rx_full(&self) -> RX_FULL_R {
                RX_FULL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline(always)]
            pub fn tx_over(&self) -> TX_OVER_R {
                TX_OVER_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline(always)]
            pub fn tx_empty(&self) -> TX_EMPTY_R {
                TX_EMPTY_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline(always)]
            pub fn rd_req(&self) -> RD_REQ_R {
                RD_REQ_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline(always)]
            pub fn tx_abrt(&self) -> TX_ABRT_R {
                TX_ABRT_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline(always)]
            pub fn rx_done(&self) -> RX_DONE_R {
                RX_DONE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline(always)]
            pub fn activity(&self) -> ACTIVITY_R {
                ACTIVITY_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline(always)]
            pub fn stop_det(&self) -> STOP_DET_R {
                STOP_DET_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline(always)]
            pub fn start_det(&self) -> START_DET_R {
                START_DET_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline(always)]
            pub fn gen_call(&self) -> GEN_CALL_R {
                GEN_CALL_R::new(((self.bits >> 11) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RX_UNDER"]
            #[inline(always)]
            pub fn rx_under(&mut self) -> RX_UNDER_W {
                RX_UNDER_W { w: self }
            }
            #[doc = "Bit 1 - RX_OVER"]
            #[inline(always)]
            pub fn rx_over(&mut self) -> RX_OVER_W {
                RX_OVER_W { w: self }
            }
            #[doc = "Bit 2 - RX_FULL"]
            #[inline(always)]
            pub fn rx_full(&mut self) -> RX_FULL_W {
                RX_FULL_W { w: self }
            }
            #[doc = "Bit 3 - TX_OVER"]
            #[inline(always)]
            pub fn tx_over(&mut self) -> TX_OVER_W {
                TX_OVER_W { w: self }
            }
            #[doc = "Bit 4 - TX_EMPTY"]
            #[inline(always)]
            pub fn tx_empty(&mut self) -> TX_EMPTY_W {
                TX_EMPTY_W { w: self }
            }
            #[doc = "Bit 5 - RD_REQ"]
            #[inline(always)]
            pub fn rd_req(&mut self) -> RD_REQ_W {
                RD_REQ_W { w: self }
            }
            #[doc = "Bit 6 - TX_ABRT"]
            #[inline(always)]
            pub fn tx_abrt(&mut self) -> TX_ABRT_W {
                TX_ABRT_W { w: self }
            }
            #[doc = "Bit 7 - RX_DONE"]
            #[inline(always)]
            pub fn rx_done(&mut self) -> RX_DONE_W {
                RX_DONE_W { w: self }
            }
            #[doc = "Bit 8 - ACTIVITY"]
            #[inline(always)]
            pub fn activity(&mut self) -> ACTIVITY_W {
                ACTIVITY_W { w: self }
            }
            #[doc = "Bit 9 - STOP_DET"]
            #[inline(always)]
            pub fn stop_det(&mut self) -> STOP_DET_W {
                STOP_DET_W { w: self }
            }
            #[doc = "Bit 10 - START_DET"]
            #[inline(always)]
            pub fn start_det(&mut self) -> START_DET_W {
                START_DET_W { w: self }
            }
            #[doc = "Bit 11 - GEN_CALL"]
            #[inline(always)]
            pub fn gen_call(&mut self) -> GEN_CALL_W {
                GEN_CALL_W { w: self }
            }
        }
    }
    #[doc = "Receive FIFO Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rx_tl](rx_tl) module"]
    pub type RX_TL = crate::Reg<u32, _RX_TL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RX_TL;
    #[doc = "`read()` method returns [rx_tl::R](rx_tl::R) reader structure"]
    impl crate::Readable for RX_TL {}
    #[doc = "`write(|w| ..)` method takes [rx_tl::W](rx_tl::W) writer structure"]
    impl crate::Writable for RX_TL {}
    #[doc = "Receive FIFO Threshold Register"]
    pub mod rx_tl {
        #[doc = "Reader of register rx_tl"]
        pub type R = crate::R<u32, super::RX_TL>;
        #[doc = "Writer for register rx_tl"]
        pub type W = crate::W<u32, super::RX_TL>;
        #[doc = "Register rx_tl `reset()`'s with value 0"]
        impl crate::ResetValue for super::RX_TL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "Transmit FIFO Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tx_tl](tx_tl) module"]
    pub type TX_TL = crate::Reg<u32, _TX_TL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TX_TL;
    #[doc = "`read()` method returns [tx_tl::R](tx_tl::R) reader structure"]
    impl crate::Readable for TX_TL {}
    #[doc = "`write(|w| ..)` method takes [tx_tl::W](tx_tl::W) writer structure"]
    impl crate::Writable for TX_TL {}
    #[doc = "Transmit FIFO Threshold Register"]
    pub mod tx_tl {
        #[doc = "Reader of register tx_tl"]
        pub type R = crate::R<u32, super::TX_TL>;
        #[doc = "Writer for register tx_tl"]
        pub type W = crate::W<u32, super::TX_TL>;
        #[doc = "Register tx_tl `reset()`'s with value 0"]
        impl crate::ResetValue for super::TX_TL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "Clear Combined and Individual Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_intr](clr_intr) module"]
    pub type CLR_INTR = crate::Reg<u32, _CLR_INTR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_INTR;
    #[doc = "`read()` method returns [clr_intr::R](clr_intr::R) reader structure"]
    impl crate::Readable for CLR_INTR {}
    #[doc = "Clear Combined and Individual Interrupt Register"]
    pub mod clr_intr {
        #[doc = "Reader of register clr_intr"]
        pub type R = crate::R<u32, super::CLR_INTR>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear RX_UNDER Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_rx_under](clr_rx_under) module"]
    pub type CLR_RX_UNDER = crate::Reg<u32, _CLR_RX_UNDER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_RX_UNDER;
    #[doc = "`read()` method returns [clr_rx_under::R](clr_rx_under::R) reader structure"]
    impl crate::Readable for CLR_RX_UNDER {}
    #[doc = "Clear RX_UNDER Interrupt Register"]
    pub mod clr_rx_under {
        #[doc = "Reader of register clr_rx_under"]
        pub type R = crate::R<u32, super::CLR_RX_UNDER>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear RX_OVER Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_rx_over](clr_rx_over) module"]
    pub type CLR_RX_OVER = crate::Reg<u32, _CLR_RX_OVER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_RX_OVER;
    #[doc = "`read()` method returns [clr_rx_over::R](clr_rx_over::R) reader structure"]
    impl crate::Readable for CLR_RX_OVER {}
    #[doc = "Clear RX_OVER Interrupt Register"]
    pub mod clr_rx_over {
        #[doc = "Reader of register clr_rx_over"]
        pub type R = crate::R<u32, super::CLR_RX_OVER>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear TX_OVER Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_tx_over](clr_tx_over) module"]
    pub type CLR_TX_OVER = crate::Reg<u32, _CLR_TX_OVER>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_TX_OVER;
    #[doc = "`read()` method returns [clr_tx_over::R](clr_tx_over::R) reader structure"]
    impl crate::Readable for CLR_TX_OVER {}
    #[doc = "Clear TX_OVER Interrupt Register"]
    pub mod clr_tx_over {
        #[doc = "Reader of register clr_tx_over"]
        pub type R = crate::R<u32, super::CLR_TX_OVER>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear RD_REQ Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_rd_req](clr_rd_req) module"]
    pub type CLR_RD_REQ = crate::Reg<u32, _CLR_RD_REQ>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_RD_REQ;
    #[doc = "`read()` method returns [clr_rd_req::R](clr_rd_req::R) reader structure"]
    impl crate::Readable for CLR_RD_REQ {}
    #[doc = "Clear RD_REQ Interrupt Register"]
    pub mod clr_rd_req {
        #[doc = "Reader of register clr_rd_req"]
        pub type R = crate::R<u32, super::CLR_RD_REQ>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear TX_ABRT Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_tx_abrt](clr_tx_abrt) module"]
    pub type CLR_TX_ABRT = crate::Reg<u32, _CLR_TX_ABRT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_TX_ABRT;
    #[doc = "`read()` method returns [clr_tx_abrt::R](clr_tx_abrt::R) reader structure"]
    impl crate::Readable for CLR_TX_ABRT {}
    #[doc = "Clear TX_ABRT Interrupt Register"]
    pub mod clr_tx_abrt {
        #[doc = "Reader of register clr_tx_abrt"]
        pub type R = crate::R<u32, super::CLR_TX_ABRT>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear RX_DONE Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_rx_done](clr_rx_done) module"]
    pub type CLR_RX_DONE = crate::Reg<u32, _CLR_RX_DONE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_RX_DONE;
    #[doc = "`read()` method returns [clr_rx_done::R](clr_rx_done::R) reader structure"]
    impl crate::Readable for CLR_RX_DONE {}
    #[doc = "Clear RX_DONE Interrupt Register"]
    pub mod clr_rx_done {
        #[doc = "Reader of register clr_rx_done"]
        pub type R = crate::R<u32, super::CLR_RX_DONE>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear ACTIVITY Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_activity](clr_activity) module"]
    pub type CLR_ACTIVITY = crate::Reg<u32, _CLR_ACTIVITY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_ACTIVITY;
    #[doc = "`read()` method returns [clr_activity::R](clr_activity::R) reader structure"]
    impl crate::Readable for CLR_ACTIVITY {}
    #[doc = "Clear ACTIVITY Interrupt Register"]
    pub mod clr_activity {
        #[doc = "Reader of register clr_activity"]
        pub type R = crate::R<u32, super::CLR_ACTIVITY>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear STOP_DET Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_stop_det](clr_stop_det) module"]
    pub type CLR_STOP_DET = crate::Reg<u32, _CLR_STOP_DET>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_STOP_DET;
    #[doc = "`read()` method returns [clr_stop_det::R](clr_stop_det::R) reader structure"]
    impl crate::Readable for CLR_STOP_DET {}
    #[doc = "Clear STOP_DET Interrupt Register"]
    pub mod clr_stop_det {
        #[doc = "Reader of register clr_stop_det"]
        pub type R = crate::R<u32, super::CLR_STOP_DET>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Clear START_DET Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_start_det](clr_start_det) module"]
    pub type CLR_START_DET = crate::Reg<u32, _CLR_START_DET>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_START_DET;
    #[doc = "`read()` method returns [clr_start_det::R](clr_start_det::R) reader structure"]
    impl crate::Readable for CLR_START_DET {}
    #[doc = "Clear START_DET Interrupt Register"]
    pub mod clr_start_det {
        #[doc = "Reader of register clr_start_det"]
        pub type R = crate::R<u32, super::CLR_START_DET>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "I2C Clear GEN_CALL Interrupt Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clr_gen_call](clr_gen_call) module"]
    pub type CLR_GEN_CALL = crate::Reg<u32, _CLR_GEN_CALL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLR_GEN_CALL;
    #[doc = "`read()` method returns [clr_gen_call::R](clr_gen_call::R) reader structure"]
    impl crate::Readable for CLR_GEN_CALL {}
    #[doc = "I2C Clear GEN_CALL Interrupt Register"]
    pub mod clr_gen_call {
        #[doc = "Reader of register clr_gen_call"]
        pub type R = crate::R<u32, super::CLR_GEN_CALL>;
        #[doc = "Reader of field `clr`"]
        pub type CLR_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - CLR"]
            #[inline(always)]
            pub fn clr(&self) -> CLR_R {
                CLR_R::new((self.bits & 0x01) != 0)
            }
        }
    }
    #[doc = "Enable Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [enable](enable) module"]
    pub type ENABLE = crate::Reg<u32, _ENABLE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ENABLE;
    #[doc = "`read()` method returns [enable::R](enable::R) reader structure"]
    impl crate::Readable for ENABLE {}
    #[doc = "`write(|w| ..)` method takes [enable::W](enable::W) writer structure"]
    impl crate::Writable for ENABLE {}
    #[doc = "Enable Register"]
    pub mod enable {
        #[doc = "Reader of register enable"]
        pub type R = crate::R<u32, super::ENABLE>;
        #[doc = "Writer for register enable"]
        pub type W = crate::W<u32, super::ENABLE>;
        #[doc = "Register enable `reset()`'s with value 0"]
        impl crate::ResetValue for super::ENABLE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `enable`"]
        pub type ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `enable`"]
        pub struct ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `abort`"]
        pub type ABORT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `abort`"]
        pub struct ABORT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ABORT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `tx_cmd_block`"]
        pub type TX_CMD_BLOCK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tx_cmd_block`"]
        pub struct TX_CMD_BLOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_CMD_BLOCK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - ENABLE"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - ABORT"]
            #[inline(always)]
            pub fn abort(&self) -> ABORT_R {
                ABORT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - TX_CMD_BLOCK"]
            #[inline(always)]
            pub fn tx_cmd_block(&self) -> TX_CMD_BLOCK_R {
                TX_CMD_BLOCK_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - ENABLE"]
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W {
                ENABLE_W { w: self }
            }
            #[doc = "Bit 1 - ABORT"]
            #[inline(always)]
            pub fn abort(&mut self) -> ABORT_W {
                ABORT_W { w: self }
            }
            #[doc = "Bit 2 - TX_CMD_BLOCK"]
            #[inline(always)]
            pub fn tx_cmd_block(&mut self) -> TX_CMD_BLOCK_W {
                TX_CMD_BLOCK_W { w: self }
            }
        }
    }
    #[doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [status](status) module"]
    pub type STATUS = crate::Reg<u32, _STATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _STATUS;
    #[doc = "`read()` method returns [status::R](status::R) reader structure"]
    impl crate::Readable for STATUS {}
    #[doc = "Status Register"]
    pub mod status {
        #[doc = "Reader of register status"]
        pub type R = crate::R<u32, super::STATUS>;
        #[doc = "Reader of field `activity`"]
        pub type ACTIVITY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `tfnf`"]
        pub type TFNF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `tfe`"]
        pub type TFE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `rfne`"]
        pub type RFNE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `rff`"]
        pub type RFF_R = crate::R<bool, bool>;
        #[doc = "Reader of field `mst_activity`"]
        pub type MST_ACTIVITY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `slv_activity`"]
        pub type SLV_ACTIVITY_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - ACTIVITY"]
            #[inline(always)]
            pub fn activity(&self) -> ACTIVITY_R {
                ACTIVITY_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - TFNF"]
            #[inline(always)]
            pub fn tfnf(&self) -> TFNF_R {
                TFNF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - TFE"]
            #[inline(always)]
            pub fn tfe(&self) -> TFE_R {
                TFE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - RFNE"]
            #[inline(always)]
            pub fn rfne(&self) -> RFNE_R {
                RFNE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - RFF"]
            #[inline(always)]
            pub fn rff(&self) -> RFF_R {
                RFF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - MST_ACTIVITY"]
            #[inline(always)]
            pub fn mst_activity(&self) -> MST_ACTIVITY_R {
                MST_ACTIVITY_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - SLV_ACTIVITY"]
            #[inline(always)]
            pub fn slv_activity(&self) -> SLV_ACTIVITY_R {
                SLV_ACTIVITY_R::new(((self.bits >> 6) & 0x01) != 0)
            }
        }
    }
    #[doc = "Transmit FIFO Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [txflr](txflr) module"]
    pub type TXFLR = crate::Reg<u32, _TXFLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TXFLR;
    #[doc = "`read()` method returns [txflr::R](txflr::R) reader structure"]
    impl crate::Readable for TXFLR {}
    #[doc = "`write(|w| ..)` method takes [txflr::W](txflr::W) writer structure"]
    impl crate::Writable for TXFLR {}
    #[doc = "Transmit FIFO Level Register"]
    pub mod txflr {
        #[doc = "Reader of register txflr"]
        pub type R = crate::R<u32, super::TXFLR>;
        #[doc = "Writer for register txflr"]
        pub type W = crate::W<u32, super::TXFLR>;
        #[doc = "Register txflr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TXFLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "Receive FIFO Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rxflr](rxflr) module"]
    pub type RXFLR = crate::Reg<u32, _RXFLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RXFLR;
    #[doc = "`read()` method returns [rxflr::R](rxflr::R) reader structure"]
    impl crate::Readable for RXFLR {}
    #[doc = "`write(|w| ..)` method takes [rxflr::W](rxflr::W) writer structure"]
    impl crate::Writable for RXFLR {}
    #[doc = "Receive FIFO Level Register"]
    pub mod rxflr {
        #[doc = "Reader of register rxflr"]
        pub type R = crate::R<u32, super::RXFLR>;
        #[doc = "Writer for register rxflr"]
        pub type W = crate::W<u32, super::RXFLR>;
        #[doc = "Register rxflr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RXFLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "SDA Hold Time Length Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sda_hold](sda_hold) module"]
    pub type SDA_HOLD = crate::Reg<u32, _SDA_HOLD>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SDA_HOLD;
    #[doc = "`read()` method returns [sda_hold::R](sda_hold::R) reader structure"]
    impl crate::Readable for SDA_HOLD {}
    #[doc = "`write(|w| ..)` method takes [sda_hold::W](sda_hold::W) writer structure"]
    impl crate::Writable for SDA_HOLD {}
    #[doc = "SDA Hold Time Length Register"]
    pub mod sda_hold {
        #[doc = "Reader of register sda_hold"]
        pub type R = crate::R<u32, super::SDA_HOLD>;
        #[doc = "Writer for register sda_hold"]
        pub type W = crate::W<u32, super::SDA_HOLD>;
        #[doc = "Register sda_hold `reset()`'s with value 0"]
        impl crate::ResetValue for super::SDA_HOLD {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `tx`"]
        pub type TX_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `tx`"]
        pub struct TX_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TX_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `rx`"]
        pub type RX_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `rx`"]
        pub struct RX_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RX_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - TX"]
            #[inline(always)]
            pub fn tx(&self) -> TX_R {
                TX_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:23 - RX"]
            #[inline(always)]
            pub fn rx(&self) -> RX_R {
                RX_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - TX"]
            #[inline(always)]
            pub fn tx(&mut self) -> TX_W {
                TX_W { w: self }
            }
            #[doc = "Bits 16:23 - RX"]
            #[inline(always)]
            pub fn rx(&mut self) -> RX_W {
                RX_W { w: self }
            }
        }
    }
    #[doc = "Transmit Abort Source Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tx_abrt_source](tx_abrt_source) module"]
    pub type TX_ABRT_SOURCE = crate::Reg<u32, _TX_ABRT_SOURCE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TX_ABRT_SOURCE;
    #[doc = "`read()` method returns [tx_abrt_source::R](tx_abrt_source::R) reader structure"]
    impl crate::Readable for TX_ABRT_SOURCE {}
    #[doc = "`write(|w| ..)` method takes [tx_abrt_source::W](tx_abrt_source::W) writer structure"]
    impl crate::Writable for TX_ABRT_SOURCE {}
    #[doc = "Transmit Abort Source Register"]
    pub mod tx_abrt_source {
        #[doc = "Reader of register tx_abrt_source"]
        pub type R = crate::R<u32, super::TX_ABRT_SOURCE>;
        #[doc = "Writer for register tx_abrt_source"]
        pub type W = crate::W<u32, super::TX_ABRT_SOURCE>;
        #[doc = "Register tx_abrt_source `reset()`'s with value 0"]
        impl crate::ResetValue for super::TX_ABRT_SOURCE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `addr7_noack`"]
        pub type ADDR7_NOACK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `addr7_noack`"]
        pub struct ADDR7_NOACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDR7_NOACK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `addr1_10_noack`"]
        pub type ADDR1_10_NOACK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `addr1_10_noack`"]
        pub struct ADDR1_10_NOACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDR1_10_NOACK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `addr2_10_noack`"]
        pub type ADDR2_10_NOACK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `addr2_10_noack`"]
        pub struct ADDR2_10_NOACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDR2_10_NOACK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `txdata_noack`"]
        pub type TXDATA_NOACK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `txdata_noack`"]
        pub struct TXDATA_NOACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXDATA_NOACK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `gcall_noack`"]
        pub type GCALL_NOACK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gcall_noack`"]
        pub struct GCALL_NOACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GCALL_NOACK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `gcall_read`"]
        pub type GCALL_READ_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gcall_read`"]
        pub struct GCALL_READ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GCALL_READ_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `hs_ackdet`"]
        pub type HS_ACKDET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `hs_ackdet`"]
        pub struct HS_ACKDET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HS_ACKDET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `sbyte_ackdet`"]
        pub type SBYTE_ACKDET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sbyte_ackdet`"]
        pub struct SBYTE_ACKDET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBYTE_ACKDET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `hs_norstrt`"]
        pub type HS_NORSTRT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `hs_norstrt`"]
        pub struct HS_NORSTRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HS_NORSTRT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `sbyte_norstrt`"]
        pub type SBYTE_NORSTRT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sbyte_norstrt`"]
        pub struct SBYTE_NORSTRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBYTE_NORSTRT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `rd_10_norstrt`"]
        pub type RD_10_NORSTRT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rd_10_norstrt`"]
        pub struct RD_10_NORSTRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RD_10_NORSTRT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `master_dis`"]
        pub type MASTER_DIS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `master_dis`"]
        pub struct MASTER_DIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MASTER_DIS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `mst_arblost`"]
        pub type MST_ARBLOST_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `mst_arblost`"]
        pub struct MST_ARBLOST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MST_ARBLOST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `slvflush_txfifo`"]
        pub type SLVFLUSH_TXFIFO_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvflush_txfifo`"]
        pub struct SLVFLUSH_TXFIFO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVFLUSH_TXFIFO_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `slv_arblost`"]
        pub type SLV_ARBLOST_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slv_arblost`"]
        pub struct SLV_ARBLOST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLV_ARBLOST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `slvrd_intx`"]
        pub type SLVRD_INTX_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `slvrd_intx`"]
        pub struct SLVRD_INTX_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SLVRD_INTX_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `user_abrt`"]
        pub type USER_ABRT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `user_abrt`"]
        pub struct USER_ABRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USER_ABRT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - 7B_ADDR_NOACK"]
            #[inline(always)]
            pub fn addr7_noack(&self) -> ADDR7_NOACK_R {
                ADDR7_NOACK_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - 10B_ADDR1_NOACK"]
            #[inline(always)]
            pub fn addr1_10_noack(&self) -> ADDR1_10_NOACK_R {
                ADDR1_10_NOACK_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - 10B_ADDR2_NOACK"]
            #[inline(always)]
            pub fn addr2_10_noack(&self) -> ADDR2_10_NOACK_R {
                ADDR2_10_NOACK_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - TXDATA_NOACK"]
            #[inline(always)]
            pub fn txdata_noack(&self) -> TXDATA_NOACK_R {
                TXDATA_NOACK_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - GCALL_NOACK"]
            #[inline(always)]
            pub fn gcall_noack(&self) -> GCALL_NOACK_R {
                GCALL_NOACK_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - GCALL_READ"]
            #[inline(always)]
            pub fn gcall_read(&self) -> GCALL_READ_R {
                GCALL_READ_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - HS_ACKDET"]
            #[inline(always)]
            pub fn hs_ackdet(&self) -> HS_ACKDET_R {
                HS_ACKDET_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - SBYTE_ACKDET"]
            #[inline(always)]
            pub fn sbyte_ackdet(&self) -> SBYTE_ACKDET_R {
                SBYTE_ACKDET_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8 - HS_NORSTRT"]
            #[inline(always)]
            pub fn hs_norstrt(&self) -> HS_NORSTRT_R {
                HS_NORSTRT_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - SBYTE_NORSTRT"]
            #[inline(always)]
            pub fn sbyte_norstrt(&self) -> SBYTE_NORSTRT_R {
                SBYTE_NORSTRT_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10 - 10B_RD_NORSTRT"]
            #[inline(always)]
            pub fn rd_10_norstrt(&self) -> RD_10_NORSTRT_R {
                RD_10_NORSTRT_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11 - MASTER_DIS"]
            #[inline(always)]
            pub fn master_dis(&self) -> MASTER_DIS_R {
                MASTER_DIS_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12 - MST_ARBLOST"]
            #[inline(always)]
            pub fn mst_arblost(&self) -> MST_ARBLOST_R {
                MST_ARBLOST_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - SLVFLUSH_TXFIFO"]
            #[inline(always)]
            pub fn slvflush_txfifo(&self) -> SLVFLUSH_TXFIFO_R {
                SLVFLUSH_TXFIFO_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - SLV_ARBLOST"]
            #[inline(always)]
            pub fn slv_arblost(&self) -> SLV_ARBLOST_R {
                SLV_ARBLOST_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - SLVRD_INTX"]
            #[inline(always)]
            pub fn slvrd_intx(&self) -> SLVRD_INTX_R {
                SLVRD_INTX_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - USER_ABRT"]
            #[inline(always)]
            pub fn user_abrt(&self) -> USER_ABRT_R {
                USER_ABRT_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - 7B_ADDR_NOACK"]
            #[inline(always)]
            pub fn addr7_noack(&mut self) -> ADDR7_NOACK_W {
                ADDR7_NOACK_W { w: self }
            }
            #[doc = "Bit 1 - 10B_ADDR1_NOACK"]
            #[inline(always)]
            pub fn addr1_10_noack(&mut self) -> ADDR1_10_NOACK_W {
                ADDR1_10_NOACK_W { w: self }
            }
            #[doc = "Bit 2 - 10B_ADDR2_NOACK"]
            #[inline(always)]
            pub fn addr2_10_noack(&mut self) -> ADDR2_10_NOACK_W {
                ADDR2_10_NOACK_W { w: self }
            }
            #[doc = "Bit 3 - TXDATA_NOACK"]
            #[inline(always)]
            pub fn txdata_noack(&mut self) -> TXDATA_NOACK_W {
                TXDATA_NOACK_W { w: self }
            }
            #[doc = "Bit 4 - GCALL_NOACK"]
            #[inline(always)]
            pub fn gcall_noack(&mut self) -> GCALL_NOACK_W {
                GCALL_NOACK_W { w: self }
            }
            #[doc = "Bit 5 - GCALL_READ"]
            #[inline(always)]
            pub fn gcall_read(&mut self) -> GCALL_READ_W {
                GCALL_READ_W { w: self }
            }
            #[doc = "Bit 6 - HS_ACKDET"]
            #[inline(always)]
            pub fn hs_ackdet(&mut self) -> HS_ACKDET_W {
                HS_ACKDET_W { w: self }
            }
            #[doc = "Bit 7 - SBYTE_ACKDET"]
            #[inline(always)]
            pub fn sbyte_ackdet(&mut self) -> SBYTE_ACKDET_W {
                SBYTE_ACKDET_W { w: self }
            }
            #[doc = "Bit 8 - HS_NORSTRT"]
            #[inline(always)]
            pub fn hs_norstrt(&mut self) -> HS_NORSTRT_W {
                HS_NORSTRT_W { w: self }
            }
            #[doc = "Bit 9 - SBYTE_NORSTRT"]
            #[inline(always)]
            pub fn sbyte_norstrt(&mut self) -> SBYTE_NORSTRT_W {
                SBYTE_NORSTRT_W { w: self }
            }
            #[doc = "Bit 10 - 10B_RD_NORSTRT"]
            #[inline(always)]
            pub fn rd_10_norstrt(&mut self) -> RD_10_NORSTRT_W {
                RD_10_NORSTRT_W { w: self }
            }
            #[doc = "Bit 11 - MASTER_DIS"]
            #[inline(always)]
            pub fn master_dis(&mut self) -> MASTER_DIS_W {
                MASTER_DIS_W { w: self }
            }
            #[doc = "Bit 12 - MST_ARBLOST"]
            #[inline(always)]
            pub fn mst_arblost(&mut self) -> MST_ARBLOST_W {
                MST_ARBLOST_W { w: self }
            }
            #[doc = "Bit 13 - SLVFLUSH_TXFIFO"]
            #[inline(always)]
            pub fn slvflush_txfifo(&mut self) -> SLVFLUSH_TXFIFO_W {
                SLVFLUSH_TXFIFO_W { w: self }
            }
            #[doc = "Bit 14 - SLV_ARBLOST"]
            #[inline(always)]
            pub fn slv_arblost(&mut self) -> SLV_ARBLOST_W {
                SLV_ARBLOST_W { w: self }
            }
            #[doc = "Bit 15 - SLVRD_INTX"]
            #[inline(always)]
            pub fn slvrd_intx(&mut self) -> SLVRD_INTX_W {
                SLVRD_INTX_W { w: self }
            }
            #[doc = "Bit 16 - USER_ABRT"]
            #[inline(always)]
            pub fn user_abrt(&mut self) -> USER_ABRT_W {
                USER_ABRT_W { w: self }
            }
        }
    }
    #[doc = "I2C DMA Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dma_cr](dma_cr) module"]
    pub type DMA_CR = crate::Reg<u32, _DMA_CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMA_CR;
    #[doc = "`read()` method returns [dma_cr::R](dma_cr::R) reader structure"]
    impl crate::Readable for DMA_CR {}
    #[doc = "`write(|w| ..)` method takes [dma_cr::W](dma_cr::W) writer structure"]
    impl crate::Writable for DMA_CR {}
    #[doc = "I2C DMA Control Register"]
    pub mod dma_cr {
        #[doc = "Reader of register dma_cr"]
        pub type R = crate::R<u32, super::DMA_CR>;
        #[doc = "Writer for register dma_cr"]
        pub type W = crate::W<u32, super::DMA_CR>;
        #[doc = "Register dma_cr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMA_CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `RDMAE`"]
        pub type RDMAE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `RDMAE`"]
        pub struct RDMAE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RDMAE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `TDMAE`"]
        pub type TDMAE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `TDMAE`"]
        pub struct TDMAE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDMAE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - RDMAE"]
            #[inline(always)]
            pub fn rdmae(&self) -> RDMAE_R {
                RDMAE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - TDMAE"]
            #[inline(always)]
            pub fn tdmae(&self) -> TDMAE_R {
                TDMAE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RDMAE"]
            #[inline(always)]
            pub fn rdmae(&mut self) -> RDMAE_W {
                RDMAE_W { w: self }
            }
            #[doc = "Bit 1 - TDMAE"]
            #[inline(always)]
            pub fn tdmae(&mut self) -> TDMAE_W {
                TDMAE_W { w: self }
            }
        }
    }
    #[doc = "DMA Transmit Data Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dma_tdlr](dma_tdlr) module"]
    pub type DMA_TDLR = crate::Reg<u32, _DMA_TDLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMA_TDLR;
    #[doc = "`read()` method returns [dma_tdlr::R](dma_tdlr::R) reader structure"]
    impl crate::Readable for DMA_TDLR {}
    #[doc = "`write(|w| ..)` method takes [dma_tdlr::W](dma_tdlr::W) writer structure"]
    impl crate::Writable for DMA_TDLR {}
    #[doc = "DMA Transmit Data Level Register"]
    pub mod dma_tdlr {
        #[doc = "Reader of register dma_tdlr"]
        pub type R = crate::R<u32, super::DMA_TDLR>;
        #[doc = "Writer for register dma_tdlr"]
        pub type W = crate::W<u32, super::DMA_TDLR>;
        #[doc = "Register dma_tdlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMA_TDLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "DMA Receive Data Level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dma_rdlr](dma_rdlr) module"]
    pub type DMA_RDLR = crate::Reg<u32, _DMA_RDLR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMA_RDLR;
    #[doc = "`read()` method returns [dma_rdlr::R](dma_rdlr::R) reader structure"]
    impl crate::Readable for DMA_RDLR {}
    #[doc = "`write(|w| ..)` method takes [dma_rdlr::W](dma_rdlr::W) writer structure"]
    impl crate::Writable for DMA_RDLR {}
    #[doc = "DMA Receive Data Level Register"]
    pub mod dma_rdlr {
        #[doc = "Reader of register dma_rdlr"]
        pub type R = crate::R<u32, super::DMA_RDLR>;
        #[doc = "Writer for register dma_rdlr"]
        pub type W = crate::W<u32, super::DMA_RDLR>;
        #[doc = "Register dma_rdlr `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMA_RDLR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "SDA Setup Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sda_setup](sda_setup) module"]
    pub type SDA_SETUP = crate::Reg<u32, _SDA_SETUP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SDA_SETUP;
    #[doc = "`read()` method returns [sda_setup::R](sda_setup::R) reader structure"]
    impl crate::Readable for SDA_SETUP {}
    #[doc = "`write(|w| ..)` method takes [sda_setup::W](sda_setup::W) writer structure"]
    impl crate::Writable for SDA_SETUP {}
    #[doc = "SDA Setup Register"]
    pub mod sda_setup {
        #[doc = "Reader of register sda_setup"]
        pub type R = crate::R<u32, super::SDA_SETUP>;
        #[doc = "Writer for register sda_setup"]
        pub type W = crate::W<u32, super::SDA_SETUP>;
        #[doc = "Register sda_setup `reset()`'s with value 0"]
        impl crate::ResetValue for super::SDA_SETUP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "ACK General Call Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [general_call](general_call) module"]
    pub type GENERAL_CALL = crate::Reg<u32, _GENERAL_CALL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _GENERAL_CALL;
    #[doc = "`read()` method returns [general_call::R](general_call::R) reader structure"]
    impl crate::Readable for GENERAL_CALL {}
    #[doc = "`write(|w| ..)` method takes [general_call::W](general_call::W) writer structure"]
    impl crate::Writable for GENERAL_CALL {}
    #[doc = "ACK General Call Register"]
    pub mod general_call {
        #[doc = "Reader of register general_call"]
        pub type R = crate::R<u32, super::GENERAL_CALL>;
        #[doc = "Writer for register general_call"]
        pub type W = crate::W<u32, super::GENERAL_CALL>;
        #[doc = "Register general_call `reset()`'s with value 0"]
        impl crate::ResetValue for super::GENERAL_CALL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `call_enable`"]
        pub type CALL_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `call_enable`"]
        pub struct CALL_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CALL_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - CALL_ENABLE"]
            #[inline(always)]
            pub fn call_enable(&self) -> CALL_ENABLE_R {
                CALL_ENABLE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - CALL_ENABLE"]
            #[inline(always)]
            pub fn call_enable(&mut self) -> CALL_ENABLE_W {
                CALL_ENABLE_W { w: self }
            }
        }
    }
    #[doc = "Enable Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [enable_status](enable_status) module"]
    pub type ENABLE_STATUS = crate::Reg<u32, _ENABLE_STATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ENABLE_STATUS;
    #[doc = "`read()` method returns [enable_status::R](enable_status::R) reader structure"]
    impl crate::Readable for ENABLE_STATUS {}
    #[doc = "Enable Status Register"]
    pub mod enable_status {
        #[doc = "Reader of register enable_status"]
        pub type R = crate::R<u32, super::ENABLE_STATUS>;
        #[doc = "Reader of field `ic_enable`"]
        pub type IC_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Reader of field `slv_dis_busy`"]
        pub type SLV_DIS_BUSY_R = crate::R<bool, bool>;
        #[doc = "Reader of field `slv_rx_data_lost`"]
        pub type SLV_RX_DATA_LOST_R = crate::R<bool, bool>;
        impl R {
            #[doc = "Bit 0 - IC_ENABLE"]
            #[inline(always)]
            pub fn ic_enable(&self) -> IC_ENABLE_R {
                IC_ENABLE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - SLV_DIS_BUSY"]
            #[inline(always)]
            pub fn slv_dis_busy(&self) -> SLV_DIS_BUSY_R {
                SLV_DIS_BUSY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - SLV_RX_DATA_LOST"]
            #[inline(always)]
            pub fn slv_rx_data_lost(&self) -> SLV_RX_DATA_LOST_R {
                SLV_RX_DATA_LOST_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
    }
    #[doc = "SS, FS or FM+ spike suppression limit\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [fs_spklen](fs_spklen) module"]
    pub type FS_SPKLEN = crate::Reg<u32, _FS_SPKLEN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FS_SPKLEN;
    #[doc = "`read()` method returns [fs_spklen::R](fs_spklen::R) reader structure"]
    impl crate::Readable for FS_SPKLEN {}
    #[doc = "`write(|w| ..)` method takes [fs_spklen::W](fs_spklen::W) writer structure"]
    impl crate::Writable for FS_SPKLEN {}
    #[doc = "SS, FS or FM+ spike suppression limit"]
    pub mod fs_spklen {
        #[doc = "Reader of register fs_spklen"]
        pub type R = crate::R<u32, super::FS_SPKLEN>;
        #[doc = "Writer for register fs_spklen"]
        pub type W = crate::W<u32, super::FS_SPKLEN>;
        #[doc = "Register fs_spklen `reset()`'s with value 0"]
        impl crate::ResetValue for super::FS_SPKLEN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `value`"]
        pub struct VALUE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> VALUE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - VALUE"]
            #[inline(always)]
            pub fn value(&mut self) -> VALUE_W {
                VALUE_W { w: self }
            }
        }
    }
    #[doc = "Component Parameter Register 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_param_1](comp_param_1) module"]
    pub type COMP_PARAM_1 = crate::Reg<u32, _COMP_PARAM_1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_PARAM_1;
    #[doc = "`read()` method returns [comp_param_1::R](comp_param_1::R) reader structure"]
    impl crate::Readable for COMP_PARAM_1 {}
    #[doc = "Component Parameter Register 1"]
    pub mod comp_param_1 {
        #[doc = "Reader of register comp_param_1"]
        pub type R = crate::R<u32, super::COMP_PARAM_1>;
        #[doc = "Reader of field `apb_data_width`"]
        pub type APB_DATA_WIDTH_R = crate::R<u8, u8>;
        #[doc = "Reader of field `max_speed_mode`"]
        pub type MAX_SPEED_MODE_R = crate::R<u8, u8>;
        #[doc = "Reader of field `hc_count_values`"]
        pub type HC_COUNT_VALUES_R = crate::R<bool, bool>;
        #[doc = "Reader of field `intr_io`"]
        pub type INTR_IO_R = crate::R<bool, bool>;
        #[doc = "Reader of field `has_dma`"]
        pub type HAS_DMA_R = crate::R<bool, bool>;
        #[doc = "Reader of field `encoded_params`"]
        pub type ENCODED_PARAMS_R = crate::R<bool, bool>;
        #[doc = "Reader of field `rx_buffer_depth`"]
        pub type RX_BUFFER_DEPTH_R = crate::R<u8, u8>;
        #[doc = "Reader of field `tx_buffer_depth`"]
        pub type TX_BUFFER_DEPTH_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 0:1 - APB_DATA_WIDTH"]
            #[inline(always)]
            pub fn apb_data_width(&self) -> APB_DATA_WIDTH_R {
                APB_DATA_WIDTH_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 2:3 - MAX_SPEED_MODE"]
            #[inline(always)]
            pub fn max_speed_mode(&self) -> MAX_SPEED_MODE_R {
                MAX_SPEED_MODE_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bit 4 - HC_COUNT_VALUES"]
            #[inline(always)]
            pub fn hc_count_values(&self) -> HC_COUNT_VALUES_R {
                HC_COUNT_VALUES_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - INTR_IO"]
            #[inline(always)]
            pub fn intr_io(&self) -> INTR_IO_R {
                INTR_IO_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - HAS_DMA"]
            #[inline(always)]
            pub fn has_dma(&self) -> HAS_DMA_R {
                HAS_DMA_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - ENCODED_PARAMS"]
            #[inline(always)]
            pub fn encoded_params(&self) -> ENCODED_PARAMS_R {
                ENCODED_PARAMS_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 8:15 - RX_BUFFER_DEPTH"]
            #[inline(always)]
            pub fn rx_buffer_depth(&self) -> RX_BUFFER_DEPTH_R {
                RX_BUFFER_DEPTH_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - TX_BUFFER_DEPTH"]
            #[inline(always)]
            pub fn tx_buffer_depth(&self) -> TX_BUFFER_DEPTH_R {
                TX_BUFFER_DEPTH_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
    }
    #[doc = "Component Version Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_version](comp_version) module"]
    pub type COMP_VERSION = crate::Reg<u32, _COMP_VERSION>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_VERSION;
    #[doc = "`read()` method returns [comp_version::R](comp_version::R) reader structure"]
    impl crate::Readable for COMP_VERSION {}
    #[doc = "Component Version Register"]
    pub mod comp_version {
        #[doc = "Reader of register comp_version"]
        pub type R = crate::R<u32, super::COMP_VERSION>;
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u32, u32>;
        impl R {
            #[doc = "Bits 0:31 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
    }
    #[doc = "Component Type Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_type](comp_type) module"]
    pub type COMP_TYPE = crate::Reg<u32, _COMP_TYPE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_TYPE;
    #[doc = "`read()` method returns [comp_type::R](comp_type::R) reader structure"]
    impl crate::Readable for COMP_TYPE {}
    #[doc = "Component Type Register"]
    pub mod comp_type {
        #[doc = "Reader of register comp_type"]
        pub type R = crate::R<u32, super::COMP_TYPE>;
        #[doc = "Reader of field `value`"]
        pub type VALUE_R = crate::R<u32, u32>;
        impl R {
            #[doc = "Bits 0:31 - VALUE"]
            #[inline(always)]
            pub fn value(&self) -> VALUE_R {
                VALUE_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
    }
}
#[doc = "Inter-Integrated Circuit Bus 1"]
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        0x5029_0000 as *const _
    }
}
impl Deref for I2C1 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C1::ptr() }
    }
}
#[doc = "Inter-Integrated Circuit Bus 2"]
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2c0::RegisterBlock {
        0x502a_0000 as *const _
    }
}
impl Deref for I2C2 {
    type Target = i2c0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*I2C2::ptr() }
    }
}
#[doc = "Field Programmable IO Array"]
pub struct FPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FPIOA {}
impl FPIOA {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fpioa::RegisterBlock {
        0x502b_0000 as *const _
    }
}
impl Deref for FPIOA {
    type Target = fpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*FPIOA::ptr() }
    }
}
#[doc = "Field Programmable IO Array"]
pub mod fpioa {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - FPIOA GPIO multiplexer io array"]
        pub io: [IO; 48],
        #[doc = "0xc0 - FPIOA GPIO multiplexer tie enable array"]
        pub tie_en: [TIE_EN; 8],
        #[doc = "0xe0 - FPIOA GPIO multiplexer tie value array"]
        pub tie_val: [TIE_VAL; 8],
    }
    #[doc = "FPIOA GPIO multiplexer io array\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [io](io) module"]
    pub type IO = crate::Reg<u32, _IO>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IO;
    #[doc = "`read()` method returns [io::R](io::R) reader structure"]
    impl crate::Readable for IO {}
    #[doc = "`write(|w| ..)` method takes [io::W](io::W) writer structure"]
    impl crate::Writable for IO {}
    #[doc = "FPIOA GPIO multiplexer io array"]
    pub mod io {
        #[doc = "Reader of register io[%s]"]
        pub type R = crate::R<u32, super::IO>;
        #[doc = "Writer for register io[%s]"]
        pub type W = crate::W<u32, super::IO>;
        #[doc = "Register io[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::IO {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ch_sel`"]
        pub type CH_SEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ch_sel`"]
        pub struct CH_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CH_SEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `ds`"]
        pub type DS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ds`"]
        pub struct DS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `oe_en`"]
        pub type OE_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `oe_en`"]
        pub struct OE_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OE_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `oe_inv`"]
        pub type OE_INV_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `oe_inv`"]
        pub struct OE_INV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OE_INV_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `do_sel`"]
        pub type DO_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `do_sel`"]
        pub struct DO_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DO_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `do_inv`"]
        pub type DO_INV_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `do_inv`"]
        pub struct DO_INV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DO_INV_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `pu`"]
        pub type PU_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pu`"]
        pub struct PU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PU_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `pd`"]
        pub type PD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pd`"]
        pub struct PD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Reader of field `sl`"]
        pub type SL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sl`"]
        pub struct SL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Reader of field `ie_en`"]
        pub type IE_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ie_en`"]
        pub struct IE_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IE_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `ie_inv`"]
        pub type IE_INV_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ie_inv`"]
        pub struct IE_INV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IE_INV_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `di_inv`"]
        pub type DI_INV_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `di_inv`"]
        pub struct DI_INV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DI_INV_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `st`"]
        pub type ST_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `st`"]
        pub struct ST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `pad_di`"]
        pub type PAD_DI_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pad_di`"]
        pub struct PAD_DI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PAD_DI_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | (((value as u32) & 0x01) << 31);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - Channel select from 256 input"]
            #[inline(always)]
            pub fn ch_sel(&self) -> CH_SEL_R {
                CH_SEL_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:11 - Driving selector"]
            #[inline(always)]
            pub fn ds(&self) -> DS_R {
                DS_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bit 12 - Static output enable, will AND with OE_INV"]
            #[inline(always)]
            pub fn oe_en(&self) -> OE_EN_R {
                OE_EN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13 - Invert output enable"]
            #[inline(always)]
            pub fn oe_inv(&self) -> OE_INV_R {
                OE_INV_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14 - Data output select: 0 for DO, 1 for OE"]
            #[inline(always)]
            pub fn do_sel(&self) -> DO_SEL_R {
                DO_SEL_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15 - Invert the result of data output select (DO_SEL)"]
            #[inline(always)]
            pub fn do_inv(&self) -> DO_INV_R {
                DO_INV_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Pull up enable. 0 for nothing, 1 for pull up"]
            #[inline(always)]
            pub fn pu(&self) -> PU_R {
                PU_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - Pull down enable. 0 for nothing, 1 for pull down"]
            #[inline(always)]
            pub fn pd(&self) -> PD_R {
                PD_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 19 - Slew rate control enable"]
            #[inline(always)]
            pub fn sl(&self) -> SL_R {
                SL_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20 - Static input enable, will AND with IE_INV"]
            #[inline(always)]
            pub fn ie_en(&self) -> IE_EN_R {
                IE_EN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21 - Invert input enable"]
            #[inline(always)]
            pub fn ie_inv(&self) -> IE_INV_R {
                IE_INV_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22 - Invert Data input"]
            #[inline(always)]
            pub fn di_inv(&self) -> DI_INV_R {
                DI_INV_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23 - Schmitt trigger"]
            #[inline(always)]
            pub fn st(&self) -> ST_R {
                ST_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 31 - Read current IO's data input"]
            #[inline(always)]
            pub fn pad_di(&self) -> PAD_DI_R {
                PAD_DI_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Channel select from 256 input"]
            #[inline(always)]
            pub fn ch_sel(&mut self) -> CH_SEL_W {
                CH_SEL_W { w: self }
            }
            #[doc = "Bits 8:11 - Driving selector"]
            #[inline(always)]
            pub fn ds(&mut self) -> DS_W {
                DS_W { w: self }
            }
            #[doc = "Bit 12 - Static output enable, will AND with OE_INV"]
            #[inline(always)]
            pub fn oe_en(&mut self) -> OE_EN_W {
                OE_EN_W { w: self }
            }
            #[doc = "Bit 13 - Invert output enable"]
            #[inline(always)]
            pub fn oe_inv(&mut self) -> OE_INV_W {
                OE_INV_W { w: self }
            }
            #[doc = "Bit 14 - Data output select: 0 for DO, 1 for OE"]
            #[inline(always)]
            pub fn do_sel(&mut self) -> DO_SEL_W {
                DO_SEL_W { w: self }
            }
            #[doc = "Bit 15 - Invert the result of data output select (DO_SEL)"]
            #[inline(always)]
            pub fn do_inv(&mut self) -> DO_INV_W {
                DO_INV_W { w: self }
            }
            #[doc = "Bit 16 - Pull up enable. 0 for nothing, 1 for pull up"]
            #[inline(always)]
            pub fn pu(&mut self) -> PU_W {
                PU_W { w: self }
            }
            #[doc = "Bit 17 - Pull down enable. 0 for nothing, 1 for pull down"]
            #[inline(always)]
            pub fn pd(&mut self) -> PD_W {
                PD_W { w: self }
            }
            #[doc = "Bit 19 - Slew rate control enable"]
            #[inline(always)]
            pub fn sl(&mut self) -> SL_W {
                SL_W { w: self }
            }
            #[doc = "Bit 20 - Static input enable, will AND with IE_INV"]
            #[inline(always)]
            pub fn ie_en(&mut self) -> IE_EN_W {
                IE_EN_W { w: self }
            }
            #[doc = "Bit 21 - Invert input enable"]
            #[inline(always)]
            pub fn ie_inv(&mut self) -> IE_INV_W {
                IE_INV_W { w: self }
            }
            #[doc = "Bit 22 - Invert Data input"]
            #[inline(always)]
            pub fn di_inv(&mut self) -> DI_INV_W {
                DI_INV_W { w: self }
            }
            #[doc = "Bit 23 - Schmitt trigger"]
            #[inline(always)]
            pub fn st(&mut self) -> ST_W {
                ST_W { w: self }
            }
            #[doc = "Bit 31 - Read current IO's data input"]
            #[inline(always)]
            pub fn pad_di(&mut self) -> PAD_DI_W {
                PAD_DI_W { w: self }
            }
        }
    }
    #[doc = "FPIOA GPIO multiplexer tie enable array\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tie_en](tie_en) module"]
    pub type TIE_EN = crate::Reg<u32, _TIE_EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TIE_EN;
    #[doc = "`read()` method returns [tie_en::R](tie_en::R) reader structure"]
    impl crate::Readable for TIE_EN {}
    #[doc = "`write(|w| ..)` method takes [tie_en::W](tie_en::W) writer structure"]
    impl crate::Writable for TIE_EN {}
    #[doc = "FPIOA GPIO multiplexer tie enable array"]
    pub mod tie_en {
        #[doc = "Reader of register tie_en[%s]"]
        pub type R = crate::R<u32, super::TIE_EN>;
        #[doc = "Writer for register tie_en[%s]"]
        pub type W = crate::W<u32, super::TIE_EN>;
        #[doc = "Register tie_en[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::TIE_EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "FPIOA GPIO multiplexer tie value array\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tie_val](tie_val) module"]
    pub type TIE_VAL = crate::Reg<u32, _TIE_VAL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TIE_VAL;
    #[doc = "`read()` method returns [tie_val::R](tie_val::R) reader structure"]
    impl crate::Readable for TIE_VAL {}
    #[doc = "`write(|w| ..)` method takes [tie_val::W](tie_val::W) writer structure"]
    impl crate::Writable for TIE_VAL {}
    #[doc = "FPIOA GPIO multiplexer tie value array"]
    pub mod tie_val {
        #[doc = "Reader of register tie_val[%s]"]
        pub type R = crate::R<u32, super::TIE_VAL>;
        #[doc = "Writer for register tie_val[%s]"]
        pub type W = crate::W<u32, super::TIE_VAL>;
        #[doc = "Register tie_val[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::TIE_VAL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "SHA256 Accelerator"]
pub struct SHA256 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SHA256 {}
impl SHA256 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sha256::RegisterBlock {
        0x502c_0000 as *const _
    }
}
impl Deref for SHA256 {
    type Target = sha256::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SHA256::ptr() }
    }
}
#[doc = "SHA256 Accelerator"]
pub mod sha256 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Calculated SHA256 return value"]
        pub result: [RESULT; 8],
        #[doc = "0x20 - SHA256 input data is written to this register"]
        pub data_in: DATA_IN,
        _reserved2: [u8; 4usize],
        #[doc = "0x28 - Counters register"]
        pub num_reg: NUM_REG,
        #[doc = "0x2c - Function configuration register 0"]
        pub function_reg_0: FUNCTION_REG_0,
        _reserved4: [u8; 4usize],
        #[doc = "0x34 - Function configuration register 1"]
        pub function_reg_1: FUNCTION_REG_1,
    }
    #[doc = "Calculated SHA256 return value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [result](result) module"]
    pub type RESULT = crate::Reg<u32, _RESULT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RESULT;
    #[doc = "`read()` method returns [result::R](result::R) reader structure"]
    impl crate::Readable for RESULT {}
    #[doc = "`write(|w| ..)` method takes [result::W](result::W) writer structure"]
    impl crate::Writable for RESULT {}
    #[doc = "Calculated SHA256 return value"]
    pub mod result {
        #[doc = "Reader of register result[%s]"]
        pub type R = crate::R<u32, super::RESULT>;
        #[doc = "Writer for register result[%s]"]
        pub type W = crate::W<u32, super::RESULT>;
        #[doc = "Register result[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::RESULT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "SHA256 input data is written to this register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_in](data_in) module"]
    pub type DATA_IN = crate::Reg<u32, _DATA_IN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DATA_IN;
    #[doc = "`read()` method returns [data_in::R](data_in::R) reader structure"]
    impl crate::Readable for DATA_IN {}
    #[doc = "`write(|w| ..)` method takes [data_in::W](data_in::W) writer structure"]
    impl crate::Writable for DATA_IN {}
    #[doc = "SHA256 input data is written to this register"]
    pub mod data_in {
        #[doc = "Reader of register data_in"]
        pub type R = crate::R<u32, super::DATA_IN>;
        #[doc = "Writer for register data_in"]
        pub type W = crate::W<u32, super::DATA_IN>;
        #[doc = "Register data_in `reset()`'s with value 0"]
        impl crate::ResetValue for super::DATA_IN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Counters register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [num_reg](num_reg) module"]
    pub type NUM_REG = crate::Reg<u32, _NUM_REG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _NUM_REG;
    #[doc = "`read()` method returns [num_reg::R](num_reg::R) reader structure"]
    impl crate::Readable for NUM_REG {}
    #[doc = "`write(|w| ..)` method takes [num_reg::W](num_reg::W) writer structure"]
    impl crate::Writable for NUM_REG {}
    #[doc = "Counters register"]
    pub mod num_reg {
        #[doc = "Reader of register num_reg"]
        pub type R = crate::R<u32, super::NUM_REG>;
        #[doc = "Writer for register num_reg"]
        pub type W = crate::W<u32, super::NUM_REG>;
        #[doc = "Register num_reg `reset()`'s with value 0"]
        impl crate::ResetValue for super::NUM_REG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `data_cnt`"]
        pub type DATA_CNT_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `data_cnt`"]
        pub struct DATA_CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_CNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `data_num`"]
        pub type DATA_NUM_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `data_num`"]
        pub struct DATA_NUM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_NUM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15 - The total amount of data calculated by SHA256 is set by this register, and the smallest unit is 512bit"]
            #[inline(always)]
            pub fn data_cnt(&self) -> DATA_CNT_R {
                DATA_CNT_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31 - Currently calculated block number. 512bit=1block"]
            #[inline(always)]
            pub fn data_num(&self) -> DATA_NUM_R {
                DATA_NUM_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - The total amount of data calculated by SHA256 is set by this register, and the smallest unit is 512bit"]
            #[inline(always)]
            pub fn data_cnt(&mut self) -> DATA_CNT_W {
                DATA_CNT_W { w: self }
            }
            #[doc = "Bits 16:31 - Currently calculated block number. 512bit=1block"]
            #[inline(always)]
            pub fn data_num(&mut self) -> DATA_NUM_W {
                DATA_NUM_W { w: self }
            }
        }
    }
    #[doc = "Function configuration register 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [function_reg_0](function_reg_0) module"]
    pub type FUNCTION_REG_0 = crate::Reg<u32, _FUNCTION_REG_0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FUNCTION_REG_0;
    #[doc = "`read()` method returns [function_reg_0::R](function_reg_0::R) reader structure"]
    impl crate::Readable for FUNCTION_REG_0 {}
    #[doc = "`write(|w| ..)` method takes [function_reg_0::W](function_reg_0::W) writer structure"]
    impl crate::Writable for FUNCTION_REG_0 {}
    #[doc = "Function configuration register 0"]
    pub mod function_reg_0 {
        #[doc = "Reader of register function_reg_0"]
        pub type R = crate::R<u32, super::FUNCTION_REG_0>;
        #[doc = "Writer for register function_reg_0"]
        pub type W = crate::W<u32, super::FUNCTION_REG_0>;
        #[doc = "Register function_reg_0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::FUNCTION_REG_0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `en`"]
        pub type EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `en`"]
        pub struct EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `overflow`"]
        pub type OVERFLOW_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `overflow`"]
        pub struct OVERFLOW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVERFLOW_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Endian setting\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDIAN_A {
            #[doc = "0: Little endian"]
            LE = 0,
            #[doc = "1: Big endian"]
            BE = 1,
        }
        impl From<ENDIAN_A> for bool {
            #[inline(always)]
            fn from(variant: ENDIAN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `endian`"]
        pub type ENDIAN_R = crate::R<bool, ENDIAN_A>;
        impl ENDIAN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENDIAN_A {
                match self.bits {
                    false => ENDIAN_A::LE,
                    true => ENDIAN_A::BE,
                }
            }
            #[doc = "Checks if the value of the field is `LE`"]
            #[inline(always)]
            pub fn is_le(&self) -> bool {
                *self == ENDIAN_A::LE
            }
            #[doc = "Checks if the value of the field is `BE`"]
            #[inline(always)]
            pub fn is_be(&self) -> bool {
                *self == ENDIAN_A::BE
            }
        }
        #[doc = "Write proxy for field `endian`"]
        pub struct ENDIAN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENDIAN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENDIAN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Little endian"]
            #[inline(always)]
            pub fn le(self) -> &'a mut W {
                self.variant(ENDIAN_A::LE)
            }
            #[doc = "Big endian"]
            #[inline(always)]
            pub fn be(self) -> &'a mut W {
                self.variant(ENDIAN_A::BE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - write:SHA256 enable register. read:Calculation completed flag"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 8 - SHA256 calculation overflow flag"]
            #[inline(always)]
            pub fn overflow(&self) -> OVERFLOW_R {
                OVERFLOW_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 16 - Endian setting"]
            #[inline(always)]
            pub fn endian(&self) -> ENDIAN_R {
                ENDIAN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - write:SHA256 enable register. read:Calculation completed flag"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W {
                EN_W { w: self }
            }
            #[doc = "Bit 8 - SHA256 calculation overflow flag"]
            #[inline(always)]
            pub fn overflow(&mut self) -> OVERFLOW_W {
                OVERFLOW_W { w: self }
            }
            #[doc = "Bit 16 - Endian setting"]
            #[inline(always)]
            pub fn endian(&mut self) -> ENDIAN_W {
                ENDIAN_W { w: self }
            }
        }
    }
    #[doc = "Function configuration register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [function_reg_1](function_reg_1) module"]
    pub type FUNCTION_REG_1 = crate::Reg<u32, _FUNCTION_REG_1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FUNCTION_REG_1;
    #[doc = "`read()` method returns [function_reg_1::R](function_reg_1::R) reader structure"]
    impl crate::Readable for FUNCTION_REG_1 {}
    #[doc = "`write(|w| ..)` method takes [function_reg_1::W](function_reg_1::W) writer structure"]
    impl crate::Writable for FUNCTION_REG_1 {}
    #[doc = "Function configuration register 1"]
    pub mod function_reg_1 {
        #[doc = "Reader of register function_reg_1"]
        pub type R = crate::R<u32, super::FUNCTION_REG_1>;
        #[doc = "Writer for register function_reg_1"]
        pub type W = crate::W<u32, super::FUNCTION_REG_1>;
        #[doc = "Register function_reg_1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::FUNCTION_REG_1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dma_en`"]
        pub type DMA_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_en`"]
        pub struct DMA_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `fifo_in_full`"]
        pub type FIFO_IN_FULL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fifo_in_full`"]
        pub struct FIFO_IN_FULL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FIFO_IN_FULL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - SHA and DMA handshake signals enable. 1:enable; 0:disable"]
            #[inline(always)]
            pub fn dma_en(&self) -> DMA_EN_R {
                DMA_EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 8 - 1:SHA256 input fifo is full; 0:not full"]
            #[inline(always)]
            pub fn fifo_in_full(&self) -> FIFO_IN_FULL_R {
                FIFO_IN_FULL_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - SHA and DMA handshake signals enable. 1:enable; 0:disable"]
            #[inline(always)]
            pub fn dma_en(&mut self) -> DMA_EN_W {
                DMA_EN_W { w: self }
            }
            #[doc = "Bit 8 - 1:SHA256 input fifo is full; 0:not full"]
            #[inline(always)]
            pub fn fifo_in_full(&mut self) -> FIFO_IN_FULL_W {
                FIFO_IN_FULL_W { w: self }
            }
        }
    }
}
#[doc = "Timer 0"]
pub struct TIMER0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER0 {}
impl TIMER0 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0::RegisterBlock {
        0x502d_0000 as *const _
    }
}
impl Deref for TIMER0 {
    type Target = timer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIMER0::ptr() }
    }
}
#[doc = "Timer 0"]
pub mod timer0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Channel cluster: load_count, current_value, control, eoi and intr_stat registers"]
        pub channel: [CHANNEL; 4],
        _reserved1: [u8; 80usize],
        #[doc = "0xa0 - Interrupt Status Register"]
        pub intr_stat: INTR_STAT,
        #[doc = "0xa4 - Interrupt Clear Register"]
        pub eoi: EOI,
        #[doc = "0xa8 - Raw Interrupt Status Register"]
        pub raw_intr_stat: RAW_INTR_STAT,
        #[doc = "0xac - Component Version Register"]
        pub comp_version: COMP_VERSION,
        #[doc = "0xb0 - Load Count2 Register"]
        pub load_count2: [LOAD_COUNT2; 4],
    }
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct CHANNEL {
        #[doc = "0x00 - Load Count Register"]
        pub load_count: self::channel::LOAD_COUNT,
        #[doc = "0x04 - Current Value Register"]
        pub current_value: self::channel::CURRENT_VALUE,
        #[doc = "0x08 - Control Register"]
        pub control: self::channel::CONTROL,
        #[doc = "0x0c - Interrupt Clear Register"]
        pub eoi: self::channel::EOI,
        #[doc = "0x10 - Interrupt Status Register"]
        pub intr_stat: self::channel::INTR_STAT,
    }
    #[doc = r"Register block"]
    #[doc = "Channel cluster: load_count, current_value, control, eoi and intr_stat registers"]
    pub mod channel {
        #[doc = "Load Count Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [load_count](load_count) module"]
        pub type LOAD_COUNT = crate::Reg<u32, _LOAD_COUNT>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _LOAD_COUNT;
        #[doc = "`read()` method returns [load_count::R](load_count::R) reader structure"]
        impl crate::Readable for LOAD_COUNT {}
        #[doc = "`write(|w| ..)` method takes [load_count::W](load_count::W) writer structure"]
        impl crate::Writable for LOAD_COUNT {}
        #[doc = "Load Count Register"]
        pub mod load_count {
            #[doc = "Reader of register load_count"]
            pub type R = crate::R<u32, super::LOAD_COUNT>;
            #[doc = "Writer for register load_count"]
            pub type W = crate::W<u32, super::LOAD_COUNT>;
            #[doc = "Register load_count `reset()`'s with value 0"]
            impl crate::ResetValue for super::LOAD_COUNT {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Current Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [current_value](current_value) module"]
        pub type CURRENT_VALUE = crate::Reg<u32, _CURRENT_VALUE>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _CURRENT_VALUE;
        #[doc = "`read()` method returns [current_value::R](current_value::R) reader structure"]
        impl crate::Readable for CURRENT_VALUE {}
        #[doc = "`write(|w| ..)` method takes [current_value::W](current_value::W) writer structure"]
        impl crate::Writable for CURRENT_VALUE {}
        #[doc = "Current Value Register"]
        pub mod current_value {
            #[doc = "Reader of register current_value"]
            pub type R = crate::R<u32, super::CURRENT_VALUE>;
            #[doc = "Writer for register current_value"]
            pub type W = crate::W<u32, super::CURRENT_VALUE>;
            #[doc = "Register current_value `reset()`'s with value 0"]
            impl crate::ResetValue for super::CURRENT_VALUE {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [control](control) module"]
        pub type CONTROL = crate::Reg<u32, _CONTROL>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _CONTROL;
        #[doc = "`read()` method returns [control::R](control::R) reader structure"]
        impl crate::Readable for CONTROL {}
        #[doc = "`write(|w| ..)` method takes [control::W](control::W) writer structure"]
        impl crate::Writable for CONTROL {}
        #[doc = "Control Register"]
        pub mod control {
            #[doc = "Reader of register control"]
            pub type R = crate::R<u32, super::CONTROL>;
            #[doc = "Writer for register control"]
            pub type W = crate::W<u32, super::CONTROL>;
            #[doc = "Register control `reset()`'s with value 0"]
            impl crate::ResetValue for super::CONTROL {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            #[doc = "Reader of field `enable`"]
            pub type ENABLE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `enable`"]
            pub struct ENABLE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> ENABLE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                    self.w
                }
            }
            #[doc = "MODE\n\nValue on reset: 0"]
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MODE_A {
                #[doc = "0: FREE_MODE"]
                FREE = 0,
                #[doc = "1: USER_MODE"]
                USER = 1,
            }
            impl From<MODE_A> for bool {
                #[inline(always)]
                fn from(variant: MODE_A) -> Self {
                    variant as u8 != 0
                }
            }
            #[doc = "Reader of field `mode`"]
            pub type MODE_R = crate::R<bool, MODE_A>;
            impl MODE_R {
                #[doc = r"Get enumerated values variant"]
                #[inline(always)]
                pub fn variant(&self) -> MODE_A {
                    match self.bits {
                        false => MODE_A::FREE,
                        true => MODE_A::USER,
                    }
                }
                #[doc = "Checks if the value of the field is `FREE`"]
                #[inline(always)]
                pub fn is_free(&self) -> bool {
                    *self == MODE_A::FREE
                }
                #[doc = "Checks if the value of the field is `USER`"]
                #[inline(always)]
                pub fn is_user(&self) -> bool {
                    *self == MODE_A::USER
                }
            }
            #[doc = "Write proxy for field `mode`"]
            pub struct MODE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MODE_W<'a> {
                #[doc = r"Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: MODE_A) -> &'a mut W {
                    {
                        self.bit(variant.into())
                    }
                }
                #[doc = "FREE_MODE"]
                #[inline(always)]
                pub fn free(self) -> &'a mut W {
                    self.variant(MODE_A::FREE)
                }
                #[doc = "USER_MODE"]
                #[inline(always)]
                pub fn user(self) -> &'a mut W {
                    self.variant(MODE_A::USER)
                }
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                    self.w
                }
            }
            #[doc = "Reader of field `interrupt`"]
            pub type INTERRUPT_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `interrupt`"]
            pub struct INTERRUPT_W<'a> {
                w: &'a mut W,
            }
            impl<'a> INTERRUPT_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                    self.w
                }
            }
            #[doc = "Reader of field `pwm_enable`"]
            pub type PWM_ENABLE_R = crate::R<bool, bool>;
            #[doc = "Write proxy for field `pwm_enable`"]
            pub struct PWM_ENABLE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PWM_ENABLE_W<'a> {
                #[doc = r"Sets the field bit"]
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                #[doc = r"Clears the field bit"]
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                #[doc = r"Writes raw bits to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                    self.w
                }
            }
            impl R {
                #[doc = "Bit 0 - ENABLE"]
                #[inline(always)]
                pub fn enable(&self) -> ENABLE_R {
                    ENABLE_R::new((self.bits & 0x01) != 0)
                }
                #[doc = "Bit 1 - MODE"]
                #[inline(always)]
                pub fn mode(&self) -> MODE_R {
                    MODE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                #[doc = "Bit 2 - INTERRUPT_MASK"]
                #[inline(always)]
                pub fn interrupt(&self) -> INTERRUPT_R {
                    INTERRUPT_R::new(((self.bits >> 2) & 0x01) != 0)
                }
                #[doc = "Bit 3 - PWM_ENABLE"]
                #[inline(always)]
                pub fn pwm_enable(&self) -> PWM_ENABLE_R {
                    PWM_ENABLE_R::new(((self.bits >> 3) & 0x01) != 0)
                }
            }
            impl W {
                #[doc = "Bit 0 - ENABLE"]
                #[inline(always)]
                pub fn enable(&mut self) -> ENABLE_W {
                    ENABLE_W { w: self }
                }
                #[doc = "Bit 1 - MODE"]
                #[inline(always)]
                pub fn mode(&mut self) -> MODE_W {
                    MODE_W { w: self }
                }
                #[doc = "Bit 2 - INTERRUPT_MASK"]
                #[inline(always)]
                pub fn interrupt(&mut self) -> INTERRUPT_W {
                    INTERRUPT_W { w: self }
                }
                #[doc = "Bit 3 - PWM_ENABLE"]
                #[inline(always)]
                pub fn pwm_enable(&mut self) -> PWM_ENABLE_W {
                    PWM_ENABLE_W { w: self }
                }
            }
        }
        #[doc = "Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eoi](eoi) module"]
        pub type EOI = crate::Reg<u32, _EOI>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _EOI;
        #[doc = "`read()` method returns [eoi::R](eoi::R) reader structure"]
        impl crate::Readable for EOI {}
        #[doc = "`write(|w| ..)` method takes [eoi::W](eoi::W) writer structure"]
        impl crate::Writable for EOI {}
        #[doc = "Interrupt Clear Register"]
        pub mod eoi {
            #[doc = "Reader of register eoi"]
            pub type R = crate::R<u32, super::EOI>;
            #[doc = "Writer for register eoi"]
            pub type W = crate::W<u32, super::EOI>;
            #[doc = "Register eoi `reset()`'s with value 0"]
            impl crate::ResetValue for super::EOI {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
        #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_stat](intr_stat) module"]
        pub type INTR_STAT = crate::Reg<u32, _INTR_STAT>;
        #[allow(missing_docs)]
        #[doc(hidden)]
        pub struct _INTR_STAT;
        #[doc = "`read()` method returns [intr_stat::R](intr_stat::R) reader structure"]
        impl crate::Readable for INTR_STAT {}
        #[doc = "`write(|w| ..)` method takes [intr_stat::W](intr_stat::W) writer structure"]
        impl crate::Writable for INTR_STAT {}
        #[doc = "Interrupt Status Register"]
        pub mod intr_stat {
            #[doc = "Reader of register intr_stat"]
            pub type R = crate::R<u32, super::INTR_STAT>;
            #[doc = "Writer for register intr_stat"]
            pub type W = crate::W<u32, super::INTR_STAT>;
            #[doc = "Register intr_stat `reset()`'s with value 0"]
            impl crate::ResetValue for super::INTR_STAT {
                type Type = u32;
                #[inline(always)]
                fn reset_value() -> Self::Type {
                    0
                }
            }
            impl R {}
            impl W {}
        }
    }
    #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [intr_stat](intr_stat) module"]
    pub type INTR_STAT = crate::Reg<u32, _INTR_STAT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTR_STAT;
    #[doc = "`read()` method returns [intr_stat::R](intr_stat::R) reader structure"]
    impl crate::Readable for INTR_STAT {}
    #[doc = "`write(|w| ..)` method takes [intr_stat::W](intr_stat::W) writer structure"]
    impl crate::Writable for INTR_STAT {}
    #[doc = "Interrupt Status Register"]
    pub mod intr_stat {
        #[doc = "Reader of register intr_stat"]
        pub type R = crate::R<u32, super::INTR_STAT>;
        #[doc = "Writer for register intr_stat"]
        pub type W = crate::W<u32, super::INTR_STAT>;
        #[doc = "Register intr_stat `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTR_STAT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eoi](eoi) module"]
    pub type EOI = crate::Reg<u32, _EOI>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EOI;
    #[doc = "`read()` method returns [eoi::R](eoi::R) reader structure"]
    impl crate::Readable for EOI {}
    #[doc = "`write(|w| ..)` method takes [eoi::W](eoi::W) writer structure"]
    impl crate::Writable for EOI {}
    #[doc = "Interrupt Clear Register"]
    pub mod eoi {
        #[doc = "Reader of register eoi"]
        pub type R = crate::R<u32, super::EOI>;
        #[doc = "Writer for register eoi"]
        pub type W = crate::W<u32, super::EOI>;
        #[doc = "Register eoi `reset()`'s with value 0"]
        impl crate::ResetValue for super::EOI {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Raw Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [raw_intr_stat](raw_intr_stat) module"]
    pub type RAW_INTR_STAT = crate::Reg<u32, _RAW_INTR_STAT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RAW_INTR_STAT;
    #[doc = "`read()` method returns [raw_intr_stat::R](raw_intr_stat::R) reader structure"]
    impl crate::Readable for RAW_INTR_STAT {}
    #[doc = "`write(|w| ..)` method takes [raw_intr_stat::W](raw_intr_stat::W) writer structure"]
    impl crate::Writable for RAW_INTR_STAT {}
    #[doc = "Raw Interrupt Status Register"]
    pub mod raw_intr_stat {
        #[doc = "Reader of register raw_intr_stat"]
        pub type R = crate::R<u32, super::RAW_INTR_STAT>;
        #[doc = "Writer for register raw_intr_stat"]
        pub type W = crate::W<u32, super::RAW_INTR_STAT>;
        #[doc = "Register raw_intr_stat `reset()`'s with value 0"]
        impl crate::ResetValue for super::RAW_INTR_STAT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Version Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_version](comp_version) module"]
    pub type COMP_VERSION = crate::Reg<u32, _COMP_VERSION>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_VERSION;
    #[doc = "`read()` method returns [comp_version::R](comp_version::R) reader structure"]
    impl crate::Readable for COMP_VERSION {}
    #[doc = "`write(|w| ..)` method takes [comp_version::W](comp_version::W) writer structure"]
    impl crate::Writable for COMP_VERSION {}
    #[doc = "Component Version Register"]
    pub mod comp_version {
        #[doc = "Reader of register comp_version"]
        pub type R = crate::R<u32, super::COMP_VERSION>;
        #[doc = "Writer for register comp_version"]
        pub type W = crate::W<u32, super::COMP_VERSION>;
        #[doc = "Register comp_version `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_VERSION {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Load Count2 Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [load_count2](load_count2) module"]
    pub type LOAD_COUNT2 = crate::Reg<u32, _LOAD_COUNT2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _LOAD_COUNT2;
    #[doc = "`read()` method returns [load_count2::R](load_count2::R) reader structure"]
    impl crate::Readable for LOAD_COUNT2 {}
    #[doc = "`write(|w| ..)` method takes [load_count2::W](load_count2::W) writer structure"]
    impl crate::Writable for LOAD_COUNT2 {}
    #[doc = "Load Count2 Register"]
    pub mod load_count2 {
        #[doc = "Reader of register load_count2%s"]
        pub type R = crate::R<u32, super::LOAD_COUNT2>;
        #[doc = "Writer for register load_count2%s"]
        pub type W = crate::W<u32, super::LOAD_COUNT2>;
        #[doc = "Register load_count2%s `reset()`'s with value 0"]
        impl crate::ResetValue for super::LOAD_COUNT2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Timer 1"]
pub struct TIMER1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER1 {}
impl TIMER1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0::RegisterBlock {
        0x502e_0000 as *const _
    }
}
impl Deref for TIMER1 {
    type Target = timer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIMER1::ptr() }
    }
}
#[doc = "Timer 2"]
pub struct TIMER2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER2 {}
impl TIMER2 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const timer0::RegisterBlock {
        0x502f_0000 as *const _
    }
}
impl Deref for TIMER2 {
    type Target = timer0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*TIMER2::ptr() }
    }
}
#[doc = "Watchdog Timer 0"]
pub struct WDT0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT0 {}
impl WDT0 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt0::RegisterBlock {
        0x5040_0000 as *const _
    }
}
impl Deref for WDT0 {
    type Target = wdt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*WDT0::ptr() }
    }
}
#[doc = "Watchdog Timer 0"]
pub mod wdt0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register"]
        pub cr: CR,
        #[doc = "0x04 - Timeout Range Register"]
        pub torr: TORR,
        #[doc = "0x08 - Current Counter Value Register"]
        pub ccvr: CCVR,
        #[doc = "0x0c - Counter Restart Register"]
        pub crr: CRR,
        #[doc = "0x10 - Interrupt Status Register"]
        pub stat: STAT,
        #[doc = "0x14 - Interrupt Clear Register"]
        pub eoi: EOI,
        _reserved6: [u8; 4usize],
        #[doc = "0x1c - Protection level Register"]
        pub prot_level: PROT_LEVEL,
        _reserved7: [u8; 196usize],
        #[doc = "0xe4 - Component Parameters Register 5"]
        pub comp_param_5: COMP_PARAM_5,
        #[doc = "0xe8 - Component Parameters Register 4"]
        pub comp_param_4: COMP_PARAM_4,
        #[doc = "0xec - Component Parameters Register 3"]
        pub comp_param_3: COMP_PARAM_3,
        #[doc = "0xf0 - Component Parameters Register 2"]
        pub comp_param_2: COMP_PARAM_2,
        #[doc = "0xf4 - Component Parameters Register 1"]
        pub comp_param_1: COMP_PARAM_1,
        #[doc = "0xf8 - Component Version Register"]
        pub comp_version: COMP_VERSION,
        #[doc = "0xfc - Component Type Register"]
        pub comp_type: COMP_TYPE,
    }
    #[doc = "Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cr](cr) module"]
    pub type CR = crate::Reg<u32, _CR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CR;
    #[doc = "`read()` method returns [cr::R](cr::R) reader structure"]
    impl crate::Readable for CR {}
    #[doc = "`write(|w| ..)` method takes [cr::W](cr::W) writer structure"]
    impl crate::Writable for CR {}
    #[doc = "Control Register"]
    pub mod cr {
        #[doc = "Reader of register cr"]
        pub type R = crate::R<u32, super::CR>;
        #[doc = "Writer for register cr"]
        pub type W = crate::W<u32, super::CR>;
        #[doc = "Register cr `reset()`'s with value 0"]
        impl crate::ResetValue for super::CR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `enable`"]
        pub type ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `enable`"]
        pub struct ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "rmod\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RMOD_A {
            #[doc = "0: RESET"]
            RESET = 0,
            #[doc = "1: INTERRUPT"]
            INTERRUPT = 1,
        }
        impl From<RMOD_A> for bool {
            #[inline(always)]
            fn from(variant: RMOD_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `rmod`"]
        pub type RMOD_R = crate::R<bool, RMOD_A>;
        impl RMOD_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> RMOD_A {
                match self.bits {
                    false => RMOD_A::RESET,
                    true => RMOD_A::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == RMOD_A::RESET
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline(always)]
            pub fn is_interrupt(&self) -> bool {
                *self == RMOD_A::INTERRUPT
            }
        }
        #[doc = "Write proxy for field `rmod`"]
        pub struct RMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RMOD_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RMOD_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "RESET"]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RMOD_A::RESET)
            }
            #[doc = "INTERRUPT"]
            #[inline(always)]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(RMOD_A::INTERRUPT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `rpl`"]
        pub type RPL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `rpl`"]
        pub struct RPL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RPL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 2)) | (((value as u32) & 0x07) << 2);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - enable"]
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - rmod"]
            #[inline(always)]
            pub fn rmod(&self) -> RMOD_R {
                RMOD_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bits 2:4 - rpl"]
            #[inline(always)]
            pub fn rpl(&self) -> RPL_R {
                RPL_R::new(((self.bits >> 2) & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable"]
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W {
                ENABLE_W { w: self }
            }
            #[doc = "Bit 1 - rmod"]
            #[inline(always)]
            pub fn rmod(&mut self) -> RMOD_W {
                RMOD_W { w: self }
            }
            #[doc = "Bits 2:4 - rpl"]
            #[inline(always)]
            pub fn rpl(&mut self) -> RPL_W {
                RPL_W { w: self }
            }
        }
    }
    #[doc = "Timeout Range Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [torr](torr) module"]
    pub type TORR = crate::Reg<u32, _TORR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TORR;
    #[doc = "`read()` method returns [torr::R](torr::R) reader structure"]
    impl crate::Readable for TORR {}
    #[doc = "`write(|w| ..)` method takes [torr::W](torr::W) writer structure"]
    impl crate::Writable for TORR {}
    #[doc = "Timeout Range Register"]
    pub mod torr {
        #[doc = "Reader of register torr"]
        pub type R = crate::R<u32, super::TORR>;
        #[doc = "Writer for register torr"]
        pub type W = crate::W<u32, super::TORR>;
        #[doc = "Register torr `reset()`'s with value 0"]
        impl crate::ResetValue for super::TORR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `top0`"]
        pub type TOP0_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `top0`"]
        pub struct TOP0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TOP0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `top1`"]
        pub type TOP1_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `top1`"]
        pub struct TOP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TOP1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3 - top (lower half)"]
            #[inline(always)]
            pub fn top0(&self) -> TOP0_R {
                TOP0_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - top (upper half)"]
            #[inline(always)]
            pub fn top1(&self) -> TOP1_R {
                TOP1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - top (lower half)"]
            #[inline(always)]
            pub fn top0(&mut self) -> TOP0_W {
                TOP0_W { w: self }
            }
            #[doc = "Bits 4:7 - top (upper half)"]
            #[inline(always)]
            pub fn top1(&mut self) -> TOP1_W {
                TOP1_W { w: self }
            }
        }
    }
    #[doc = "Current Counter Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [ccvr](ccvr) module"]
    pub type CCVR = crate::Reg<u32, _CCVR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CCVR;
    #[doc = "`read()` method returns [ccvr::R](ccvr::R) reader structure"]
    impl crate::Readable for CCVR {}
    #[doc = "`write(|w| ..)` method takes [ccvr::W](ccvr::W) writer structure"]
    impl crate::Writable for CCVR {}
    #[doc = "Current Counter Value Register"]
    pub mod ccvr {
        #[doc = "Reader of register ccvr"]
        pub type R = crate::R<u32, super::CCVR>;
        #[doc = "Writer for register ccvr"]
        pub type W = crate::W<u32, super::CCVR>;
        #[doc = "Register ccvr `reset()`'s with value 0"]
        impl crate::ResetValue for super::CCVR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Counter Restart Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [crr](crr) module"]
    pub type CRR = crate::Reg<u32, _CRR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CRR;
    #[doc = "`read()` method returns [crr::R](crr::R) reader structure"]
    impl crate::Readable for CRR {}
    #[doc = "`write(|w| ..)` method takes [crr::W](crr::W) writer structure"]
    impl crate::Writable for CRR {}
    #[doc = "Counter Restart Register"]
    pub mod crr {
        #[doc = "Reader of register crr"]
        pub type R = crate::R<u32, super::CRR>;
        #[doc = "Writer for register crr"]
        pub type W = crate::W<u32, super::CRR>;
        #[doc = "Register crr `reset()`'s with value 0"]
        impl crate::ResetValue for super::CRR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Interrupt Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [stat](stat) module"]
    pub type STAT = crate::Reg<u32, _STAT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _STAT;
    #[doc = "`read()` method returns [stat::R](stat::R) reader structure"]
    impl crate::Readable for STAT {}
    #[doc = "`write(|w| ..)` method takes [stat::W](stat::W) writer structure"]
    impl crate::Writable for STAT {}
    #[doc = "Interrupt Status Register"]
    pub mod stat {
        #[doc = "Reader of register stat"]
        pub type R = crate::R<u32, super::STAT>;
        #[doc = "Writer for register stat"]
        pub type W = crate::W<u32, super::STAT>;
        #[doc = "Register stat `reset()`'s with value 0"]
        impl crate::ResetValue for super::STAT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `stat`"]
        pub type STAT_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `stat`"]
        pub struct STAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STAT_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - stat"]
            #[inline(always)]
            pub fn stat(&self) -> STAT_R {
                STAT_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - stat"]
            #[inline(always)]
            pub fn stat(&mut self) -> STAT_W {
                STAT_W { w: self }
            }
        }
    }
    #[doc = "Interrupt Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [eoi](eoi) module"]
    pub type EOI = crate::Reg<u32, _EOI>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EOI;
    #[doc = "`read()` method returns [eoi::R](eoi::R) reader structure"]
    impl crate::Readable for EOI {}
    #[doc = "`write(|w| ..)` method takes [eoi::W](eoi::W) writer structure"]
    impl crate::Writable for EOI {}
    #[doc = "Interrupt Clear Register"]
    pub mod eoi {
        #[doc = "Reader of register eoi"]
        pub type R = crate::R<u32, super::EOI>;
        #[doc = "Writer for register eoi"]
        pub type W = crate::W<u32, super::EOI>;
        #[doc = "Register eoi `reset()`'s with value 0"]
        impl crate::ResetValue for super::EOI {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `eoi`"]
        pub type EOI_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `eoi`"]
        pub struct EOI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOI_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - eoi"]
            #[inline(always)]
            pub fn eoi(&self) -> EOI_R {
                EOI_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - eoi"]
            #[inline(always)]
            pub fn eoi(&mut self) -> EOI_W {
                EOI_W { w: self }
            }
        }
    }
    #[doc = "Protection level Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [prot_level](prot_level) module"]
    pub type PROT_LEVEL = crate::Reg<u32, _PROT_LEVEL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PROT_LEVEL;
    #[doc = "`read()` method returns [prot_level::R](prot_level::R) reader structure"]
    impl crate::Readable for PROT_LEVEL {}
    #[doc = "`write(|w| ..)` method takes [prot_level::W](prot_level::W) writer structure"]
    impl crate::Writable for PROT_LEVEL {}
    #[doc = "Protection level Register"]
    pub mod prot_level {
        #[doc = "Reader of register prot_level"]
        pub type R = crate::R<u32, super::PROT_LEVEL>;
        #[doc = "Writer for register prot_level"]
        pub type W = crate::W<u32, super::PROT_LEVEL>;
        #[doc = "Register prot_level `reset()`'s with value 0"]
        impl crate::ResetValue for super::PROT_LEVEL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `prot_level`"]
        pub type PROT_LEVEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `prot_level`"]
        pub struct PROT_LEVEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PROT_LEVEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - prot_level"]
            #[inline(always)]
            pub fn prot_level(&self) -> PROT_LEVEL_R {
                PROT_LEVEL_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - prot_level"]
            #[inline(always)]
            pub fn prot_level(&mut self) -> PROT_LEVEL_W {
                PROT_LEVEL_W { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_param_5](comp_param_5) module"]
    pub type COMP_PARAM_5 = crate::Reg<u32, _COMP_PARAM_5>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_PARAM_5;
    #[doc = "`read()` method returns [comp_param_5::R](comp_param_5::R) reader structure"]
    impl crate::Readable for COMP_PARAM_5 {}
    #[doc = "`write(|w| ..)` method takes [comp_param_5::W](comp_param_5::W) writer structure"]
    impl crate::Writable for COMP_PARAM_5 {}
    #[doc = "Component Parameters Register 5"]
    pub mod comp_param_5 {
        #[doc = "Reader of register comp_param_5"]
        pub type R = crate::R<u32, super::COMP_PARAM_5>;
        #[doc = "Writer for register comp_param_5"]
        pub type W = crate::W<u32, super::COMP_PARAM_5>;
        #[doc = "Register comp_param_5 `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_PARAM_5 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `user_top_max`"]
        pub type USER_TOP_MAX_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `user_top_max`"]
        pub struct USER_TOP_MAX_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USER_TOP_MAX_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - user_top_max"]
            #[inline(always)]
            pub fn user_top_max(&self) -> USER_TOP_MAX_R {
                USER_TOP_MAX_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - user_top_max"]
            #[inline(always)]
            pub fn user_top_max(&mut self) -> USER_TOP_MAX_W {
                USER_TOP_MAX_W { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_param_4](comp_param_4) module"]
    pub type COMP_PARAM_4 = crate::Reg<u32, _COMP_PARAM_4>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_PARAM_4;
    #[doc = "`read()` method returns [comp_param_4::R](comp_param_4::R) reader structure"]
    impl crate::Readable for COMP_PARAM_4 {}
    #[doc = "`write(|w| ..)` method takes [comp_param_4::W](comp_param_4::W) writer structure"]
    impl crate::Writable for COMP_PARAM_4 {}
    #[doc = "Component Parameters Register 4"]
    pub mod comp_param_4 {
        #[doc = "Reader of register comp_param_4"]
        pub type R = crate::R<u32, super::COMP_PARAM_4>;
        #[doc = "Writer for register comp_param_4"]
        pub type W = crate::W<u32, super::COMP_PARAM_4>;
        #[doc = "Register comp_param_4 `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_PARAM_4 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `user_top_init_max`"]
        pub type USER_TOP_INIT_MAX_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `user_top_init_max`"]
        pub struct USER_TOP_INIT_MAX_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USER_TOP_INIT_MAX_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - user_top_init_max"]
            #[inline(always)]
            pub fn user_top_init_max(&self) -> USER_TOP_INIT_MAX_R {
                USER_TOP_INIT_MAX_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - user_top_init_max"]
            #[inline(always)]
            pub fn user_top_init_max(&mut self) -> USER_TOP_INIT_MAX_W {
                USER_TOP_INIT_MAX_W { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_param_3](comp_param_3) module"]
    pub type COMP_PARAM_3 = crate::Reg<u32, _COMP_PARAM_3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_PARAM_3;
    #[doc = "`read()` method returns [comp_param_3::R](comp_param_3::R) reader structure"]
    impl crate::Readable for COMP_PARAM_3 {}
    #[doc = "`write(|w| ..)` method takes [comp_param_3::W](comp_param_3::W) writer structure"]
    impl crate::Writable for COMP_PARAM_3 {}
    #[doc = "Component Parameters Register 3"]
    pub mod comp_param_3 {
        #[doc = "Reader of register comp_param_3"]
        pub type R = crate::R<u32, super::COMP_PARAM_3>;
        #[doc = "Writer for register comp_param_3"]
        pub type W = crate::W<u32, super::COMP_PARAM_3>;
        #[doc = "Register comp_param_3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_PARAM_3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `top_rst`"]
        pub type TOP_RST_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `top_rst`"]
        pub struct TOP_RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TOP_RST_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - top_rst"]
            #[inline(always)]
            pub fn top_rst(&self) -> TOP_RST_R {
                TOP_RST_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - top_rst"]
            #[inline(always)]
            pub fn top_rst(&mut self) -> TOP_RST_W {
                TOP_RST_W { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_param_2](comp_param_2) module"]
    pub type COMP_PARAM_2 = crate::Reg<u32, _COMP_PARAM_2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_PARAM_2;
    #[doc = "`read()` method returns [comp_param_2::R](comp_param_2::R) reader structure"]
    impl crate::Readable for COMP_PARAM_2 {}
    #[doc = "`write(|w| ..)` method takes [comp_param_2::W](comp_param_2::W) writer structure"]
    impl crate::Writable for COMP_PARAM_2 {}
    #[doc = "Component Parameters Register 2"]
    pub mod comp_param_2 {
        #[doc = "Reader of register comp_param_2"]
        pub type R = crate::R<u32, super::COMP_PARAM_2>;
        #[doc = "Writer for register comp_param_2"]
        pub type W = crate::W<u32, super::COMP_PARAM_2>;
        #[doc = "Register comp_param_2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_PARAM_2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `cnt_rst`"]
        pub type CNT_RST_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `cnt_rst`"]
        pub struct CNT_RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_RST_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - cnt_rst"]
            #[inline(always)]
            pub fn cnt_rst(&self) -> CNT_RST_R {
                CNT_RST_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - cnt_rst"]
            #[inline(always)]
            pub fn cnt_rst(&mut self) -> CNT_RST_W {
                CNT_RST_W { w: self }
            }
        }
    }
    #[doc = "Component Parameters Register 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_param_1](comp_param_1) module"]
    pub type COMP_PARAM_1 = crate::Reg<u32, _COMP_PARAM_1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_PARAM_1;
    #[doc = "`read()` method returns [comp_param_1::R](comp_param_1::R) reader structure"]
    impl crate::Readable for COMP_PARAM_1 {}
    #[doc = "`write(|w| ..)` method takes [comp_param_1::W](comp_param_1::W) writer structure"]
    impl crate::Writable for COMP_PARAM_1 {}
    #[doc = "Component Parameters Register 1"]
    pub mod comp_param_1 {
        #[doc = "Reader of register comp_param_1"]
        pub type R = crate::R<u32, super::COMP_PARAM_1>;
        #[doc = "Writer for register comp_param_1"]
        pub type W = crate::W<u32, super::COMP_PARAM_1>;
        #[doc = "Register comp_param_1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_PARAM_1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `always_en`"]
        pub type ALWAYS_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `always_en`"]
        pub struct ALWAYS_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALWAYS_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `dflt_rmod`"]
        pub type DFLT_RMOD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dflt_rmod`"]
        pub struct DFLT_RMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DFLT_RMOD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `dual_top`"]
        pub type DUAL_TOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dual_top`"]
        pub struct DUAL_TOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DUAL_TOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `hc_rmod`"]
        pub type HC_RMOD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `hc_rmod`"]
        pub struct HC_RMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HC_RMOD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `hc_rpl`"]
        pub type HC_RPL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `hc_rpl`"]
        pub struct HC_RPL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HC_RPL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `hc_top`"]
        pub type HC_TOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `hc_top`"]
        pub struct HC_TOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HC_TOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `use_fix_top`"]
        pub type USE_FIX_TOP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `use_fix_top`"]
        pub struct USE_FIX_TOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USE_FIX_TOP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `pause`"]
        pub type PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pause`"]
        pub struct PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `apb_data_width`"]
        pub type APB_DATA_WIDTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `apb_data_width`"]
        pub struct APB_DATA_WIDTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> APB_DATA_WIDTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `dflt_rpl`"]
        pub type DFLT_RPL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `dflt_rpl`"]
        pub struct DFLT_RPL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DFLT_RPL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 10)) | (((value as u32) & 0x07) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `dflt_top`"]
        pub type DFLT_TOP_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `dflt_top`"]
        pub struct DFLT_TOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DFLT_TOP_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `dflt_top_init`"]
        pub type DFLT_TOP_INIT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `dflt_top_init`"]
        pub struct DFLT_TOP_INIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DFLT_TOP_INIT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | (((value as u32) & 0x0f) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `cnt_width`"]
        pub type CNT_WIDTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `cnt_width`"]
        pub struct CNT_WIDTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_WIDTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 24)) | (((value as u32) & 0x1f) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - always_en"]
            #[inline(always)]
            pub fn always_en(&self) -> ALWAYS_EN_R {
                ALWAYS_EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - dflt_rmod"]
            #[inline(always)]
            pub fn dflt_rmod(&self) -> DFLT_RMOD_R {
                DFLT_RMOD_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - dual_top"]
            #[inline(always)]
            pub fn dual_top(&self) -> DUAL_TOP_R {
                DUAL_TOP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - hc_rmod"]
            #[inline(always)]
            pub fn hc_rmod(&self) -> HC_RMOD_R {
                HC_RMOD_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - hc_rpl"]
            #[inline(always)]
            pub fn hc_rpl(&self) -> HC_RPL_R {
                HC_RPL_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5 - hc_top"]
            #[inline(always)]
            pub fn hc_top(&self) -> HC_TOP_R {
                HC_TOP_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6 - use_fix_top"]
            #[inline(always)]
            pub fn use_fix_top(&self) -> USE_FIX_TOP_R {
                USE_FIX_TOP_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7 - pause"]
            #[inline(always)]
            pub fn pause(&self) -> PAUSE_R {
                PAUSE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bits 8:9 - apb_data_width"]
            #[inline(always)]
            pub fn apb_data_width(&self) -> APB_DATA_WIDTH_R {
                APB_DATA_WIDTH_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bits 10:12 - dflt_rpl"]
            #[inline(always)]
            pub fn dflt_rpl(&self) -> DFLT_RPL_R {
                DFLT_RPL_R::new(((self.bits >> 10) & 0x07) as u8)
            }
            #[doc = "Bits 16:19 - dflt_top"]
            #[inline(always)]
            pub fn dflt_top(&self) -> DFLT_TOP_R {
                DFLT_TOP_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - dflt_top_init"]
            #[inline(always)]
            pub fn dflt_top_init(&self) -> DFLT_TOP_INIT_R {
                DFLT_TOP_INIT_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bits 24:28 - cnt_width"]
            #[inline(always)]
            pub fn cnt_width(&self) -> CNT_WIDTH_R {
                CNT_WIDTH_R::new(((self.bits >> 24) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - always_en"]
            #[inline(always)]
            pub fn always_en(&mut self) -> ALWAYS_EN_W {
                ALWAYS_EN_W { w: self }
            }
            #[doc = "Bit 1 - dflt_rmod"]
            #[inline(always)]
            pub fn dflt_rmod(&mut self) -> DFLT_RMOD_W {
                DFLT_RMOD_W { w: self }
            }
            #[doc = "Bit 2 - dual_top"]
            #[inline(always)]
            pub fn dual_top(&mut self) -> DUAL_TOP_W {
                DUAL_TOP_W { w: self }
            }
            #[doc = "Bit 3 - hc_rmod"]
            #[inline(always)]
            pub fn hc_rmod(&mut self) -> HC_RMOD_W {
                HC_RMOD_W { w: self }
            }
            #[doc = "Bit 4 - hc_rpl"]
            #[inline(always)]
            pub fn hc_rpl(&mut self) -> HC_RPL_W {
                HC_RPL_W { w: self }
            }
            #[doc = "Bit 5 - hc_top"]
            #[inline(always)]
            pub fn hc_top(&mut self) -> HC_TOP_W {
                HC_TOP_W { w: self }
            }
            #[doc = "Bit 6 - use_fix_top"]
            #[inline(always)]
            pub fn use_fix_top(&mut self) -> USE_FIX_TOP_W {
                USE_FIX_TOP_W { w: self }
            }
            #[doc = "Bit 7 - pause"]
            #[inline(always)]
            pub fn pause(&mut self) -> PAUSE_W {
                PAUSE_W { w: self }
            }
            #[doc = "Bits 8:9 - apb_data_width"]
            #[inline(always)]
            pub fn apb_data_width(&mut self) -> APB_DATA_WIDTH_W {
                APB_DATA_WIDTH_W { w: self }
            }
            #[doc = "Bits 10:12 - dflt_rpl"]
            #[inline(always)]
            pub fn dflt_rpl(&mut self) -> DFLT_RPL_W {
                DFLT_RPL_W { w: self }
            }
            #[doc = "Bits 16:19 - dflt_top"]
            #[inline(always)]
            pub fn dflt_top(&mut self) -> DFLT_TOP_W {
                DFLT_TOP_W { w: self }
            }
            #[doc = "Bits 20:23 - dflt_top_init"]
            #[inline(always)]
            pub fn dflt_top_init(&mut self) -> DFLT_TOP_INIT_W {
                DFLT_TOP_INIT_W { w: self }
            }
            #[doc = "Bits 24:28 - cnt_width"]
            #[inline(always)]
            pub fn cnt_width(&mut self) -> CNT_WIDTH_W {
                CNT_WIDTH_W { w: self }
            }
        }
    }
    #[doc = "Component Version Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_version](comp_version) module"]
    pub type COMP_VERSION = crate::Reg<u32, _COMP_VERSION>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_VERSION;
    #[doc = "`read()` method returns [comp_version::R](comp_version::R) reader structure"]
    impl crate::Readable for COMP_VERSION {}
    #[doc = "`write(|w| ..)` method takes [comp_version::W](comp_version::W) writer structure"]
    impl crate::Writable for COMP_VERSION {}
    #[doc = "Component Version Register"]
    pub mod comp_version {
        #[doc = "Reader of register comp_version"]
        pub type R = crate::R<u32, super::COMP_VERSION>;
        #[doc = "Writer for register comp_version"]
        pub type W = crate::W<u32, super::COMP_VERSION>;
        #[doc = "Register comp_version `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_VERSION {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Component Type Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [comp_type](comp_type) module"]
    pub type COMP_TYPE = crate::Reg<u32, _COMP_TYPE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _COMP_TYPE;
    #[doc = "`read()` method returns [comp_type::R](comp_type::R) reader structure"]
    impl crate::Readable for COMP_TYPE {}
    #[doc = "`write(|w| ..)` method takes [comp_type::W](comp_type::W) writer structure"]
    impl crate::Writable for COMP_TYPE {}
    #[doc = "Component Type Register"]
    pub mod comp_type {
        #[doc = "Reader of register comp_type"]
        pub type R = crate::R<u32, super::COMP_TYPE>;
        #[doc = "Writer for register comp_type"]
        pub type W = crate::W<u32, super::COMP_TYPE>;
        #[doc = "Register comp_type `reset()`'s with value 0"]
        impl crate::ResetValue for super::COMP_TYPE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Watchdog Timer 1"]
pub struct WDT1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT1 {}
impl WDT1 {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const wdt0::RegisterBlock {
        0x5041_0000 as *const _
    }
}
impl Deref for WDT1 {
    type Target = wdt0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*WDT1::ptr() }
    }
}
#[doc = "One-Time Programmable Memory Controller"]
pub struct OTP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for OTP {}
impl OTP {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const otp::RegisterBlock {
        0x5042_0000 as *const _
    }
}
impl Deref for OTP {
    type Target = otp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*OTP::ptr() }
    }
}
#[doc = "One-Time Programmable Memory Controller"]
pub mod otp {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Dummy register: this peripheral is not implemented yet"]
        pub dummy: DUMMY,
    }
    #[doc = "Dummy register: this peripheral is not implemented yet\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dummy](dummy) module"]
    pub type DUMMY = crate::Reg<u32, _DUMMY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DUMMY;
    #[doc = "`read()` method returns [dummy::R](dummy::R) reader structure"]
    impl crate::Readable for DUMMY {}
    #[doc = "`write(|w| ..)` method takes [dummy::W](dummy::W) writer structure"]
    impl crate::Writable for DUMMY {}
    #[doc = "Dummy register: this peripheral is not implemented yet"]
    pub mod dummy {
        #[doc = "Reader of register dummy"]
        pub type R = crate::R<u32, super::DUMMY>;
        #[doc = "Writer for register dummy"]
        pub type W = crate::W<u32, super::DUMMY>;
        #[doc = "Register dummy `reset()`'s with value 0"]
        impl crate::ResetValue for super::DUMMY {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Digital Video Port"]
pub struct DVP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DVP {}
impl DVP {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dvp::RegisterBlock {
        0x5043_0000 as *const _
    }
}
impl Deref for DVP {
    type Target = dvp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*DVP::ptr() }
    }
}
#[doc = "Digital Video Port"]
pub mod dvp {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Config Register"]
        pub dvp_cfg: DVP_CFG,
        #[doc = "0x04 - R_ADDR"]
        pub r_addr: R_ADDR,
        #[doc = "0x08 - G_ADDR"]
        pub g_addr: G_ADDR,
        #[doc = "0x0c - B_ADDR"]
        pub b_addr: B_ADDR,
        #[doc = "0x10 - CMOS Config Register"]
        pub cmos_cfg: CMOS_CFG,
        #[doc = "0x14 - SCCB Config Register"]
        pub sccb_cfg: SCCB_CFG,
        #[doc = "0x18 - SCCB Control Register"]
        pub sccb_ctl: SCCB_CTL,
        #[doc = "0x1c - AXI Register"]
        pub axi: AXI,
        #[doc = "0x20 - STS Register"]
        pub sts: STS,
        #[doc = "0x24 - REVERSE"]
        pub reverse: REVERSE,
        #[doc = "0x28 - RGB_ADDR"]
        pub rgb_addr: RGB_ADDR,
    }
    #[doc = "Config Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dvp_cfg](dvp_cfg) module"]
    pub type DVP_CFG = crate::Reg<u32, _DVP_CFG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DVP_CFG;
    #[doc = "`read()` method returns [dvp_cfg::R](dvp_cfg::R) reader structure"]
    impl crate::Readable for DVP_CFG {}
    #[doc = "`write(|w| ..)` method takes [dvp_cfg::W](dvp_cfg::W) writer structure"]
    impl crate::Writable for DVP_CFG {}
    #[doc = "Config Register"]
    pub mod dvp_cfg {
        #[doc = "Reader of register dvp_cfg"]
        pub type R = crate::R<u32, super::DVP_CFG>;
        #[doc = "Writer for register dvp_cfg"]
        pub type W = crate::W<u32, super::DVP_CFG>;
        #[doc = "Register dvp_cfg `reset()`'s with value 0"]
        impl crate::ResetValue for super::DVP_CFG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `start_int_enable`"]
        pub type START_INT_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `start_int_enable`"]
        pub struct START_INT_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> START_INT_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `finish_int_enable`"]
        pub type FINISH_INT_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `finish_int_enable`"]
        pub struct FINISH_INT_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FINISH_INT_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `ai_output_enable`"]
        pub type AI_OUTPUT_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ai_output_enable`"]
        pub struct AI_OUTPUT_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AI_OUTPUT_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `display_output_enable`"]
        pub type DISPLAY_OUTPUT_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `display_output_enable`"]
        pub struct DISPLAY_OUTPUT_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISPLAY_OUTPUT_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `auto_enable`"]
        pub type AUTO_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `auto_enable`"]
        pub struct AUTO_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AUTO_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `burst_size_4beats`"]
        pub type BURST_SIZE_4BEATS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `burst_size_4beats`"]
        pub struct BURST_SIZE_4BEATS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BURST_SIZE_4BEATS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "FORMAT\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum FORMAT_A {
            #[doc = "0: RGB_FORMAT"]
            RGB = 0,
            #[doc = "1: YUV_FORMAT"]
            YUV = 1,
            #[doc = "3: Y_FORMAT"]
            Y = 3,
        }
        impl From<FORMAT_A> for u8 {
            #[inline(always)]
            fn from(variant: FORMAT_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `format`"]
        pub type FORMAT_R = crate::R<u8, FORMAT_A>;
        impl FORMAT_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, FORMAT_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(FORMAT_A::RGB),
                    1 => Val(FORMAT_A::YUV),
                    3 => Val(FORMAT_A::Y),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `RGB`"]
            #[inline(always)]
            pub fn is_rgb(&self) -> bool {
                *self == FORMAT_A::RGB
            }
            #[doc = "Checks if the value of the field is `YUV`"]
            #[inline(always)]
            pub fn is_yuv(&self) -> bool {
                *self == FORMAT_A::YUV
            }
            #[doc = "Checks if the value of the field is `Y`"]
            #[inline(always)]
            pub fn is_y(&self) -> bool {
                *self == FORMAT_A::Y
            }
        }
        #[doc = "Write proxy for field `format`"]
        pub struct FORMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FORMAT_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FORMAT_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "RGB_FORMAT"]
            #[inline(always)]
            pub fn rgb(self) -> &'a mut W {
                self.variant(FORMAT_A::RGB)
            }
            #[doc = "YUV_FORMAT"]
            #[inline(always)]
            pub fn yuv(self) -> &'a mut W {
                self.variant(FORMAT_A::YUV)
            }
            #[doc = "Y_FORMAT"]
            #[inline(always)]
            pub fn y(self) -> &'a mut W {
                self.variant(FORMAT_A::Y)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 9)) | (((value as u32) & 0x03) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `href_burst_num`"]
        pub type HREF_BURST_NUM_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `href_burst_num`"]
        pub struct HREF_BURST_NUM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HREF_BURST_NUM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 12)) | (((value as u32) & 0xff) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `line_num`"]
        pub type LINE_NUM_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `line_num`"]
        pub struct LINE_NUM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LINE_NUM_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03ff << 20)) | (((value as u32) & 0x03ff) << 20);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - START_INT_ENABLE"]
            #[inline(always)]
            pub fn start_int_enable(&self) -> START_INT_ENABLE_R {
                START_INT_ENABLE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - FINISH_INT_ENABLE"]
            #[inline(always)]
            pub fn finish_int_enable(&self) -> FINISH_INT_ENABLE_R {
                FINISH_INT_ENABLE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2 - AI_OUTPUT_ENABLE"]
            #[inline(always)]
            pub fn ai_output_enable(&self) -> AI_OUTPUT_ENABLE_R {
                AI_OUTPUT_ENABLE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3 - DISPLAY_OUTPUT_ENABLE"]
            #[inline(always)]
            pub fn display_output_enable(&self) -> DISPLAY_OUTPUT_ENABLE_R {
                DISPLAY_OUTPUT_ENABLE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4 - AUTO_ENABLE"]
            #[inline(always)]
            pub fn auto_enable(&self) -> AUTO_ENABLE_R {
                AUTO_ENABLE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 8 - BURST_SIZE_4BEATS"]
            #[inline(always)]
            pub fn burst_size_4beats(&self) -> BURST_SIZE_4BEATS_R {
                BURST_SIZE_4BEATS_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bits 9:10 - FORMAT"]
            #[inline(always)]
            pub fn format(&self) -> FORMAT_R {
                FORMAT_R::new(((self.bits >> 9) & 0x03) as u8)
            }
            #[doc = "Bits 12:19 - HREF_BURST_NUM"]
            #[inline(always)]
            pub fn href_burst_num(&self) -> HREF_BURST_NUM_R {
                HREF_BURST_NUM_R::new(((self.bits >> 12) & 0xff) as u8)
            }
            #[doc = "Bits 20:29 - LINE_NUM"]
            #[inline(always)]
            pub fn line_num(&self) -> LINE_NUM_R {
                LINE_NUM_R::new(((self.bits >> 20) & 0x03ff) as u16)
            }
        }
        impl W {
            #[doc = "Bit 0 - START_INT_ENABLE"]
            #[inline(always)]
            pub fn start_int_enable(&mut self) -> START_INT_ENABLE_W {
                START_INT_ENABLE_W { w: self }
            }
            #[doc = "Bit 1 - FINISH_INT_ENABLE"]
            #[inline(always)]
            pub fn finish_int_enable(&mut self) -> FINISH_INT_ENABLE_W {
                FINISH_INT_ENABLE_W { w: self }
            }
            #[doc = "Bit 2 - AI_OUTPUT_ENABLE"]
            #[inline(always)]
            pub fn ai_output_enable(&mut self) -> AI_OUTPUT_ENABLE_W {
                AI_OUTPUT_ENABLE_W { w: self }
            }
            #[doc = "Bit 3 - DISPLAY_OUTPUT_ENABLE"]
            #[inline(always)]
            pub fn display_output_enable(&mut self) -> DISPLAY_OUTPUT_ENABLE_W {
                DISPLAY_OUTPUT_ENABLE_W { w: self }
            }
            #[doc = "Bit 4 - AUTO_ENABLE"]
            #[inline(always)]
            pub fn auto_enable(&mut self) -> AUTO_ENABLE_W {
                AUTO_ENABLE_W { w: self }
            }
            #[doc = "Bit 8 - BURST_SIZE_4BEATS"]
            #[inline(always)]
            pub fn burst_size_4beats(&mut self) -> BURST_SIZE_4BEATS_W {
                BURST_SIZE_4BEATS_W { w: self }
            }
            #[doc = "Bits 9:10 - FORMAT"]
            #[inline(always)]
            pub fn format(&mut self) -> FORMAT_W {
                FORMAT_W { w: self }
            }
            #[doc = "Bits 12:19 - HREF_BURST_NUM"]
            #[inline(always)]
            pub fn href_burst_num(&mut self) -> HREF_BURST_NUM_W {
                HREF_BURST_NUM_W { w: self }
            }
            #[doc = "Bits 20:29 - LINE_NUM"]
            #[inline(always)]
            pub fn line_num(&mut self) -> LINE_NUM_W {
                LINE_NUM_W { w: self }
            }
        }
    }
    #[doc = "R_ADDR\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [r_addr](r_addr) module"]
    pub type R_ADDR = crate::Reg<u32, _R_ADDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _R_ADDR;
    #[doc = "`read()` method returns [r_addr::R](r_addr::R) reader structure"]
    impl crate::Readable for R_ADDR {}
    #[doc = "`write(|w| ..)` method takes [r_addr::W](r_addr::W) writer structure"]
    impl crate::Writable for R_ADDR {}
    #[doc = "R_ADDR"]
    pub mod r_addr {
        #[doc = "Reader of register r_addr"]
        pub type R = crate::R<u32, super::R_ADDR>;
        #[doc = "Writer for register r_addr"]
        pub type W = crate::W<u32, super::R_ADDR>;
        #[doc = "Register r_addr `reset()`'s with value 0"]
        impl crate::ResetValue for super::R_ADDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "G_ADDR\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [g_addr](g_addr) module"]
    pub type G_ADDR = crate::Reg<u32, _G_ADDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _G_ADDR;
    #[doc = "`read()` method returns [g_addr::R](g_addr::R) reader structure"]
    impl crate::Readable for G_ADDR {}
    #[doc = "`write(|w| ..)` method takes [g_addr::W](g_addr::W) writer structure"]
    impl crate::Writable for G_ADDR {}
    #[doc = "G_ADDR"]
    pub mod g_addr {
        #[doc = "Reader of register g_addr"]
        pub type R = crate::R<u32, super::G_ADDR>;
        #[doc = "Writer for register g_addr"]
        pub type W = crate::W<u32, super::G_ADDR>;
        #[doc = "Register g_addr `reset()`'s with value 0"]
        impl crate::ResetValue for super::G_ADDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "B_ADDR\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [b_addr](b_addr) module"]
    pub type B_ADDR = crate::Reg<u32, _B_ADDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _B_ADDR;
    #[doc = "`read()` method returns [b_addr::R](b_addr::R) reader structure"]
    impl crate::Readable for B_ADDR {}
    #[doc = "`write(|w| ..)` method takes [b_addr::W](b_addr::W) writer structure"]
    impl crate::Writable for B_ADDR {}
    #[doc = "B_ADDR"]
    pub mod b_addr {
        #[doc = "Reader of register b_addr"]
        pub type R = crate::R<u32, super::B_ADDR>;
        #[doc = "Writer for register b_addr"]
        pub type W = crate::W<u32, super::B_ADDR>;
        #[doc = "Register b_addr `reset()`'s with value 0"]
        impl crate::ResetValue for super::B_ADDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "CMOS Config Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [cmos_cfg](cmos_cfg) module"]
    pub type CMOS_CFG = crate::Reg<u32, _CMOS_CFG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CMOS_CFG;
    #[doc = "`read()` method returns [cmos_cfg::R](cmos_cfg::R) reader structure"]
    impl crate::Readable for CMOS_CFG {}
    #[doc = "`write(|w| ..)` method takes [cmos_cfg::W](cmos_cfg::W) writer structure"]
    impl crate::Writable for CMOS_CFG {}
    #[doc = "CMOS Config Register"]
    pub mod cmos_cfg {
        #[doc = "Reader of register cmos_cfg"]
        pub type R = crate::R<u32, super::CMOS_CFG>;
        #[doc = "Writer for register cmos_cfg"]
        pub type W = crate::W<u32, super::CMOS_CFG>;
        #[doc = "Register cmos_cfg `reset()`'s with value 0"]
        impl crate::ResetValue for super::CMOS_CFG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `clk_div`"]
        pub type CLK_DIV_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clk_div`"]
        pub struct CLK_DIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLK_DIV_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `clk_enable`"]
        pub type CLK_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `clk_enable`"]
        pub struct CLK_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLK_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `reset`"]
        pub type RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `reset`"]
        pub struct RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `power_down`"]
        pub type POWER_DOWN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_down`"]
        pub struct POWER_DOWN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_DOWN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - CLK_DIV"]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIV_R {
                CLK_DIV_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 8 - CLK_ENABLE"]
            #[inline(always)]
            pub fn clk_enable(&self) -> CLK_ENABLE_R {
                CLK_ENABLE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 16 - RESET"]
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 24 - POWER_DOWN"]
            #[inline(always)]
            pub fn power_down(&self) -> POWER_DOWN_R {
                POWER_DOWN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - CLK_DIV"]
            #[inline(always)]
            pub fn clk_div(&mut self) -> CLK_DIV_W {
                CLK_DIV_W { w: self }
            }
            #[doc = "Bit 8 - CLK_ENABLE"]
            #[inline(always)]
            pub fn clk_enable(&mut self) -> CLK_ENABLE_W {
                CLK_ENABLE_W { w: self }
            }
            #[doc = "Bit 16 - RESET"]
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W {
                RESET_W { w: self }
            }
            #[doc = "Bit 24 - POWER_DOWN"]
            #[inline(always)]
            pub fn power_down(&mut self) -> POWER_DOWN_W {
                POWER_DOWN_W { w: self }
            }
        }
    }
    #[doc = "SCCB Config Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccb_cfg](sccb_cfg) module"]
    pub type SCCB_CFG = crate::Reg<u32, _SCCB_CFG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SCCB_CFG;
    #[doc = "`read()` method returns [sccb_cfg::R](sccb_cfg::R) reader structure"]
    impl crate::Readable for SCCB_CFG {}
    #[doc = "`write(|w| ..)` method takes [sccb_cfg::W](sccb_cfg::W) writer structure"]
    impl crate::Writable for SCCB_CFG {}
    #[doc = "SCCB Config Register"]
    pub mod sccb_cfg {
        #[doc = "Reader of register sccb_cfg"]
        pub type R = crate::R<u32, super::SCCB_CFG>;
        #[doc = "Writer for register sccb_cfg"]
        pub type W = crate::W<u32, super::SCCB_CFG>;
        #[doc = "Register sccb_cfg `reset()`'s with value 0"]
        impl crate::ResetValue for super::SCCB_CFG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "BYTE_NUM\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum BYTE_NUM_A {
            #[doc = "1: BYTE_NUM_2"]
            NUM2 = 1,
            #[doc = "2: BYTE_NUM_3"]
            NUM3 = 2,
            #[doc = "3: BYTE_NUM_4"]
            NUM4 = 3,
        }
        impl From<BYTE_NUM_A> for u8 {
            #[inline(always)]
            fn from(variant: BYTE_NUM_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `byte_num`"]
        pub type BYTE_NUM_R = crate::R<u8, BYTE_NUM_A>;
        impl BYTE_NUM_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, BYTE_NUM_A> {
                use crate::Variant::*;
                match self.bits {
                    1 => Val(BYTE_NUM_A::NUM2),
                    2 => Val(BYTE_NUM_A::NUM3),
                    3 => Val(BYTE_NUM_A::NUM4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `NUM2`"]
            #[inline(always)]
            pub fn is_num2(&self) -> bool {
                *self == BYTE_NUM_A::NUM2
            }
            #[doc = "Checks if the value of the field is `NUM3`"]
            #[inline(always)]
            pub fn is_num3(&self) -> bool {
                *self == BYTE_NUM_A::NUM3
            }
            #[doc = "Checks if the value of the field is `NUM4`"]
            #[inline(always)]
            pub fn is_num4(&self) -> bool {
                *self == BYTE_NUM_A::NUM4
            }
        }
        #[doc = "Write proxy for field `byte_num`"]
        pub struct BYTE_NUM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BYTE_NUM_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BYTE_NUM_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "BYTE_NUM_2"]
            #[inline(always)]
            pub fn num2(self) -> &'a mut W {
                self.variant(BYTE_NUM_A::NUM2)
            }
            #[doc = "BYTE_NUM_3"]
            #[inline(always)]
            pub fn num3(self) -> &'a mut W {
                self.variant(BYTE_NUM_A::NUM3)
            }
            #[doc = "BYTE_NUM_4"]
            #[inline(always)]
            pub fn num4(self) -> &'a mut W {
                self.variant(BYTE_NUM_A::NUM4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Reader of field `scl_lcnt`"]
        pub type SCL_LCNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `scl_lcnt`"]
        pub struct SCL_LCNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCL_LCNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `scl_hcnt`"]
        pub type SCL_HCNT_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `scl_hcnt`"]
        pub struct SCL_HCNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCL_HCNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `rdata`"]
        pub type RDATA_R = crate::R<u8, u8>;
        impl R {
            #[doc = "Bits 0:1 - BYTE_NUM"]
            #[inline(always)]
            pub fn byte_num(&self) -> BYTE_NUM_R {
                BYTE_NUM_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bits 8:15 - SCL_LCNT"]
            #[inline(always)]
            pub fn scl_lcnt(&self) -> SCL_LCNT_R {
                SCL_LCNT_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - SCL_HCNT"]
            #[inline(always)]
            pub fn scl_hcnt(&self) -> SCL_HCNT_R {
                SCL_HCNT_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - RDATA"]
            #[inline(always)]
            pub fn rdata(&self) -> RDATA_R {
                RDATA_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - BYTE_NUM"]
            #[inline(always)]
            pub fn byte_num(&mut self) -> BYTE_NUM_W {
                BYTE_NUM_W { w: self }
            }
            #[doc = "Bits 8:15 - SCL_LCNT"]
            #[inline(always)]
            pub fn scl_lcnt(&mut self) -> SCL_LCNT_W {
                SCL_LCNT_W { w: self }
            }
            #[doc = "Bits 16:23 - SCL_HCNT"]
            #[inline(always)]
            pub fn scl_hcnt(&mut self) -> SCL_HCNT_W {
                SCL_HCNT_W { w: self }
            }
        }
    }
    #[doc = "SCCB Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sccb_ctl](sccb_ctl) module"]
    pub type SCCB_CTL = crate::Reg<u32, _SCCB_CTL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SCCB_CTL;
    #[doc = "`read()` method returns [sccb_ctl::R](sccb_ctl::R) reader structure"]
    impl crate::Readable for SCCB_CTL {}
    #[doc = "`write(|w| ..)` method takes [sccb_ctl::W](sccb_ctl::W) writer structure"]
    impl crate::Writable for SCCB_CTL {}
    #[doc = "SCCB Control Register"]
    pub mod sccb_ctl {
        #[doc = "Reader of register sccb_ctl"]
        pub type R = crate::R<u32, super::SCCB_CTL>;
        #[doc = "Writer for register sccb_ctl"]
        pub type W = crate::W<u32, super::SCCB_CTL>;
        #[doc = "Register sccb_ctl `reset()`'s with value 0"]
        impl crate::ResetValue for super::SCCB_CTL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `device_address`"]
        pub type DEVICE_ADDRESS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `device_address`"]
        pub struct DEVICE_ADDRESS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEVICE_ADDRESS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `reg_address`"]
        pub type REG_ADDRESS_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `reg_address`"]
        pub struct REG_ADDRESS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REG_ADDRESS_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `wdata_byte0`"]
        pub type WDATA_BYTE0_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `wdata_byte0`"]
        pub struct WDATA_BYTE0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDATA_BYTE0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `wdata_byte1`"]
        pub type WDATA_BYTE1_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `wdata_byte1`"]
        pub struct WDATA_BYTE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDATA_BYTE1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - DEVICE_ADDRESS"]
            #[inline(always)]
            pub fn device_address(&self) -> DEVICE_ADDRESS_R {
                DEVICE_ADDRESS_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - REG_ADDRESS"]
            #[inline(always)]
            pub fn reg_address(&self) -> REG_ADDRESS_R {
                REG_ADDRESS_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - WDATA_BYTE0"]
            #[inline(always)]
            pub fn wdata_byte0(&self) -> WDATA_BYTE0_R {
                WDATA_BYTE0_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - WDATA_BYTE1"]
            #[inline(always)]
            pub fn wdata_byte1(&self) -> WDATA_BYTE1_R {
                WDATA_BYTE1_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - DEVICE_ADDRESS"]
            #[inline(always)]
            pub fn device_address(&mut self) -> DEVICE_ADDRESS_W {
                DEVICE_ADDRESS_W { w: self }
            }
            #[doc = "Bits 8:15 - REG_ADDRESS"]
            #[inline(always)]
            pub fn reg_address(&mut self) -> REG_ADDRESS_W {
                REG_ADDRESS_W { w: self }
            }
            #[doc = "Bits 16:23 - WDATA_BYTE0"]
            #[inline(always)]
            pub fn wdata_byte0(&mut self) -> WDATA_BYTE0_W {
                WDATA_BYTE0_W { w: self }
            }
            #[doc = "Bits 24:31 - WDATA_BYTE1"]
            #[inline(always)]
            pub fn wdata_byte1(&mut self) -> WDATA_BYTE1_W {
                WDATA_BYTE1_W { w: self }
            }
        }
    }
    #[doc = "AXI Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [axi](axi) module"]
    pub type AXI = crate::Reg<u32, _AXI>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AXI;
    #[doc = "`read()` method returns [axi::R](axi::R) reader structure"]
    impl crate::Readable for AXI {}
    #[doc = "`write(|w| ..)` method takes [axi::W](axi::W) writer structure"]
    impl crate::Writable for AXI {}
    #[doc = "AXI Register"]
    pub mod axi {
        #[doc = "Reader of register axi"]
        pub type R = crate::R<u32, super::AXI>;
        #[doc = "Writer for register axi"]
        pub type W = crate::W<u32, super::AXI>;
        #[doc = "Register axi `reset()`'s with value 0"]
        impl crate::ResetValue for super::AXI {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "GM_MLEN\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum GM_MLEN_A {
            #[doc = "0: GM_MLEN_1BYTE"]
            BYTE1 = 0,
            #[doc = "3: GM_MLEN_4BYTE"]
            BYTE4 = 3,
        }
        impl From<GM_MLEN_A> for u8 {
            #[inline(always)]
            fn from(variant: GM_MLEN_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `gm_mlen`"]
        pub type GM_MLEN_R = crate::R<u8, GM_MLEN_A>;
        impl GM_MLEN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, GM_MLEN_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(GM_MLEN_A::BYTE1),
                    3 => Val(GM_MLEN_A::BYTE4),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `BYTE1`"]
            #[inline(always)]
            pub fn is_byte1(&self) -> bool {
                *self == GM_MLEN_A::BYTE1
            }
            #[doc = "Checks if the value of the field is `BYTE4`"]
            #[inline(always)]
            pub fn is_byte4(&self) -> bool {
                *self == GM_MLEN_A::BYTE4
            }
        }
        #[doc = "Write proxy for field `gm_mlen`"]
        pub struct GM_MLEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GM_MLEN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GM_MLEN_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "GM_MLEN_1BYTE"]
            #[inline(always)]
            pub fn byte1(self) -> &'a mut W {
                self.variant(GM_MLEN_A::BYTE1)
            }
            #[doc = "GM_MLEN_4BYTE"]
            #[inline(always)]
            pub fn byte4(self) -> &'a mut W {
                self.variant(GM_MLEN_A::BYTE4)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7 - GM_MLEN"]
            #[inline(always)]
            pub fn gm_mlen(&self) -> GM_MLEN_R {
                GM_MLEN_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GM_MLEN"]
            #[inline(always)]
            pub fn gm_mlen(&mut self) -> GM_MLEN_W {
                GM_MLEN_W { w: self }
            }
        }
    }
    #[doc = "STS Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [sts](sts) module"]
    pub type STS = crate::Reg<u32, _STS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _STS;
    #[doc = "`read()` method returns [sts::R](sts::R) reader structure"]
    impl crate::Readable for STS {}
    #[doc = "`write(|w| ..)` method takes [sts::W](sts::W) writer structure"]
    impl crate::Writable for STS {}
    #[doc = "STS Register"]
    pub mod sts {
        #[doc = "Reader of register sts"]
        pub type R = crate::R<u32, super::STS>;
        #[doc = "Writer for register sts"]
        pub type W = crate::W<u32, super::STS>;
        #[doc = "Register sts `reset()`'s with value 0"]
        impl crate::ResetValue for super::STS {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `frame_start`"]
        pub type FRAME_START_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `frame_start`"]
        pub struct FRAME_START_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FRAME_START_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `frame_start_we`"]
        pub type FRAME_START_WE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `frame_start_we`"]
        pub struct FRAME_START_WE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FRAME_START_WE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `frame_finish`"]
        pub type FRAME_FINISH_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `frame_finish`"]
        pub struct FRAME_FINISH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FRAME_FINISH_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `frame_finish_we`"]
        pub type FRAME_FINISH_WE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `frame_finish_we`"]
        pub struct FRAME_FINISH_WE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FRAME_FINISH_WE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `dvp_en`"]
        pub type DVP_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dvp_en`"]
        pub struct DVP_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DVP_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `dvp_en_we`"]
        pub type DVP_EN_WE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dvp_en_we`"]
        pub struct DVP_EN_WE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DVP_EN_WE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Reader of field `sccb_en`"]
        pub type SCCB_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sccb_en`"]
        pub struct SCCB_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCCB_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `sccb_en_we`"]
        pub type SCCB_EN_WE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sccb_en_we`"]
        pub struct SCCB_EN_WE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCCB_EN_WE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - FRAME_START"]
            #[inline(always)]
            pub fn frame_start(&self) -> FRAME_START_R {
                FRAME_START_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - FRAME_START_WE"]
            #[inline(always)]
            pub fn frame_start_we(&self) -> FRAME_START_WE_R {
                FRAME_START_WE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 8 - FRAME_FINISH"]
            #[inline(always)]
            pub fn frame_finish(&self) -> FRAME_FINISH_R {
                FRAME_FINISH_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9 - FRAME_FINISH_WE"]
            #[inline(always)]
            pub fn frame_finish_we(&self) -> FRAME_FINISH_WE_R {
                FRAME_FINISH_WE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 16 - DVP_EN"]
            #[inline(always)]
            pub fn dvp_en(&self) -> DVP_EN_R {
                DVP_EN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17 - DVP_EN_WE"]
            #[inline(always)]
            pub fn dvp_en_we(&self) -> DVP_EN_WE_R {
                DVP_EN_WE_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 24 - SCCB_EN"]
            #[inline(always)]
            pub fn sccb_en(&self) -> SCCB_EN_R {
                SCCB_EN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25 - SCCB_EN_WE"]
            #[inline(always)]
            pub fn sccb_en_we(&self) -> SCCB_EN_WE_R {
                SCCB_EN_WE_R::new(((self.bits >> 25) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - FRAME_START"]
            #[inline(always)]
            pub fn frame_start(&mut self) -> FRAME_START_W {
                FRAME_START_W { w: self }
            }
            #[doc = "Bit 1 - FRAME_START_WE"]
            #[inline(always)]
            pub fn frame_start_we(&mut self) -> FRAME_START_WE_W {
                FRAME_START_WE_W { w: self }
            }
            #[doc = "Bit 8 - FRAME_FINISH"]
            #[inline(always)]
            pub fn frame_finish(&mut self) -> FRAME_FINISH_W {
                FRAME_FINISH_W { w: self }
            }
            #[doc = "Bit 9 - FRAME_FINISH_WE"]
            #[inline(always)]
            pub fn frame_finish_we(&mut self) -> FRAME_FINISH_WE_W {
                FRAME_FINISH_WE_W { w: self }
            }
            #[doc = "Bit 16 - DVP_EN"]
            #[inline(always)]
            pub fn dvp_en(&mut self) -> DVP_EN_W {
                DVP_EN_W { w: self }
            }
            #[doc = "Bit 17 - DVP_EN_WE"]
            #[inline(always)]
            pub fn dvp_en_we(&mut self) -> DVP_EN_WE_W {
                DVP_EN_WE_W { w: self }
            }
            #[doc = "Bit 24 - SCCB_EN"]
            #[inline(always)]
            pub fn sccb_en(&mut self) -> SCCB_EN_W {
                SCCB_EN_W { w: self }
            }
            #[doc = "Bit 25 - SCCB_EN_WE"]
            #[inline(always)]
            pub fn sccb_en_we(&mut self) -> SCCB_EN_WE_W {
                SCCB_EN_WE_W { w: self }
            }
        }
    }
    #[doc = "REVERSE\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reverse](reverse) module"]
    pub type REVERSE = crate::Reg<u32, _REVERSE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _REVERSE;
    #[doc = "`read()` method returns [reverse::R](reverse::R) reader structure"]
    impl crate::Readable for REVERSE {}
    #[doc = "`write(|w| ..)` method takes [reverse::W](reverse::W) writer structure"]
    impl crate::Writable for REVERSE {}
    #[doc = "REVERSE"]
    pub mod reverse {
        #[doc = "Reader of register reverse"]
        pub type R = crate::R<u32, super::REVERSE>;
        #[doc = "Writer for register reverse"]
        pub type W = crate::W<u32, super::REVERSE>;
        #[doc = "Register reverse `reset()`'s with value 0"]
        impl crate::ResetValue for super::REVERSE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "RGB_ADDR\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rgb_addr](rgb_addr) module"]
    pub type RGB_ADDR = crate::Reg<u32, _RGB_ADDR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RGB_ADDR;
    #[doc = "`read()` method returns [rgb_addr::R](rgb_addr::R) reader structure"]
    impl crate::Readable for RGB_ADDR {}
    #[doc = "`write(|w| ..)` method takes [rgb_addr::W](rgb_addr::W) writer structure"]
    impl crate::Writable for RGB_ADDR {}
    #[doc = "RGB_ADDR"]
    pub mod rgb_addr {
        #[doc = "Reader of register rgb_addr"]
        pub type R = crate::R<u32, super::RGB_ADDR>;
        #[doc = "Writer for register rgb_addr"]
        pub type W = crate::W<u32, super::RGB_ADDR>;
        #[doc = "Register rgb_addr `reset()`'s with value 0"]
        impl crate::ResetValue for super::RGB_ADDR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "System Controller"]
pub struct SYSCTL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSCTL {}
impl SYSCTL {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sysctl::RegisterBlock {
        0x5044_0000 as *const _
    }
}
impl Deref for SYSCTL {
    type Target = sysctl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*SYSCTL::ptr() }
    }
}
#[doc = "System Controller"]
pub mod sysctl {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Git short commit id"]
        pub git_id: GIT_ID,
        #[doc = "0x04 - System clock base frequency"]
        pub clk_freq: CLK_FREQ,
        #[doc = "0x08 - PLL0 controller"]
        pub pll0: PLL0,
        #[doc = "0x0c - PLL1 controller"]
        pub pll1: PLL1,
        #[doc = "0x10 - PLL2 controller"]
        pub pll2: PLL2,
        _reserved5: [u8; 4usize],
        #[doc = "0x18 - PLL lock tester"]
        pub pll_lock: PLL_LOCK,
        #[doc = "0x1c - AXI ROM detector"]
        pub rom_error: ROM_ERROR,
        #[doc = "0x20 - Clock select controller 0"]
        pub clk_sel0: CLK_SEL0,
        #[doc = "0x24 - Clock select controller 1"]
        pub clk_sel1: CLK_SEL1,
        #[doc = "0x28 - Central clock enable"]
        pub clk_en_cent: CLK_EN_CENT,
        #[doc = "0x2c - Peripheral clock enable"]
        pub clk_en_peri: CLK_EN_PERI,
        #[doc = "0x30 - Soft reset ctrl"]
        pub soft_reset: SOFT_RESET,
        #[doc = "0x34 - Peripheral reset controller"]
        pub peri_reset: PERI_RESET,
        #[doc = "0x38 - Clock threshold controller 0"]
        pub clk_th0: CLK_TH0,
        #[doc = "0x3c - Clock threshold controller 1"]
        pub clk_th1: CLK_TH1,
        #[doc = "0x40 - Clock threshold controller 2"]
        pub clk_th2: CLK_TH2,
        #[doc = "0x44 - Clock threshold controller 3"]
        pub clk_th3: CLK_TH3,
        #[doc = "0x48 - Clock threshold controller 4"]
        pub clk_th4: CLK_TH4,
        #[doc = "0x4c - Clock threshold controller 5"]
        pub clk_th5: CLK_TH5,
        #[doc = "0x50 - Clock threshold controller 6"]
        pub clk_th6: CLK_TH6,
        #[doc = "0x54 - Miscellaneous controller"]
        pub misc: MISC,
        #[doc = "0x58 - Peripheral controller"]
        pub peri: PERI,
        #[doc = "0x5c - SPI sleep controller"]
        pub spi_sleep: SPI_SLEEP,
        #[doc = "0x60 - Reset source status"]
        pub reset_status: RESET_STATUS,
        #[doc = "0x64 - DMA handshake selector"]
        pub dma_sel0: DMA_SEL0,
        #[doc = "0x68 - DMA handshake selector"]
        pub dma_sel1: DMA_SEL1,
        #[doc = "0x6c - IO Power Mode Select controller"]
        pub power_sel: POWER_SEL,
    }
    #[doc = "Git short commit id\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [git_id](git_id) module"]
    pub type GIT_ID = crate::Reg<u32, _GIT_ID>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _GIT_ID;
    #[doc = "`read()` method returns [git_id::R](git_id::R) reader structure"]
    impl crate::Readable for GIT_ID {}
    #[doc = "`write(|w| ..)` method takes [git_id::W](git_id::W) writer structure"]
    impl crate::Writable for GIT_ID {}
    #[doc = "Git short commit id"]
    pub mod git_id {
        #[doc = "Reader of register git_id"]
        pub type R = crate::R<u32, super::GIT_ID>;
        #[doc = "Writer for register git_id"]
        pub type W = crate::W<u32, super::GIT_ID>;
        #[doc = "Register git_id `reset()`'s with value 0"]
        impl crate::ResetValue for super::GIT_ID {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "System clock base frequency\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_freq](clk_freq) module"]
    pub type CLK_FREQ = crate::Reg<u32, _CLK_FREQ>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_FREQ;
    #[doc = "`read()` method returns [clk_freq::R](clk_freq::R) reader structure"]
    impl crate::Readable for CLK_FREQ {}
    #[doc = "`write(|w| ..)` method takes [clk_freq::W](clk_freq::W) writer structure"]
    impl crate::Writable for CLK_FREQ {}
    #[doc = "System clock base frequency"]
    pub mod clk_freq {
        #[doc = "Reader of register clk_freq"]
        pub type R = crate::R<u32, super::CLK_FREQ>;
        #[doc = "Writer for register clk_freq"]
        pub type W = crate::W<u32, super::CLK_FREQ>;
        #[doc = "Register clk_freq `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_FREQ {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "PLL0 controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pll0](pll0) module"]
    pub type PLL0 = crate::Reg<u32, _PLL0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PLL0;
    #[doc = "`read()` method returns [pll0::R](pll0::R) reader structure"]
    impl crate::Readable for PLL0 {}
    #[doc = "`write(|w| ..)` method takes [pll0::W](pll0::W) writer structure"]
    impl crate::Writable for PLL0 {}
    #[doc = "PLL0 controller"]
    pub mod pll0 {
        #[doc = "Reader of register pll0"]
        pub type R = crate::R<u32, super::PLL0>;
        #[doc = "Writer for register pll0"]
        pub type W = crate::W<u32, super::PLL0>;
        #[doc = "Register pll0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::PLL0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `clkr`"]
        pub type CLKR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkr`"]
        pub struct CLKR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `clkf`"]
        pub type CLKF_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkf`"]
        pub struct CLKF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKF_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 4)) | (((value as u32) & 0x3f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `clkod`"]
        pub type CLKOD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkod`"]
        pub struct CLKOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKOD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 10)) | (((value as u32) & 0x0f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `bwadj`"]
        pub type BWADJ_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `bwadj`"]
        pub struct BWADJ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BWADJ_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 14)) | (((value as u32) & 0x3f) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `reset`"]
        pub type RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `reset`"]
        pub struct RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `pwrd`"]
        pub type PWRD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pwrd`"]
        pub struct PWRD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWRD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `intfb`"]
        pub type INTFB_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `intfb`"]
        pub struct INTFB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INTFB_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `bypass`"]
        pub type BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `bypass`"]
        pub struct BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `test`"]
        pub type TEST_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `test`"]
        pub struct TEST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `out_en`"]
        pub type OUT_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `out_en`"]
        pub struct OUT_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OUT_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Reader of field `test_en`"]
        pub type TEST_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `test_en`"]
        pub struct TEST_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEST_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn clkr(&self) -> CLKR_R {
                CLKR_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:9"]
            #[inline(always)]
            pub fn clkf(&self) -> CLKF_R {
                CLKF_R::new(((self.bits >> 4) & 0x3f) as u8)
            }
            #[doc = "Bits 10:13"]
            #[inline(always)]
            pub fn clkod(&self) -> CLKOD_R {
                CLKOD_R::new(((self.bits >> 10) & 0x0f) as u8)
            }
            #[doc = "Bits 14:19"]
            #[inline(always)]
            pub fn bwadj(&self) -> BWADJ_R {
                BWADJ_R::new(((self.bits >> 14) & 0x3f) as u8)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pwrd(&self) -> PWRD_R {
                PWRD_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn intfb(&self) -> INTFB_R {
                INTFB_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn bypass(&self) -> BYPASS_R {
                BYPASS_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn test(&self) -> TEST_R {
                TEST_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn out_en(&self) -> OUT_EN_R {
                OUT_EN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn test_en(&self) -> TEST_EN_R {
                TEST_EN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn clkr(&mut self) -> CLKR_W {
                CLKR_W { w: self }
            }
            #[doc = "Bits 4:9"]
            #[inline(always)]
            pub fn clkf(&mut self) -> CLKF_W {
                CLKF_W { w: self }
            }
            #[doc = "Bits 10:13"]
            #[inline(always)]
            pub fn clkod(&mut self) -> CLKOD_W {
                CLKOD_W { w: self }
            }
            #[doc = "Bits 14:19"]
            #[inline(always)]
            pub fn bwadj(&mut self) -> BWADJ_W {
                BWADJ_W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W {
                RESET_W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pwrd(&mut self) -> PWRD_W {
                PWRD_W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn intfb(&mut self) -> INTFB_W {
                INTFB_W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn bypass(&mut self) -> BYPASS_W {
                BYPASS_W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn test(&mut self) -> TEST_W {
                TEST_W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn out_en(&mut self) -> OUT_EN_W {
                OUT_EN_W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn test_en(&mut self) -> TEST_EN_W {
                TEST_EN_W { w: self }
            }
        }
    }
    #[doc = "PLL1 controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pll1](pll1) module"]
    pub type PLL1 = crate::Reg<u32, _PLL1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PLL1;
    #[doc = "`read()` method returns [pll1::R](pll1::R) reader structure"]
    impl crate::Readable for PLL1 {}
    #[doc = "`write(|w| ..)` method takes [pll1::W](pll1::W) writer structure"]
    impl crate::Writable for PLL1 {}
    #[doc = "PLL1 controller"]
    pub mod pll1 {
        #[doc = "Reader of register pll1"]
        pub type R = crate::R<u32, super::PLL1>;
        #[doc = "Writer for register pll1"]
        pub type W = crate::W<u32, super::PLL1>;
        #[doc = "Register pll1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::PLL1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `clkr`"]
        pub type CLKR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkr`"]
        pub struct CLKR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `clkf`"]
        pub type CLKF_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkf`"]
        pub struct CLKF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKF_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 4)) | (((value as u32) & 0x3f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `clkod`"]
        pub type CLKOD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkod`"]
        pub struct CLKOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKOD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 10)) | (((value as u32) & 0x0f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `bwadj`"]
        pub type BWADJ_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `bwadj`"]
        pub struct BWADJ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BWADJ_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 14)) | (((value as u32) & 0x3f) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `reset`"]
        pub type RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `reset`"]
        pub struct RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `pwrd`"]
        pub type PWRD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pwrd`"]
        pub struct PWRD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWRD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `intfb`"]
        pub type INTFB_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `intfb`"]
        pub struct INTFB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INTFB_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `bypass`"]
        pub type BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `bypass`"]
        pub struct BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `test`"]
        pub type TEST_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `test`"]
        pub struct TEST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `out_en`"]
        pub type OUT_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `out_en`"]
        pub struct OUT_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OUT_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn clkr(&self) -> CLKR_R {
                CLKR_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:9"]
            #[inline(always)]
            pub fn clkf(&self) -> CLKF_R {
                CLKF_R::new(((self.bits >> 4) & 0x3f) as u8)
            }
            #[doc = "Bits 10:13"]
            #[inline(always)]
            pub fn clkod(&self) -> CLKOD_R {
                CLKOD_R::new(((self.bits >> 10) & 0x0f) as u8)
            }
            #[doc = "Bits 14:19"]
            #[inline(always)]
            pub fn bwadj(&self) -> BWADJ_R {
                BWADJ_R::new(((self.bits >> 14) & 0x3f) as u8)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pwrd(&self) -> PWRD_R {
                PWRD_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn intfb(&self) -> INTFB_R {
                INTFB_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn bypass(&self) -> BYPASS_R {
                BYPASS_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn test(&self) -> TEST_R {
                TEST_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn out_en(&self) -> OUT_EN_R {
                OUT_EN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn clkr(&mut self) -> CLKR_W {
                CLKR_W { w: self }
            }
            #[doc = "Bits 4:9"]
            #[inline(always)]
            pub fn clkf(&mut self) -> CLKF_W {
                CLKF_W { w: self }
            }
            #[doc = "Bits 10:13"]
            #[inline(always)]
            pub fn clkod(&mut self) -> CLKOD_W {
                CLKOD_W { w: self }
            }
            #[doc = "Bits 14:19"]
            #[inline(always)]
            pub fn bwadj(&mut self) -> BWADJ_W {
                BWADJ_W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W {
                RESET_W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pwrd(&mut self) -> PWRD_W {
                PWRD_W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn intfb(&mut self) -> INTFB_W {
                INTFB_W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn bypass(&mut self) -> BYPASS_W {
                BYPASS_W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn test(&mut self) -> TEST_W {
                TEST_W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn out_en(&mut self) -> OUT_EN_W {
                OUT_EN_W { w: self }
            }
        }
    }
    #[doc = "PLL2 controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pll2](pll2) module"]
    pub type PLL2 = crate::Reg<u32, _PLL2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PLL2;
    #[doc = "`read()` method returns [pll2::R](pll2::R) reader structure"]
    impl crate::Readable for PLL2 {}
    #[doc = "`write(|w| ..)` method takes [pll2::W](pll2::W) writer structure"]
    impl crate::Writable for PLL2 {}
    #[doc = "PLL2 controller"]
    pub mod pll2 {
        #[doc = "Reader of register pll2"]
        pub type R = crate::R<u32, super::PLL2>;
        #[doc = "Writer for register pll2"]
        pub type W = crate::W<u32, super::PLL2>;
        #[doc = "Register pll2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::PLL2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `clkr`"]
        pub type CLKR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkr`"]
        pub struct CLKR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `clkf`"]
        pub type CLKF_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkf`"]
        pub struct CLKF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKF_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 4)) | (((value as u32) & 0x3f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `clkod`"]
        pub type CLKOD_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `clkod`"]
        pub struct CLKOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKOD_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 10)) | (((value as u32) & 0x0f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `bwadj`"]
        pub type BWADJ_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `bwadj`"]
        pub struct BWADJ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BWADJ_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 14)) | (((value as u32) & 0x3f) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `reset`"]
        pub type RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `reset`"]
        pub struct RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `pwrd`"]
        pub type PWRD_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pwrd`"]
        pub struct PWRD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWRD_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `intfb`"]
        pub type INTFB_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `intfb`"]
        pub struct INTFB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INTFB_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `bypass`"]
        pub type BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `bypass`"]
        pub struct BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `test`"]
        pub type TEST_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `test`"]
        pub struct TEST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEST_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `out_en`"]
        pub type OUT_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `out_en`"]
        pub struct OUT_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OUT_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Reader of field `ckin_sel`"]
        pub type CKIN_SEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ckin_sel`"]
        pub struct CKIN_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKIN_SEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | (((value as u32) & 0x03) << 26);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn clkr(&self) -> CLKR_R {
                CLKR_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:9"]
            #[inline(always)]
            pub fn clkf(&self) -> CLKF_R {
                CLKF_R::new(((self.bits >> 4) & 0x3f) as u8)
            }
            #[doc = "Bits 10:13"]
            #[inline(always)]
            pub fn clkod(&self) -> CLKOD_R {
                CLKOD_R::new(((self.bits >> 10) & 0x0f) as u8)
            }
            #[doc = "Bits 14:19"]
            #[inline(always)]
            pub fn bwadj(&self) -> BWADJ_R {
                BWADJ_R::new(((self.bits >> 14) & 0x3f) as u8)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn reset(&self) -> RESET_R {
                RESET_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pwrd(&self) -> PWRD_R {
                PWRD_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn intfb(&self) -> INTFB_R {
                INTFB_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn bypass(&self) -> BYPASS_R {
                BYPASS_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn test(&self) -> TEST_R {
                TEST_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn out_en(&self) -> OUT_EN_R {
                OUT_EN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bits 26:27"]
            #[inline(always)]
            pub fn ckin_sel(&self) -> CKIN_SEL_R {
                CKIN_SEL_R::new(((self.bits >> 26) & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn clkr(&mut self) -> CLKR_W {
                CLKR_W { w: self }
            }
            #[doc = "Bits 4:9"]
            #[inline(always)]
            pub fn clkf(&mut self) -> CLKF_W {
                CLKF_W { w: self }
            }
            #[doc = "Bits 10:13"]
            #[inline(always)]
            pub fn clkod(&mut self) -> CLKOD_W {
                CLKOD_W { w: self }
            }
            #[doc = "Bits 14:19"]
            #[inline(always)]
            pub fn bwadj(&mut self) -> BWADJ_W {
                BWADJ_W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W {
                RESET_W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn pwrd(&mut self) -> PWRD_W {
                PWRD_W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn intfb(&mut self) -> INTFB_W {
                INTFB_W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn bypass(&mut self) -> BYPASS_W {
                BYPASS_W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn test(&mut self) -> TEST_W {
                TEST_W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn out_en(&mut self) -> OUT_EN_W {
                OUT_EN_W { w: self }
            }
            #[doc = "Bits 26:27"]
            #[inline(always)]
            pub fn ckin_sel(&mut self) -> CKIN_SEL_W {
                CKIN_SEL_W { w: self }
            }
        }
    }
    #[doc = "PLL lock tester\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pll_lock](pll_lock) module"]
    pub type PLL_LOCK = crate::Reg<u32, _PLL_LOCK>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PLL_LOCK;
    #[doc = "`read()` method returns [pll_lock::R](pll_lock::R) reader structure"]
    impl crate::Readable for PLL_LOCK {}
    #[doc = "`write(|w| ..)` method takes [pll_lock::W](pll_lock::W) writer structure"]
    impl crate::Writable for PLL_LOCK {}
    #[doc = "PLL lock tester"]
    pub mod pll_lock {
        #[doc = "Reader of register pll_lock"]
        pub type R = crate::R<u32, super::PLL_LOCK>;
        #[doc = "Writer for register pll_lock"]
        pub type W = crate::W<u32, super::PLL_LOCK>;
        #[doc = "Register pll_lock `reset()`'s with value 0"]
        impl crate::ResetValue for super::PLL_LOCK {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `pll_lock0`"]
        pub type PLL_LOCK0_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `pll_lock0`"]
        pub struct PLL_LOCK0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLL_LOCK0_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        #[doc = "Reader of field `pll_slip_clear0`"]
        pub type PLL_SLIP_CLEAR0_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pll_slip_clear0`"]
        pub struct PLL_SLIP_CLEAR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLL_SLIP_CLEAR0_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `test_clk_out0`"]
        pub type TEST_CLK_OUT0_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `test_clk_out0`"]
        pub struct TEST_CLK_OUT0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEST_CLK_OUT0_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `pll_lock1`"]
        pub type PLL_LOCK1_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `pll_lock1`"]
        pub struct PLL_LOCK1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLL_LOCK1_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | (((value as u32) & 0x03) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `pll_slip_clear1`"]
        pub type PLL_SLIP_CLEAR1_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pll_slip_clear1`"]
        pub struct PLL_SLIP_CLEAR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLL_SLIP_CLEAR1_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `test_clk_out1`"]
        pub type TEST_CLK_OUT1_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `test_clk_out1`"]
        pub struct TEST_CLK_OUT1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEST_CLK_OUT1_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `pll_lock2`"]
        pub type PLL_LOCK2_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `pll_lock2`"]
        pub struct PLL_LOCK2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLL_LOCK2_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | (((value as u32) & 0x03) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `pll_slip_clear2`"]
        pub type PLL_SLIP_CLEAR2_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pll_slip_clear2`"]
        pub struct PLL_SLIP_CLEAR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLL_SLIP_CLEAR2_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Reader of field `test_clk_out2`"]
        pub type TEST_CLK_OUT2_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `test_clk_out2`"]
        pub struct TEST_CLK_OUT2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEST_CLK_OUT2_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            pub fn pll_lock0(&self) -> PLL_LOCK0_R {
                PLL_LOCK0_R::new((self.bits & 0x03) as u8)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pll_slip_clear0(&self) -> PLL_SLIP_CLEAR0_R {
                PLL_SLIP_CLEAR0_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn test_clk_out0(&self) -> TEST_CLK_OUT0_R {
                TEST_CLK_OUT0_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bits 8:9"]
            #[inline(always)]
            pub fn pll_lock1(&self) -> PLL_LOCK1_R {
                PLL_LOCK1_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pll_slip_clear1(&self) -> PLL_SLIP_CLEAR1_R {
                PLL_SLIP_CLEAR1_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn test_clk_out1(&self) -> TEST_CLK_OUT1_R {
                TEST_CLK_OUT1_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bits 16:17"]
            #[inline(always)]
            pub fn pll_lock2(&self) -> PLL_LOCK2_R {
                PLL_LOCK2_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pll_slip_clear2(&self) -> PLL_SLIP_CLEAR2_R {
                PLL_SLIP_CLEAR2_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn test_clk_out2(&self) -> TEST_CLK_OUT2_R {
                TEST_CLK_OUT2_R::new(((self.bits >> 19) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1"]
            #[inline(always)]
            pub fn pll_lock0(&mut self) -> PLL_LOCK0_W {
                PLL_LOCK0_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn pll_slip_clear0(&mut self) -> PLL_SLIP_CLEAR0_W {
                PLL_SLIP_CLEAR0_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn test_clk_out0(&mut self) -> TEST_CLK_OUT0_W {
                TEST_CLK_OUT0_W { w: self }
            }
            #[doc = "Bits 8:9"]
            #[inline(always)]
            pub fn pll_lock1(&mut self) -> PLL_LOCK1_W {
                PLL_LOCK1_W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn pll_slip_clear1(&mut self) -> PLL_SLIP_CLEAR1_W {
                PLL_SLIP_CLEAR1_W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn test_clk_out1(&mut self) -> TEST_CLK_OUT1_W {
                TEST_CLK_OUT1_W { w: self }
            }
            #[doc = "Bits 16:17"]
            #[inline(always)]
            pub fn pll_lock2(&mut self) -> PLL_LOCK2_W {
                PLL_LOCK2_W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn pll_slip_clear2(&mut self) -> PLL_SLIP_CLEAR2_W {
                PLL_SLIP_CLEAR2_W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn test_clk_out2(&mut self) -> TEST_CLK_OUT2_W {
                TEST_CLK_OUT2_W { w: self }
            }
        }
    }
    #[doc = "AXI ROM detector\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [rom_error](rom_error) module"]
    pub type ROM_ERROR = crate::Reg<u32, _ROM_ERROR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ROM_ERROR;
    #[doc = "`read()` method returns [rom_error::R](rom_error::R) reader structure"]
    impl crate::Readable for ROM_ERROR {}
    #[doc = "`write(|w| ..)` method takes [rom_error::W](rom_error::W) writer structure"]
    impl crate::Writable for ROM_ERROR {}
    #[doc = "AXI ROM detector"]
    pub mod rom_error {
        #[doc = "Reader of register rom_error"]
        pub type R = crate::R<u32, super::ROM_ERROR>;
        #[doc = "Writer for register rom_error"]
        pub type W = crate::W<u32, super::ROM_ERROR>;
        #[doc = "Register rom_error `reset()`'s with value 0"]
        impl crate::ResetValue for super::ROM_ERROR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rom_mul_error`"]
        pub type ROM_MUL_ERROR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rom_mul_error`"]
        pub struct ROM_MUL_ERROR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ROM_MUL_ERROR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `rom_one_error`"]
        pub type ROM_ONE_ERROR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rom_one_error`"]
        pub struct ROM_ONE_ERROR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ROM_ONE_ERROR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rom_mul_error(&self) -> ROM_MUL_ERROR_R {
                ROM_MUL_ERROR_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn rom_one_error(&self) -> ROM_ONE_ERROR_R {
                ROM_ONE_ERROR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rom_mul_error(&mut self) -> ROM_MUL_ERROR_W {
                ROM_MUL_ERROR_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn rom_one_error(&mut self) -> ROM_ONE_ERROR_W {
                ROM_ONE_ERROR_W { w: self }
            }
        }
    }
    #[doc = "Clock select controller 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_sel0](clk_sel0) module"]
    pub type CLK_SEL0 = crate::Reg<u32, _CLK_SEL0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_SEL0;
    #[doc = "`read()` method returns [clk_sel0::R](clk_sel0::R) reader structure"]
    impl crate::Readable for CLK_SEL0 {}
    #[doc = "`write(|w| ..)` method takes [clk_sel0::W](clk_sel0::W) writer structure"]
    impl crate::Writable for CLK_SEL0 {}
    #[doc = "Clock select controller 0"]
    pub mod clk_sel0 {
        #[doc = "Reader of register clk_sel0"]
        pub type R = crate::R<u32, super::CLK_SEL0>;
        #[doc = "Writer for register clk_sel0"]
        pub type W = crate::W<u32, super::CLK_SEL0>;
        #[doc = "Register clk_sel0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_SEL0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `aclk_sel`"]
        pub type ACLK_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `aclk_sel`"]
        pub struct ACLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACLK_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `aclk_divider_sel`"]
        pub type ACLK_DIVIDER_SEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `aclk_divider_sel`"]
        pub struct ACLK_DIVIDER_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACLK_DIVIDER_SEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 1)) | (((value as u32) & 0x03) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `apb0_clk_sel`"]
        pub type APB0_CLK_SEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `apb0_clk_sel`"]
        pub struct APB0_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> APB0_CLK_SEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | (((value as u32) & 0x07) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `apb1_clk_sel`"]
        pub type APB1_CLK_SEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `apb1_clk_sel`"]
        pub struct APB1_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> APB1_CLK_SEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 6)) | (((value as u32) & 0x07) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `apb2_clk_sel`"]
        pub type APB2_CLK_SEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `apb2_clk_sel`"]
        pub struct APB2_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> APB2_CLK_SEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 9)) | (((value as u32) & 0x07) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `spi3_clk_sel`"]
        pub type SPI3_CLK_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi3_clk_sel`"]
        pub struct SPI3_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3_CLK_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `timer0_clk_sel`"]
        pub type TIMER0_CLK_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer0_clk_sel`"]
        pub struct TIMER0_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER0_CLK_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `timer1_clk_sel`"]
        pub type TIMER1_CLK_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer1_clk_sel`"]
        pub struct TIMER1_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER1_CLK_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `timer2_clk_sel`"]
        pub type TIMER2_CLK_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer2_clk_sel`"]
        pub struct TIMER2_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER2_CLK_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn aclk_sel(&self) -> ACLK_SEL_R {
                ACLK_SEL_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bits 1:2"]
            #[inline(always)]
            pub fn aclk_divider_sel(&self) -> ACLK_DIVIDER_SEL_R {
                ACLK_DIVIDER_SEL_R::new(((self.bits >> 1) & 0x03) as u8)
            }
            #[doc = "Bits 3:5"]
            #[inline(always)]
            pub fn apb0_clk_sel(&self) -> APB0_CLK_SEL_R {
                APB0_CLK_SEL_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            #[doc = "Bits 6:8"]
            #[inline(always)]
            pub fn apb1_clk_sel(&self) -> APB1_CLK_SEL_R {
                APB1_CLK_SEL_R::new(((self.bits >> 6) & 0x07) as u8)
            }
            #[doc = "Bits 9:11"]
            #[inline(always)]
            pub fn apb2_clk_sel(&self) -> APB2_CLK_SEL_R {
                APB2_CLK_SEL_R::new(((self.bits >> 9) & 0x07) as u8)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn spi3_clk_sel(&self) -> SPI3_CLK_SEL_R {
                SPI3_CLK_SEL_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn timer0_clk_sel(&self) -> TIMER0_CLK_SEL_R {
                TIMER0_CLK_SEL_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn timer1_clk_sel(&self) -> TIMER1_CLK_SEL_R {
                TIMER1_CLK_SEL_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn timer2_clk_sel(&self) -> TIMER2_CLK_SEL_R {
                TIMER2_CLK_SEL_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn aclk_sel(&mut self) -> ACLK_SEL_W {
                ACLK_SEL_W { w: self }
            }
            #[doc = "Bits 1:2"]
            #[inline(always)]
            pub fn aclk_divider_sel(&mut self) -> ACLK_DIVIDER_SEL_W {
                ACLK_DIVIDER_SEL_W { w: self }
            }
            #[doc = "Bits 3:5"]
            #[inline(always)]
            pub fn apb0_clk_sel(&mut self) -> APB0_CLK_SEL_W {
                APB0_CLK_SEL_W { w: self }
            }
            #[doc = "Bits 6:8"]
            #[inline(always)]
            pub fn apb1_clk_sel(&mut self) -> APB1_CLK_SEL_W {
                APB1_CLK_SEL_W { w: self }
            }
            #[doc = "Bits 9:11"]
            #[inline(always)]
            pub fn apb2_clk_sel(&mut self) -> APB2_CLK_SEL_W {
                APB2_CLK_SEL_W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn spi3_clk_sel(&mut self) -> SPI3_CLK_SEL_W {
                SPI3_CLK_SEL_W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn timer0_clk_sel(&mut self) -> TIMER0_CLK_SEL_W {
                TIMER0_CLK_SEL_W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn timer1_clk_sel(&mut self) -> TIMER1_CLK_SEL_W {
                TIMER1_CLK_SEL_W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn timer2_clk_sel(&mut self) -> TIMER2_CLK_SEL_W {
                TIMER2_CLK_SEL_W { w: self }
            }
        }
    }
    #[doc = "Clock select controller 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_sel1](clk_sel1) module"]
    pub type CLK_SEL1 = crate::Reg<u32, _CLK_SEL1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_SEL1;
    #[doc = "`read()` method returns [clk_sel1::R](clk_sel1::R) reader structure"]
    impl crate::Readable for CLK_SEL1 {}
    #[doc = "`write(|w| ..)` method takes [clk_sel1::W](clk_sel1::W) writer structure"]
    impl crate::Writable for CLK_SEL1 {}
    #[doc = "Clock select controller 1"]
    pub mod clk_sel1 {
        #[doc = "Reader of register clk_sel1"]
        pub type R = crate::R<u32, super::CLK_SEL1>;
        #[doc = "Writer for register clk_sel1"]
        pub type W = crate::W<u32, super::CLK_SEL1>;
        #[doc = "Register clk_sel1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_SEL1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `spi3_sample_clk_sel`"]
        pub type SPI3_SAMPLE_CLK_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi3_sample_clk_sel`"]
        pub struct SPI3_SAMPLE_CLK_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3_SAMPLE_CLK_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn spi3_sample_clk_sel(&self) -> SPI3_SAMPLE_CLK_SEL_R {
                SPI3_SAMPLE_CLK_SEL_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn spi3_sample_clk_sel(&mut self) -> SPI3_SAMPLE_CLK_SEL_W {
                SPI3_SAMPLE_CLK_SEL_W { w: self }
            }
        }
    }
    #[doc = "Central clock enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_en_cent](clk_en_cent) module"]
    pub type CLK_EN_CENT = crate::Reg<u32, _CLK_EN_CENT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_EN_CENT;
    #[doc = "`read()` method returns [clk_en_cent::R](clk_en_cent::R) reader structure"]
    impl crate::Readable for CLK_EN_CENT {}
    #[doc = "`write(|w| ..)` method takes [clk_en_cent::W](clk_en_cent::W) writer structure"]
    impl crate::Writable for CLK_EN_CENT {}
    #[doc = "Central clock enable"]
    pub mod clk_en_cent {
        #[doc = "Reader of register clk_en_cent"]
        pub type R = crate::R<u32, super::CLK_EN_CENT>;
        #[doc = "Writer for register clk_en_cent"]
        pub type W = crate::W<u32, super::CLK_EN_CENT>;
        #[doc = "Register clk_en_cent `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_EN_CENT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `cpu_clk_en`"]
        pub type CPU_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `cpu_clk_en`"]
        pub struct CPU_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPU_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `sram0_clk_en`"]
        pub type SRAM0_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sram0_clk_en`"]
        pub struct SRAM0_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SRAM0_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `sram1_clk_en`"]
        pub type SRAM1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sram1_clk_en`"]
        pub struct SRAM1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SRAM1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `apb0_clk_en`"]
        pub type APB0_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `apb0_clk_en`"]
        pub struct APB0_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> APB0_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `apb1_clk_en`"]
        pub type APB1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `apb1_clk_en`"]
        pub struct APB1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> APB1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `apb2_clk_en`"]
        pub type APB2_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `apb2_clk_en`"]
        pub struct APB2_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> APB2_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn cpu_clk_en(&self) -> CPU_CLK_EN_R {
                CPU_CLK_EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn sram0_clk_en(&self) -> SRAM0_CLK_EN_R {
                SRAM0_CLK_EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn sram1_clk_en(&self) -> SRAM1_CLK_EN_R {
                SRAM1_CLK_EN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn apb0_clk_en(&self) -> APB0_CLK_EN_R {
                APB0_CLK_EN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn apb1_clk_en(&self) -> APB1_CLK_EN_R {
                APB1_CLK_EN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn apb2_clk_en(&self) -> APB2_CLK_EN_R {
                APB2_CLK_EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn cpu_clk_en(&mut self) -> CPU_CLK_EN_W {
                CPU_CLK_EN_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn sram0_clk_en(&mut self) -> SRAM0_CLK_EN_W {
                SRAM0_CLK_EN_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn sram1_clk_en(&mut self) -> SRAM1_CLK_EN_W {
                SRAM1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn apb0_clk_en(&mut self) -> APB0_CLK_EN_W {
                APB0_CLK_EN_W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn apb1_clk_en(&mut self) -> APB1_CLK_EN_W {
                APB1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn apb2_clk_en(&mut self) -> APB2_CLK_EN_W {
                APB2_CLK_EN_W { w: self }
            }
        }
    }
    #[doc = "Peripheral clock enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_en_peri](clk_en_peri) module"]
    pub type CLK_EN_PERI = crate::Reg<u32, _CLK_EN_PERI>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_EN_PERI;
    #[doc = "`read()` method returns [clk_en_peri::R](clk_en_peri::R) reader structure"]
    impl crate::Readable for CLK_EN_PERI {}
    #[doc = "`write(|w| ..)` method takes [clk_en_peri::W](clk_en_peri::W) writer structure"]
    impl crate::Writable for CLK_EN_PERI {}
    #[doc = "Peripheral clock enable"]
    pub mod clk_en_peri {
        #[doc = "Reader of register clk_en_peri"]
        pub type R = crate::R<u32, super::CLK_EN_PERI>;
        #[doc = "Writer for register clk_en_peri"]
        pub type W = crate::W<u32, super::CLK_EN_PERI>;
        #[doc = "Register clk_en_peri `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_EN_PERI {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rom_clk_en`"]
        pub type ROM_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rom_clk_en`"]
        pub struct ROM_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ROM_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `dma_clk_en`"]
        pub type DMA_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_clk_en`"]
        pub struct DMA_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `ai_clk_en`"]
        pub type AI_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ai_clk_en`"]
        pub struct AI_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AI_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `dvp_clk_en`"]
        pub type DVP_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dvp_clk_en`"]
        pub struct DVP_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DVP_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `fft_clk_en`"]
        pub type FFT_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fft_clk_en`"]
        pub struct FFT_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FFT_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `gpio_clk_en`"]
        pub type GPIO_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gpio_clk_en`"]
        pub struct GPIO_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GPIO_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `spi0_clk_en`"]
        pub type SPI0_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi0_clk_en`"]
        pub struct SPI0_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI0_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `spi1_clk_en`"]
        pub type SPI1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi1_clk_en`"]
        pub struct SPI1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `spi2_clk_en`"]
        pub type SPI2_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi2_clk_en`"]
        pub struct SPI2_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `spi3_clk_en`"]
        pub type SPI3_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi3_clk_en`"]
        pub struct SPI3_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `i2s0_clk_en`"]
        pub type I2S0_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s0_clk_en`"]
        pub struct I2S0_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S0_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `i2s1_clk_en`"]
        pub type I2S1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s1_clk_en`"]
        pub struct I2S1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `i2s2_clk_en`"]
        pub type I2S2_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s2_clk_en`"]
        pub struct I2S2_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S2_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `i2c0_clk_en`"]
        pub type I2C0_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2c0_clk_en`"]
        pub struct I2C0_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C0_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `i2c1_clk_en`"]
        pub type I2C1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2c1_clk_en`"]
        pub struct I2C1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `i2c2_clk_en`"]
        pub type I2C2_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2c2_clk_en`"]
        pub struct I2C2_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `uart1_clk_en`"]
        pub type UART1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `uart1_clk_en`"]
        pub struct UART1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `uart2_clk_en`"]
        pub type UART2_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `uart2_clk_en`"]
        pub struct UART2_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART2_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Reader of field `uart3_clk_en`"]
        pub type UART3_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `uart3_clk_en`"]
        pub struct UART3_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART3_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Reader of field `aes_clk_en`"]
        pub type AES_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `aes_clk_en`"]
        pub struct AES_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AES_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Reader of field `fpioa_clk_en`"]
        pub type FPIOA_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fpioa_clk_en`"]
        pub struct FPIOA_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FPIOA_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `timer0_clk_en`"]
        pub type TIMER0_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer0_clk_en`"]
        pub struct TIMER0_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER0_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `timer1_clk_en`"]
        pub type TIMER1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer1_clk_en`"]
        pub struct TIMER1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `timer2_clk_en`"]
        pub type TIMER2_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer2_clk_en`"]
        pub struct TIMER2_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER2_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `wdt0_clk_en`"]
        pub type WDT0_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `wdt0_clk_en`"]
        pub struct WDT0_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT0_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `wdt1_clk_en`"]
        pub type WDT1_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `wdt1_clk_en`"]
        pub struct WDT1_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT1_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Reader of field `sha_clk_en`"]
        pub type SHA_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sha_clk_en`"]
        pub struct SHA_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SHA_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Reader of field `otp_clk_en`"]
        pub type OTP_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `otp_clk_en`"]
        pub struct OTP_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OTP_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | (((value as u32) & 0x01) << 27);
                self.w
            }
        }
        #[doc = "Reader of field `rtc_clk_en`"]
        pub type RTC_CLK_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rtc_clk_en`"]
        pub struct RTC_CLK_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTC_CLK_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rom_clk_en(&self) -> ROM_CLK_EN_R {
                ROM_CLK_EN_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn dma_clk_en(&self) -> DMA_CLK_EN_R {
                DMA_CLK_EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn ai_clk_en(&self) -> AI_CLK_EN_R {
                AI_CLK_EN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn dvp_clk_en(&self) -> DVP_CLK_EN_R {
                DVP_CLK_EN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn fft_clk_en(&self) -> FFT_CLK_EN_R {
                FFT_CLK_EN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn gpio_clk_en(&self) -> GPIO_CLK_EN_R {
                GPIO_CLK_EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn spi0_clk_en(&self) -> SPI0_CLK_EN_R {
                SPI0_CLK_EN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn spi1_clk_en(&self) -> SPI1_CLK_EN_R {
                SPI1_CLK_EN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn spi2_clk_en(&self) -> SPI2_CLK_EN_R {
                SPI2_CLK_EN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn spi3_clk_en(&self) -> SPI3_CLK_EN_R {
                SPI3_CLK_EN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn i2s0_clk_en(&self) -> I2S0_CLK_EN_R {
                I2S0_CLK_EN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn i2s1_clk_en(&self) -> I2S1_CLK_EN_R {
                I2S1_CLK_EN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn i2s2_clk_en(&self) -> I2S2_CLK_EN_R {
                I2S2_CLK_EN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn i2c0_clk_en(&self) -> I2C0_CLK_EN_R {
                I2C0_CLK_EN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn i2c1_clk_en(&self) -> I2C1_CLK_EN_R {
                I2C1_CLK_EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn i2c2_clk_en(&self) -> I2C2_CLK_EN_R {
                I2C2_CLK_EN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn uart1_clk_en(&self) -> UART1_CLK_EN_R {
                UART1_CLK_EN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn uart2_clk_en(&self) -> UART2_CLK_EN_R {
                UART2_CLK_EN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn uart3_clk_en(&self) -> UART3_CLK_EN_R {
                UART3_CLK_EN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn aes_clk_en(&self) -> AES_CLK_EN_R {
                AES_CLK_EN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn fpioa_clk_en(&self) -> FPIOA_CLK_EN_R {
                FPIOA_CLK_EN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn timer0_clk_en(&self) -> TIMER0_CLK_EN_R {
                TIMER0_CLK_EN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn timer1_clk_en(&self) -> TIMER1_CLK_EN_R {
                TIMER1_CLK_EN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn timer2_clk_en(&self) -> TIMER2_CLK_EN_R {
                TIMER2_CLK_EN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn wdt0_clk_en(&self) -> WDT0_CLK_EN_R {
                WDT0_CLK_EN_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn wdt1_clk_en(&self) -> WDT1_CLK_EN_R {
                WDT1_CLK_EN_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn sha_clk_en(&self) -> SHA_CLK_EN_R {
                SHA_CLK_EN_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn otp_clk_en(&self) -> OTP_CLK_EN_R {
                OTP_CLK_EN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn rtc_clk_en(&self) -> RTC_CLK_EN_R {
                RTC_CLK_EN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rom_clk_en(&mut self) -> ROM_CLK_EN_W {
                ROM_CLK_EN_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn dma_clk_en(&mut self) -> DMA_CLK_EN_W {
                DMA_CLK_EN_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn ai_clk_en(&mut self) -> AI_CLK_EN_W {
                AI_CLK_EN_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn dvp_clk_en(&mut self) -> DVP_CLK_EN_W {
                DVP_CLK_EN_W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn fft_clk_en(&mut self) -> FFT_CLK_EN_W {
                FFT_CLK_EN_W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn gpio_clk_en(&mut self) -> GPIO_CLK_EN_W {
                GPIO_CLK_EN_W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn spi0_clk_en(&mut self) -> SPI0_CLK_EN_W {
                SPI0_CLK_EN_W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn spi1_clk_en(&mut self) -> SPI1_CLK_EN_W {
                SPI1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn spi2_clk_en(&mut self) -> SPI2_CLK_EN_W {
                SPI2_CLK_EN_W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn spi3_clk_en(&mut self) -> SPI3_CLK_EN_W {
                SPI3_CLK_EN_W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn i2s0_clk_en(&mut self) -> I2S0_CLK_EN_W {
                I2S0_CLK_EN_W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn i2s1_clk_en(&mut self) -> I2S1_CLK_EN_W {
                I2S1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn i2s2_clk_en(&mut self) -> I2S2_CLK_EN_W {
                I2S2_CLK_EN_W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn i2c0_clk_en(&mut self) -> I2C0_CLK_EN_W {
                I2C0_CLK_EN_W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn i2c1_clk_en(&mut self) -> I2C1_CLK_EN_W {
                I2C1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn i2c2_clk_en(&mut self) -> I2C2_CLK_EN_W {
                I2C2_CLK_EN_W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn uart1_clk_en(&mut self) -> UART1_CLK_EN_W {
                UART1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn uart2_clk_en(&mut self) -> UART2_CLK_EN_W {
                UART2_CLK_EN_W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn uart3_clk_en(&mut self) -> UART3_CLK_EN_W {
                UART3_CLK_EN_W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn aes_clk_en(&mut self) -> AES_CLK_EN_W {
                AES_CLK_EN_W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn fpioa_clk_en(&mut self) -> FPIOA_CLK_EN_W {
                FPIOA_CLK_EN_W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn timer0_clk_en(&mut self) -> TIMER0_CLK_EN_W {
                TIMER0_CLK_EN_W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn timer1_clk_en(&mut self) -> TIMER1_CLK_EN_W {
                TIMER1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn timer2_clk_en(&mut self) -> TIMER2_CLK_EN_W {
                TIMER2_CLK_EN_W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn wdt0_clk_en(&mut self) -> WDT0_CLK_EN_W {
                WDT0_CLK_EN_W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn wdt1_clk_en(&mut self) -> WDT1_CLK_EN_W {
                WDT1_CLK_EN_W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn sha_clk_en(&mut self) -> SHA_CLK_EN_W {
                SHA_CLK_EN_W { w: self }
            }
            #[doc = "Bit 27"]
            #[inline(always)]
            pub fn otp_clk_en(&mut self) -> OTP_CLK_EN_W {
                OTP_CLK_EN_W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn rtc_clk_en(&mut self) -> RTC_CLK_EN_W {
                RTC_CLK_EN_W { w: self }
            }
        }
    }
    #[doc = "Soft reset ctrl\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [soft_reset](soft_reset) module"]
    pub type SOFT_RESET = crate::Reg<u32, _SOFT_RESET>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SOFT_RESET;
    #[doc = "`read()` method returns [soft_reset::R](soft_reset::R) reader structure"]
    impl crate::Readable for SOFT_RESET {}
    #[doc = "`write(|w| ..)` method takes [soft_reset::W](soft_reset::W) writer structure"]
    impl crate::Writable for SOFT_RESET {}
    #[doc = "Soft reset ctrl"]
    pub mod soft_reset {
        #[doc = "Reader of register soft_reset"]
        pub type R = crate::R<u32, super::SOFT_RESET>;
        #[doc = "Writer for register soft_reset"]
        pub type W = crate::W<u32, super::SOFT_RESET>;
        #[doc = "Register soft_reset `reset()`'s with value 0"]
        impl crate::ResetValue for super::SOFT_RESET {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `soft_reset`"]
        pub type SOFT_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `soft_reset`"]
        pub struct SOFT_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SOFT_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn soft_reset(&self) -> SOFT_RESET_R {
                SOFT_RESET_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn soft_reset(&mut self) -> SOFT_RESET_W {
                SOFT_RESET_W { w: self }
            }
        }
    }
    #[doc = "Peripheral reset controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [peri_reset](peri_reset) module"]
    pub type PERI_RESET = crate::Reg<u32, _PERI_RESET>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PERI_RESET;
    #[doc = "`read()` method returns [peri_reset::R](peri_reset::R) reader structure"]
    impl crate::Readable for PERI_RESET {}
    #[doc = "`write(|w| ..)` method takes [peri_reset::W](peri_reset::W) writer structure"]
    impl crate::Writable for PERI_RESET {}
    #[doc = "Peripheral reset controller"]
    pub mod peri_reset {
        #[doc = "Reader of register peri_reset"]
        pub type R = crate::R<u32, super::PERI_RESET>;
        #[doc = "Writer for register peri_reset"]
        pub type W = crate::W<u32, super::PERI_RESET>;
        #[doc = "Register peri_reset `reset()`'s with value 0"]
        impl crate::ResetValue for super::PERI_RESET {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `rom_reset`"]
        pub type ROM_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rom_reset`"]
        pub struct ROM_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ROM_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `dma_reset`"]
        pub type DMA_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_reset`"]
        pub struct DMA_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `ai_reset`"]
        pub type AI_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ai_reset`"]
        pub struct AI_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AI_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `dvp_reset`"]
        pub type DVP_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dvp_reset`"]
        pub struct DVP_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DVP_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `fft_reset`"]
        pub type FFT_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fft_reset`"]
        pub struct FFT_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FFT_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `gpio_reset`"]
        pub type GPIO_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `gpio_reset`"]
        pub struct GPIO_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GPIO_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `spi0_reset`"]
        pub type SPI0_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi0_reset`"]
        pub struct SPI0_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI0_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `spi1_reset`"]
        pub type SPI1_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi1_reset`"]
        pub struct SPI1_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `spi2_reset`"]
        pub type SPI2_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi2_reset`"]
        pub struct SPI2_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `spi3_reset`"]
        pub type SPI3_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi3_reset`"]
        pub struct SPI3_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `i2s0_reset`"]
        pub type I2S0_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s0_reset`"]
        pub struct I2S0_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S0_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `i2s1_reset`"]
        pub type I2S1_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s1_reset`"]
        pub struct I2S1_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S1_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `i2s2_reset`"]
        pub type I2S2_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s2_reset`"]
        pub struct I2S2_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S2_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `i2c0_reset`"]
        pub type I2C0_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2c0_reset`"]
        pub struct I2C0_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C0_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `i2c1_reset`"]
        pub type I2C1_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2c1_reset`"]
        pub struct I2C1_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `i2c2_reset`"]
        pub type I2C2_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2c2_reset`"]
        pub struct I2C2_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `uart1_reset`"]
        pub type UART1_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `uart1_reset`"]
        pub struct UART1_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART1_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `uart2_reset`"]
        pub type UART2_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `uart2_reset`"]
        pub struct UART2_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART2_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Reader of field `uart3_reset`"]
        pub type UART3_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `uart3_reset`"]
        pub struct UART3_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART3_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Reader of field `aes_reset`"]
        pub type AES_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `aes_reset`"]
        pub struct AES_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AES_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Reader of field `fpioa_reset`"]
        pub type FPIOA_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `fpioa_reset`"]
        pub struct FPIOA_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FPIOA_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `timer0_reset`"]
        pub type TIMER0_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer0_reset`"]
        pub struct TIMER0_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER0_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `timer1_reset`"]
        pub type TIMER1_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer1_reset`"]
        pub struct TIMER1_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER1_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `timer2_reset`"]
        pub type TIMER2_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer2_reset`"]
        pub struct TIMER2_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER2_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `wdt0_reset`"]
        pub type WDT0_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `wdt0_reset`"]
        pub struct WDT0_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT0_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        #[doc = "Reader of field `wdt1_reset`"]
        pub type WDT1_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `wdt1_reset`"]
        pub struct WDT1_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT1_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | (((value as u32) & 0x01) << 25);
                self.w
            }
        }
        #[doc = "Reader of field `sha_reset`"]
        pub type SHA_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `sha_reset`"]
        pub struct SHA_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SHA_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | (((value as u32) & 0x01) << 26);
                self.w
            }
        }
        #[doc = "Reader of field `rtc_reset`"]
        pub type RTC_RESET_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `rtc_reset`"]
        pub struct RTC_RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTC_RESET_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rom_reset(&self) -> ROM_RESET_R {
                ROM_RESET_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn dma_reset(&self) -> DMA_RESET_R {
                DMA_RESET_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn ai_reset(&self) -> AI_RESET_R {
                AI_RESET_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn dvp_reset(&self) -> DVP_RESET_R {
                DVP_RESET_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn fft_reset(&self) -> FFT_RESET_R {
                FFT_RESET_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn gpio_reset(&self) -> GPIO_RESET_R {
                GPIO_RESET_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn spi0_reset(&self) -> SPI0_RESET_R {
                SPI0_RESET_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn spi1_reset(&self) -> SPI1_RESET_R {
                SPI1_RESET_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn spi2_reset(&self) -> SPI2_RESET_R {
                SPI2_RESET_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn spi3_reset(&self) -> SPI3_RESET_R {
                SPI3_RESET_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn i2s0_reset(&self) -> I2S0_RESET_R {
                I2S0_RESET_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn i2s1_reset(&self) -> I2S1_RESET_R {
                I2S1_RESET_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn i2s2_reset(&self) -> I2S2_RESET_R {
                I2S2_RESET_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn i2c0_reset(&self) -> I2C0_RESET_R {
                I2C0_RESET_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn i2c1_reset(&self) -> I2C1_RESET_R {
                I2C1_RESET_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn i2c2_reset(&self) -> I2C2_RESET_R {
                I2C2_RESET_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn uart1_reset(&self) -> UART1_RESET_R {
                UART1_RESET_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn uart2_reset(&self) -> UART2_RESET_R {
                UART2_RESET_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn uart3_reset(&self) -> UART3_RESET_R {
                UART3_RESET_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn aes_reset(&self) -> AES_RESET_R {
                AES_RESET_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn fpioa_reset(&self) -> FPIOA_RESET_R {
                FPIOA_RESET_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn timer0_reset(&self) -> TIMER0_RESET_R {
                TIMER0_RESET_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn timer1_reset(&self) -> TIMER1_RESET_R {
                TIMER1_RESET_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn timer2_reset(&self) -> TIMER2_RESET_R {
                TIMER2_RESET_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn wdt0_reset(&self) -> WDT0_RESET_R {
                WDT0_RESET_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn wdt1_reset(&self) -> WDT1_RESET_R {
                WDT1_RESET_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn sha_reset(&self) -> SHA_RESET_R {
                SHA_RESET_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn rtc_reset(&self) -> RTC_RESET_R {
                RTC_RESET_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn rom_reset(&mut self) -> ROM_RESET_W {
                ROM_RESET_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn dma_reset(&mut self) -> DMA_RESET_W {
                DMA_RESET_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn ai_reset(&mut self) -> AI_RESET_W {
                AI_RESET_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn dvp_reset(&mut self) -> DVP_RESET_W {
                DVP_RESET_W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn fft_reset(&mut self) -> FFT_RESET_W {
                FFT_RESET_W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn gpio_reset(&mut self) -> GPIO_RESET_W {
                GPIO_RESET_W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn spi0_reset(&mut self) -> SPI0_RESET_W {
                SPI0_RESET_W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn spi1_reset(&mut self) -> SPI1_RESET_W {
                SPI1_RESET_W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn spi2_reset(&mut self) -> SPI2_RESET_W {
                SPI2_RESET_W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn spi3_reset(&mut self) -> SPI3_RESET_W {
                SPI3_RESET_W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn i2s0_reset(&mut self) -> I2S0_RESET_W {
                I2S0_RESET_W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn i2s1_reset(&mut self) -> I2S1_RESET_W {
                I2S1_RESET_W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn i2s2_reset(&mut self) -> I2S2_RESET_W {
                I2S2_RESET_W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn i2c0_reset(&mut self) -> I2C0_RESET_W {
                I2C0_RESET_W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn i2c1_reset(&mut self) -> I2C1_RESET_W {
                I2C1_RESET_W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn i2c2_reset(&mut self) -> I2C2_RESET_W {
                I2C2_RESET_W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn uart1_reset(&mut self) -> UART1_RESET_W {
                UART1_RESET_W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn uart2_reset(&mut self) -> UART2_RESET_W {
                UART2_RESET_W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn uart3_reset(&mut self) -> UART3_RESET_W {
                UART3_RESET_W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn aes_reset(&mut self) -> AES_RESET_W {
                AES_RESET_W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn fpioa_reset(&mut self) -> FPIOA_RESET_W {
                FPIOA_RESET_W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn timer0_reset(&mut self) -> TIMER0_RESET_W {
                TIMER0_RESET_W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn timer1_reset(&mut self) -> TIMER1_RESET_W {
                TIMER1_RESET_W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn timer2_reset(&mut self) -> TIMER2_RESET_W {
                TIMER2_RESET_W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn wdt0_reset(&mut self) -> WDT0_RESET_W {
                WDT0_RESET_W { w: self }
            }
            #[doc = "Bit 25"]
            #[inline(always)]
            pub fn wdt1_reset(&mut self) -> WDT1_RESET_W {
                WDT1_RESET_W { w: self }
            }
            #[doc = "Bit 26"]
            #[inline(always)]
            pub fn sha_reset(&mut self) -> SHA_RESET_W {
                SHA_RESET_W { w: self }
            }
            #[doc = "Bit 29"]
            #[inline(always)]
            pub fn rtc_reset(&mut self) -> RTC_RESET_W {
                RTC_RESET_W { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_th0](clk_th0) module"]
    pub type CLK_TH0 = crate::Reg<u32, _CLK_TH0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_TH0;
    #[doc = "`read()` method returns [clk_th0::R](clk_th0::R) reader structure"]
    impl crate::Readable for CLK_TH0 {}
    #[doc = "`write(|w| ..)` method takes [clk_th0::W](clk_th0::W) writer structure"]
    impl crate::Writable for CLK_TH0 {}
    #[doc = "Clock threshold controller 0"]
    pub mod clk_th0 {
        #[doc = "Reader of register clk_th0"]
        pub type R = crate::R<u32, super::CLK_TH0>;
        #[doc = "Writer for register clk_th0"]
        pub type W = crate::W<u32, super::CLK_TH0>;
        #[doc = "Register clk_th0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_TH0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `sram0_gclk`"]
        pub type SRAM0_GCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `sram0_gclk`"]
        pub struct SRAM0_GCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SRAM0_GCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | ((value as u32) & 0x0f);
                self.w
            }
        }
        #[doc = "Reader of field `sram1_gclk`"]
        pub type SRAM1_GCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `sram1_gclk`"]
        pub struct SRAM1_GCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SRAM1_GCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | (((value as u32) & 0x0f) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `ai_gclk`"]
        pub type AI_GCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `ai_gclk`"]
        pub struct AI_GCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AI_GCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | (((value as u32) & 0x0f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `dvp_gclk`"]
        pub type DVP_GCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `dvp_gclk`"]
        pub struct DVP_GCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DVP_GCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | (((value as u32) & 0x0f) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `rom_gclk`"]
        pub type ROM_GCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `rom_gclk`"]
        pub struct ROM_GCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ROM_GCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn sram0_gclk(&self) -> SRAM0_GCLK_R {
                SRAM0_GCLK_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7"]
            #[inline(always)]
            pub fn sram1_gclk(&self) -> SRAM1_GCLK_R {
                SRAM1_GCLK_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bits 8:11"]
            #[inline(always)]
            pub fn ai_gclk(&self) -> AI_GCLK_R {
                AI_GCLK_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15"]
            #[inline(always)]
            pub fn dvp_gclk(&self) -> DVP_GCLK_R {
                DVP_GCLK_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            #[doc = "Bits 16:19"]
            #[inline(always)]
            pub fn rom_gclk(&self) -> ROM_GCLK_R {
                ROM_GCLK_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3"]
            #[inline(always)]
            pub fn sram0_gclk(&mut self) -> SRAM0_GCLK_W {
                SRAM0_GCLK_W { w: self }
            }
            #[doc = "Bits 4:7"]
            #[inline(always)]
            pub fn sram1_gclk(&mut self) -> SRAM1_GCLK_W {
                SRAM1_GCLK_W { w: self }
            }
            #[doc = "Bits 8:11"]
            #[inline(always)]
            pub fn ai_gclk(&mut self) -> AI_GCLK_W {
                AI_GCLK_W { w: self }
            }
            #[doc = "Bits 12:15"]
            #[inline(always)]
            pub fn dvp_gclk(&mut self) -> DVP_GCLK_W {
                DVP_GCLK_W { w: self }
            }
            #[doc = "Bits 16:19"]
            #[inline(always)]
            pub fn rom_gclk(&mut self) -> ROM_GCLK_W {
                ROM_GCLK_W { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_th1](clk_th1) module"]
    pub type CLK_TH1 = crate::Reg<u32, _CLK_TH1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_TH1;
    #[doc = "`read()` method returns [clk_th1::R](clk_th1::R) reader structure"]
    impl crate::Readable for CLK_TH1 {}
    #[doc = "`write(|w| ..)` method takes [clk_th1::W](clk_th1::W) writer structure"]
    impl crate::Writable for CLK_TH1 {}
    #[doc = "Clock threshold controller 1"]
    pub mod clk_th1 {
        #[doc = "Reader of register clk_th1"]
        pub type R = crate::R<u32, super::CLK_TH1>;
        #[doc = "Writer for register clk_th1"]
        pub type W = crate::W<u32, super::CLK_TH1>;
        #[doc = "Register clk_th1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_TH1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `spi0_clk`"]
        pub type SPI0_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `spi0_clk`"]
        pub struct SPI0_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI0_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `spi1_clk`"]
        pub type SPI1_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `spi1_clk`"]
        pub struct SPI1_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `spi2_clk`"]
        pub type SPI2_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `spi2_clk`"]
        pub struct SPI2_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `spi3_clk`"]
        pub type SPI3_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `spi3_clk`"]
        pub struct SPI3_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn spi0_clk(&self) -> SPI0_CLK_R {
                SPI0_CLK_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn spi1_clk(&self) -> SPI1_CLK_R {
                SPI1_CLK_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn spi2_clk(&self) -> SPI2_CLK_R {
                SPI2_CLK_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31"]
            #[inline(always)]
            pub fn spi3_clk(&self) -> SPI3_CLK_R {
                SPI3_CLK_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn spi0_clk(&mut self) -> SPI0_CLK_W {
                SPI0_CLK_W { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn spi1_clk(&mut self) -> SPI1_CLK_W {
                SPI1_CLK_W { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn spi2_clk(&mut self) -> SPI2_CLK_W {
                SPI2_CLK_W { w: self }
            }
            #[doc = "Bits 24:31"]
            #[inline(always)]
            pub fn spi3_clk(&mut self) -> SPI3_CLK_W {
                SPI3_CLK_W { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_th2](clk_th2) module"]
    pub type CLK_TH2 = crate::Reg<u32, _CLK_TH2>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_TH2;
    #[doc = "`read()` method returns [clk_th2::R](clk_th2::R) reader structure"]
    impl crate::Readable for CLK_TH2 {}
    #[doc = "`write(|w| ..)` method takes [clk_th2::W](clk_th2::W) writer structure"]
    impl crate::Writable for CLK_TH2 {}
    #[doc = "Clock threshold controller 2"]
    pub mod clk_th2 {
        #[doc = "Reader of register clk_th2"]
        pub type R = crate::R<u32, super::CLK_TH2>;
        #[doc = "Writer for register clk_th2"]
        pub type W = crate::W<u32, super::CLK_TH2>;
        #[doc = "Register clk_th2 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_TH2 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `timer0_clk`"]
        pub type TIMER0_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `timer0_clk`"]
        pub struct TIMER0_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER0_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `timer1_clk`"]
        pub type TIMER1_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `timer1_clk`"]
        pub struct TIMER1_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER1_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `timer2_clk`"]
        pub type TIMER2_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `timer2_clk`"]
        pub struct TIMER2_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER2_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn timer0_clk(&self) -> TIMER0_CLK_R {
                TIMER0_CLK_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn timer1_clk(&self) -> TIMER1_CLK_R {
                TIMER1_CLK_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn timer2_clk(&self) -> TIMER2_CLK_R {
                TIMER2_CLK_R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn timer0_clk(&mut self) -> TIMER0_CLK_W {
                TIMER0_CLK_W { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn timer1_clk(&mut self) -> TIMER1_CLK_W {
                TIMER1_CLK_W { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn timer2_clk(&mut self) -> TIMER2_CLK_W {
                TIMER2_CLK_W { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_th3](clk_th3) module"]
    pub type CLK_TH3 = crate::Reg<u32, _CLK_TH3>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_TH3;
    #[doc = "`read()` method returns [clk_th3::R](clk_th3::R) reader structure"]
    impl crate::Readable for CLK_TH3 {}
    #[doc = "`write(|w| ..)` method takes [clk_th3::W](clk_th3::W) writer structure"]
    impl crate::Writable for CLK_TH3 {}
    #[doc = "Clock threshold controller 3"]
    pub mod clk_th3 {
        #[doc = "Reader of register clk_th3"]
        pub type R = crate::R<u32, super::CLK_TH3>;
        #[doc = "Writer for register clk_th3"]
        pub type W = crate::W<u32, super::CLK_TH3>;
        #[doc = "Register clk_th3 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_TH3 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `i2s0_clk`"]
        pub type I2S0_CLK_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `i2s0_clk`"]
        pub struct I2S0_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S0_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `i2s1_clk`"]
        pub type I2S1_CLK_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `i2s1_clk`"]
        pub struct I2S1_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S1_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xffff << 16)) | (((value as u32) & 0xffff) << 16);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15"]
            #[inline(always)]
            pub fn i2s0_clk(&self) -> I2S0_CLK_R {
                I2S0_CLK_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:31"]
            #[inline(always)]
            pub fn i2s1_clk(&self) -> I2S1_CLK_R {
                I2S1_CLK_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:15"]
            #[inline(always)]
            pub fn i2s0_clk(&mut self) -> I2S0_CLK_W {
                I2S0_CLK_W { w: self }
            }
            #[doc = "Bits 16:31"]
            #[inline(always)]
            pub fn i2s1_clk(&mut self) -> I2S1_CLK_W {
                I2S1_CLK_W { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 4\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_th4](clk_th4) module"]
    pub type CLK_TH4 = crate::Reg<u32, _CLK_TH4>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_TH4;
    #[doc = "`read()` method returns [clk_th4::R](clk_th4::R) reader structure"]
    impl crate::Readable for CLK_TH4 {}
    #[doc = "`write(|w| ..)` method takes [clk_th4::W](clk_th4::W) writer structure"]
    impl crate::Writable for CLK_TH4 {}
    #[doc = "Clock threshold controller 4"]
    pub mod clk_th4 {
        #[doc = "Reader of register clk_th4"]
        pub type R = crate::R<u32, super::CLK_TH4>;
        #[doc = "Writer for register clk_th4"]
        pub type W = crate::W<u32, super::CLK_TH4>;
        #[doc = "Register clk_th4 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_TH4 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `i2s2_clk`"]
        pub type I2S2_CLK_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `i2s2_clk`"]
        pub struct I2S2_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S2_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | ((value as u32) & 0xffff);
                self.w
            }
        }
        #[doc = "Reader of field `i2s0_mclk`"]
        pub type I2S0_MCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `i2s0_mclk`"]
        pub struct I2S0_MCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S0_MCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `i2s1_mclk`"]
        pub type I2S1_MCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `i2s1_mclk`"]
        pub struct I2S1_MCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S1_MCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:15"]
            #[inline(always)]
            pub fn i2s2_clk(&self) -> I2S2_CLK_R {
                I2S2_CLK_R::new((self.bits & 0xffff) as u16)
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn i2s0_mclk(&self) -> I2S0_MCLK_R {
                I2S0_MCLK_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31"]
            #[inline(always)]
            pub fn i2s1_mclk(&self) -> I2S1_MCLK_R {
                I2S1_MCLK_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:15"]
            #[inline(always)]
            pub fn i2s2_clk(&mut self) -> I2S2_CLK_W {
                I2S2_CLK_W { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn i2s0_mclk(&mut self) -> I2S0_MCLK_W {
                I2S0_MCLK_W { w: self }
            }
            #[doc = "Bits 24:31"]
            #[inline(always)]
            pub fn i2s1_mclk(&mut self) -> I2S1_MCLK_W {
                I2S1_MCLK_W { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 5\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_th5](clk_th5) module"]
    pub type CLK_TH5 = crate::Reg<u32, _CLK_TH5>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_TH5;
    #[doc = "`read()` method returns [clk_th5::R](clk_th5::R) reader structure"]
    impl crate::Readable for CLK_TH5 {}
    #[doc = "`write(|w| ..)` method takes [clk_th5::W](clk_th5::W) writer structure"]
    impl crate::Writable for CLK_TH5 {}
    #[doc = "Clock threshold controller 5"]
    pub mod clk_th5 {
        #[doc = "Reader of register clk_th5"]
        pub type R = crate::R<u32, super::CLK_TH5>;
        #[doc = "Writer for register clk_th5"]
        pub type W = crate::W<u32, super::CLK_TH5>;
        #[doc = "Register clk_th5 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_TH5 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `i2s2_mclk`"]
        pub type I2S2_MCLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `i2s2_mclk`"]
        pub struct I2S2_MCLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S2_MCLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `i2c0_clk`"]
        pub type I2C0_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `i2c0_clk`"]
        pub struct I2C0_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C0_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `i2c1_clk`"]
        pub type I2C1_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `i2c1_clk`"]
        pub struct I2C1_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 16)) | (((value as u32) & 0xff) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `i2c2_clk`"]
        pub type I2C2_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `i2c2_clk`"]
        pub struct I2C2_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn i2s2_mclk(&self) -> I2S2_MCLK_R {
                I2S2_MCLK_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn i2c0_clk(&self) -> I2C0_CLK_R {
                I2C0_CLK_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn i2c1_clk(&self) -> I2C1_CLK_R {
                I2C1_CLK_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31"]
            #[inline(always)]
            pub fn i2c2_clk(&self) -> I2C2_CLK_R {
                I2C2_CLK_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn i2s2_mclk(&mut self) -> I2S2_MCLK_W {
                I2S2_MCLK_W { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn i2c0_clk(&mut self) -> I2C0_CLK_W {
                I2C0_CLK_W { w: self }
            }
            #[doc = "Bits 16:23"]
            #[inline(always)]
            pub fn i2c1_clk(&mut self) -> I2C1_CLK_W {
                I2C1_CLK_W { w: self }
            }
            #[doc = "Bits 24:31"]
            #[inline(always)]
            pub fn i2c2_clk(&mut self) -> I2C2_CLK_W {
                I2C2_CLK_W { w: self }
            }
        }
    }
    #[doc = "Clock threshold controller 6\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [clk_th6](clk_th6) module"]
    pub type CLK_TH6 = crate::Reg<u32, _CLK_TH6>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CLK_TH6;
    #[doc = "`read()` method returns [clk_th6::R](clk_th6::R) reader structure"]
    impl crate::Readable for CLK_TH6 {}
    #[doc = "`write(|w| ..)` method takes [clk_th6::W](clk_th6::W) writer structure"]
    impl crate::Writable for CLK_TH6 {}
    #[doc = "Clock threshold controller 6"]
    pub mod clk_th6 {
        #[doc = "Reader of register clk_th6"]
        pub type R = crate::R<u32, super::CLK_TH6>;
        #[doc = "Writer for register clk_th6"]
        pub type W = crate::W<u32, super::CLK_TH6>;
        #[doc = "Register clk_th6 `reset()`'s with value 0"]
        impl crate::ResetValue for super::CLK_TH6 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `wdt0_clk`"]
        pub type WDT0_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `wdt0_clk`"]
        pub struct WDT0_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT0_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | ((value as u32) & 0xff);
                self.w
            }
        }
        #[doc = "Reader of field `wdt1_clk`"]
        pub type WDT1_CLK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `wdt1_clk`"]
        pub struct WDT1_CLK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT1_CLK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | (((value as u32) & 0xff) << 8);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn wdt0_clk(&self) -> WDT0_CLK_R {
                WDT0_CLK_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn wdt1_clk(&self) -> WDT1_CLK_R {
                WDT1_CLK_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7"]
            #[inline(always)]
            pub fn wdt0_clk(&mut self) -> WDT0_CLK_W {
                WDT0_CLK_W { w: self }
            }
            #[doc = "Bits 8:15"]
            #[inline(always)]
            pub fn wdt1_clk(&mut self) -> WDT1_CLK_W {
                WDT1_CLK_W { w: self }
            }
        }
    }
    #[doc = "Miscellaneous controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [misc](misc) module"]
    pub type MISC = crate::Reg<u32, _MISC>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MISC;
    #[doc = "`read()` method returns [misc::R](misc::R) reader structure"]
    impl crate::Readable for MISC {}
    #[doc = "`write(|w| ..)` method takes [misc::W](misc::W) writer structure"]
    impl crate::Writable for MISC {}
    #[doc = "Miscellaneous controller"]
    pub mod misc {
        #[doc = "Reader of register misc"]
        pub type R = crate::R<u32, super::MISC>;
        #[doc = "Writer for register misc"]
        pub type W = crate::W<u32, super::MISC>;
        #[doc = "Register misc `reset()`'s with value 0"]
        impl crate::ResetValue for super::MISC {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `debug_sel`"]
        pub type DEBUG_SEL_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `debug_sel`"]
        pub struct DEBUG_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEBUG_SEL_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3f) | ((value as u32) & 0x3f);
                self.w
            }
        }
        #[doc = "Reader of field `spi_dvp_data_enable`"]
        pub type SPI_DVP_DATA_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi_dvp_data_enable`"]
        pub struct SPI_DVP_DATA_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI_DVP_DATA_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn debug_sel(&self) -> DEBUG_SEL_R {
                DEBUG_SEL_R::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn spi_dvp_data_enable(&self) -> SPI_DVP_DATA_ENABLE_R {
                SPI_DVP_DATA_ENABLE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn debug_sel(&mut self) -> DEBUG_SEL_W {
                DEBUG_SEL_W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn spi_dvp_data_enable(&mut self) -> SPI_DVP_DATA_ENABLE_W {
                SPI_DVP_DATA_ENABLE_W { w: self }
            }
        }
    }
    #[doc = "Peripheral controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [peri](peri) module"]
    pub type PERI = crate::Reg<u32, _PERI>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PERI;
    #[doc = "`read()` method returns [peri::R](peri::R) reader structure"]
    impl crate::Readable for PERI {}
    #[doc = "`write(|w| ..)` method takes [peri::W](peri::W) writer structure"]
    impl crate::Writable for PERI {}
    #[doc = "Peripheral controller"]
    pub mod peri {
        #[doc = "Reader of register peri"]
        pub type R = crate::R<u32, super::PERI>;
        #[doc = "Writer for register peri"]
        pub type W = crate::W<u32, super::PERI>;
        #[doc = "Register peri `reset()`'s with value 0"]
        impl crate::ResetValue for super::PERI {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `timer0_pause`"]
        pub type TIMER0_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer0_pause`"]
        pub struct TIMER0_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER0_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `timer1_pause`"]
        pub type TIMER1_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer1_pause`"]
        pub struct TIMER1_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER1_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `timer2_pause`"]
        pub type TIMER2_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer2_pause`"]
        pub struct TIMER2_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER2_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `timer3_pause`"]
        pub type TIMER3_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer3_pause`"]
        pub struct TIMER3_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER3_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `timer4_pause`"]
        pub type TIMER4_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer4_pause`"]
        pub struct TIMER4_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER4_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `timer5_pause`"]
        pub type TIMER5_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer5_pause`"]
        pub struct TIMER5_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER5_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `timer6_pause`"]
        pub type TIMER6_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer6_pause`"]
        pub struct TIMER6_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER6_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `timer7_pause`"]
        pub type TIMER7_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer7_pause`"]
        pub struct TIMER7_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER7_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Reader of field `timer8_pause`"]
        pub type TIMER8_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer8_pause`"]
        pub struct TIMER8_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER8_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | (((value as u32) & 0x01) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `timer9_pause`"]
        pub type TIMER9_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer9_pause`"]
        pub struct TIMER9_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER9_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        #[doc = "Reader of field `timer10_pause`"]
        pub type TIMER10_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer10_pause`"]
        pub struct TIMER10_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER10_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | (((value as u32) & 0x01) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `timer11_pause`"]
        pub type TIMER11_PAUSE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `timer11_pause`"]
        pub struct TIMER11_PAUSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER11_PAUSE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | (((value as u32) & 0x01) << 11);
                self.w
            }
        }
        #[doc = "Reader of field `spi0_xip_en`"]
        pub type SPI0_XIP_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi0_xip_en`"]
        pub struct SPI0_XIP_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI0_XIP_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | (((value as u32) & 0x01) << 12);
                self.w
            }
        }
        #[doc = "Reader of field `spi1_xip_en`"]
        pub type SPI1_XIP_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi1_xip_en`"]
        pub struct SPI1_XIP_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1_XIP_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | (((value as u32) & 0x01) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `spi2_xip_en`"]
        pub type SPI2_XIP_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi2_xip_en`"]
        pub struct SPI2_XIP_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2_XIP_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | (((value as u32) & 0x01) << 14);
                self.w
            }
        }
        #[doc = "Reader of field `spi3_xip_en`"]
        pub type SPI3_XIP_EN_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi3_xip_en`"]
        pub struct SPI3_XIP_EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3_XIP_EN_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | (((value as u32) & 0x01) << 15);
                self.w
            }
        }
        #[doc = "Reader of field `spi0_clk_bypass`"]
        pub type SPI0_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi0_clk_bypass`"]
        pub struct SPI0_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI0_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | (((value as u32) & 0x01) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `spi1_clk_bypass`"]
        pub type SPI1_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi1_clk_bypass`"]
        pub struct SPI1_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | (((value as u32) & 0x01) << 17);
                self.w
            }
        }
        #[doc = "Reader of field `spi2_clk_bypass`"]
        pub type SPI2_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `spi2_clk_bypass`"]
        pub struct SPI2_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | (((value as u32) & 0x01) << 18);
                self.w
            }
        }
        #[doc = "Reader of field `i2s0_clk_bypass`"]
        pub type I2S0_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s0_clk_bypass`"]
        pub struct I2S0_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S0_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | (((value as u32) & 0x01) << 19);
                self.w
            }
        }
        #[doc = "Reader of field `i2s1_clk_bypass`"]
        pub type I2S1_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s1_clk_bypass`"]
        pub struct I2S1_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S1_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | (((value as u32) & 0x01) << 20);
                self.w
            }
        }
        #[doc = "Reader of field `i2s2_clk_bypass`"]
        pub type I2S2_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `i2s2_clk_bypass`"]
        pub struct I2S2_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2S2_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | (((value as u32) & 0x01) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `jtag_clk_bypass`"]
        pub type JTAG_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `jtag_clk_bypass`"]
        pub struct JTAG_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JTAG_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | (((value as u32) & 0x01) << 22);
                self.w
            }
        }
        #[doc = "Reader of field `dvp_clk_bypass`"]
        pub type DVP_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dvp_clk_bypass`"]
        pub struct DVP_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DVP_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | (((value as u32) & 0x01) << 23);
                self.w
            }
        }
        #[doc = "Reader of field `debug_clk_bypass`"]
        pub type DEBUG_CLK_BYPASS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `debug_clk_bypass`"]
        pub struct DEBUG_CLK_BYPASS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DEBUG_CLK_BYPASS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | (((value as u32) & 0x01) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn timer0_pause(&self) -> TIMER0_PAUSE_R {
                TIMER0_PAUSE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn timer1_pause(&self) -> TIMER1_PAUSE_R {
                TIMER1_PAUSE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn timer2_pause(&self) -> TIMER2_PAUSE_R {
                TIMER2_PAUSE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn timer3_pause(&self) -> TIMER3_PAUSE_R {
                TIMER3_PAUSE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn timer4_pause(&self) -> TIMER4_PAUSE_R {
                TIMER4_PAUSE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn timer5_pause(&self) -> TIMER5_PAUSE_R {
                TIMER5_PAUSE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn timer6_pause(&self) -> TIMER6_PAUSE_R {
                TIMER6_PAUSE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn timer7_pause(&self) -> TIMER7_PAUSE_R {
                TIMER7_PAUSE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn timer8_pause(&self) -> TIMER8_PAUSE_R {
                TIMER8_PAUSE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn timer9_pause(&self) -> TIMER9_PAUSE_R {
                TIMER9_PAUSE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn timer10_pause(&self) -> TIMER10_PAUSE_R {
                TIMER10_PAUSE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn timer11_pause(&self) -> TIMER11_PAUSE_R {
                TIMER11_PAUSE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn spi0_xip_en(&self) -> SPI0_XIP_EN_R {
                SPI0_XIP_EN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn spi1_xip_en(&self) -> SPI1_XIP_EN_R {
                SPI1_XIP_EN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn spi2_xip_en(&self) -> SPI2_XIP_EN_R {
                SPI2_XIP_EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn spi3_xip_en(&self) -> SPI3_XIP_EN_R {
                SPI3_XIP_EN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn spi0_clk_bypass(&self) -> SPI0_CLK_BYPASS_R {
                SPI0_CLK_BYPASS_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn spi1_clk_bypass(&self) -> SPI1_CLK_BYPASS_R {
                SPI1_CLK_BYPASS_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn spi2_clk_bypass(&self) -> SPI2_CLK_BYPASS_R {
                SPI2_CLK_BYPASS_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn i2s0_clk_bypass(&self) -> I2S0_CLK_BYPASS_R {
                I2S0_CLK_BYPASS_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn i2s1_clk_bypass(&self) -> I2S1_CLK_BYPASS_R {
                I2S1_CLK_BYPASS_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn i2s2_clk_bypass(&self) -> I2S2_CLK_BYPASS_R {
                I2S2_CLK_BYPASS_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn jtag_clk_bypass(&self) -> JTAG_CLK_BYPASS_R {
                JTAG_CLK_BYPASS_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn dvp_clk_bypass(&self) -> DVP_CLK_BYPASS_R {
                DVP_CLK_BYPASS_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn debug_clk_bypass(&self) -> DEBUG_CLK_BYPASS_R {
                DEBUG_CLK_BYPASS_R::new(((self.bits >> 24) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn timer0_pause(&mut self) -> TIMER0_PAUSE_W {
                TIMER0_PAUSE_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn timer1_pause(&mut self) -> TIMER1_PAUSE_W {
                TIMER1_PAUSE_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn timer2_pause(&mut self) -> TIMER2_PAUSE_W {
                TIMER2_PAUSE_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn timer3_pause(&mut self) -> TIMER3_PAUSE_W {
                TIMER3_PAUSE_W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn timer4_pause(&mut self) -> TIMER4_PAUSE_W {
                TIMER4_PAUSE_W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn timer5_pause(&mut self) -> TIMER5_PAUSE_W {
                TIMER5_PAUSE_W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn timer6_pause(&mut self) -> TIMER6_PAUSE_W {
                TIMER6_PAUSE_W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn timer7_pause(&mut self) -> TIMER7_PAUSE_W {
                TIMER7_PAUSE_W { w: self }
            }
            #[doc = "Bit 8"]
            #[inline(always)]
            pub fn timer8_pause(&mut self) -> TIMER8_PAUSE_W {
                TIMER8_PAUSE_W { w: self }
            }
            #[doc = "Bit 9"]
            #[inline(always)]
            pub fn timer9_pause(&mut self) -> TIMER9_PAUSE_W {
                TIMER9_PAUSE_W { w: self }
            }
            #[doc = "Bit 10"]
            #[inline(always)]
            pub fn timer10_pause(&mut self) -> TIMER10_PAUSE_W {
                TIMER10_PAUSE_W { w: self }
            }
            #[doc = "Bit 11"]
            #[inline(always)]
            pub fn timer11_pause(&mut self) -> TIMER11_PAUSE_W {
                TIMER11_PAUSE_W { w: self }
            }
            #[doc = "Bit 12"]
            #[inline(always)]
            pub fn spi0_xip_en(&mut self) -> SPI0_XIP_EN_W {
                SPI0_XIP_EN_W { w: self }
            }
            #[doc = "Bit 13"]
            #[inline(always)]
            pub fn spi1_xip_en(&mut self) -> SPI1_XIP_EN_W {
                SPI1_XIP_EN_W { w: self }
            }
            #[doc = "Bit 14"]
            #[inline(always)]
            pub fn spi2_xip_en(&mut self) -> SPI2_XIP_EN_W {
                SPI2_XIP_EN_W { w: self }
            }
            #[doc = "Bit 15"]
            #[inline(always)]
            pub fn spi3_xip_en(&mut self) -> SPI3_XIP_EN_W {
                SPI3_XIP_EN_W { w: self }
            }
            #[doc = "Bit 16"]
            #[inline(always)]
            pub fn spi0_clk_bypass(&mut self) -> SPI0_CLK_BYPASS_W {
                SPI0_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 17"]
            #[inline(always)]
            pub fn spi1_clk_bypass(&mut self) -> SPI1_CLK_BYPASS_W {
                SPI1_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 18"]
            #[inline(always)]
            pub fn spi2_clk_bypass(&mut self) -> SPI2_CLK_BYPASS_W {
                SPI2_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 19"]
            #[inline(always)]
            pub fn i2s0_clk_bypass(&mut self) -> I2S0_CLK_BYPASS_W {
                I2S0_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 20"]
            #[inline(always)]
            pub fn i2s1_clk_bypass(&mut self) -> I2S1_CLK_BYPASS_W {
                I2S1_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 21"]
            #[inline(always)]
            pub fn i2s2_clk_bypass(&mut self) -> I2S2_CLK_BYPASS_W {
                I2S2_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 22"]
            #[inline(always)]
            pub fn jtag_clk_bypass(&mut self) -> JTAG_CLK_BYPASS_W {
                JTAG_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 23"]
            #[inline(always)]
            pub fn dvp_clk_bypass(&mut self) -> DVP_CLK_BYPASS_W {
                DVP_CLK_BYPASS_W { w: self }
            }
            #[doc = "Bit 24"]
            #[inline(always)]
            pub fn debug_clk_bypass(&mut self) -> DEBUG_CLK_BYPASS_W {
                DEBUG_CLK_BYPASS_W { w: self }
            }
        }
    }
    #[doc = "SPI sleep controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [spi_sleep](spi_sleep) module"]
    pub type SPI_SLEEP = crate::Reg<u32, _SPI_SLEEP>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _SPI_SLEEP;
    #[doc = "`read()` method returns [spi_sleep::R](spi_sleep::R) reader structure"]
    impl crate::Readable for SPI_SLEEP {}
    #[doc = "`write(|w| ..)` method takes [spi_sleep::W](spi_sleep::W) writer structure"]
    impl crate::Writable for SPI_SLEEP {}
    #[doc = "SPI sleep controller"]
    pub mod spi_sleep {
        #[doc = "Reader of register spi_sleep"]
        pub type R = crate::R<u32, super::SPI_SLEEP>;
        #[doc = "Writer for register spi_sleep"]
        pub type W = crate::W<u32, super::SPI_SLEEP>;
        #[doc = "Register spi_sleep `reset()`'s with value 0"]
        impl crate::ResetValue for super::SPI_SLEEP {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `ssi0_sleep`"]
        pub type SSI0_SLEEP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ssi0_sleep`"]
        pub struct SSI0_SLEEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSI0_SLEEP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `ssi1_sleep`"]
        pub type SSI1_SLEEP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ssi1_sleep`"]
        pub struct SSI1_SLEEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSI1_SLEEP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `ssi2_sleep`"]
        pub type SSI2_SLEEP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ssi2_sleep`"]
        pub struct SSI2_SLEEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSI2_SLEEP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `ssi3_sleep`"]
        pub type SSI3_SLEEP_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `ssi3_sleep`"]
        pub struct SSI3_SLEEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSI3_SLEEP_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn ssi0_sleep(&self) -> SSI0_SLEEP_R {
                SSI0_SLEEP_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn ssi1_sleep(&self) -> SSI1_SLEEP_R {
                SSI1_SLEEP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn ssi2_sleep(&self) -> SSI2_SLEEP_R {
                SSI2_SLEEP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn ssi3_sleep(&self) -> SSI3_SLEEP_R {
                SSI3_SLEEP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn ssi0_sleep(&mut self) -> SSI0_SLEEP_W {
                SSI0_SLEEP_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn ssi1_sleep(&mut self) -> SSI1_SLEEP_W {
                SSI1_SLEEP_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn ssi2_sleep(&mut self) -> SSI2_SLEEP_W {
                SSI2_SLEEP_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn ssi3_sleep(&mut self) -> SSI3_SLEEP_W {
                SSI3_SLEEP_W { w: self }
            }
        }
    }
    #[doc = "Reset source status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [reset_status](reset_status) module"]
    pub type RESET_STATUS = crate::Reg<u32, _RESET_STATUS>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _RESET_STATUS;
    #[doc = "`read()` method returns [reset_status::R](reset_status::R) reader structure"]
    impl crate::Readable for RESET_STATUS {}
    #[doc = "`write(|w| ..)` method takes [reset_status::W](reset_status::W) writer structure"]
    impl crate::Writable for RESET_STATUS {}
    #[doc = "Reset source status"]
    pub mod reset_status {
        #[doc = "Reader of register reset_status"]
        pub type R = crate::R<u32, super::RESET_STATUS>;
        #[doc = "Writer for register reset_status"]
        pub type W = crate::W<u32, super::RESET_STATUS>;
        #[doc = "Register reset_status `reset()`'s with value 0"]
        impl crate::ResetValue for super::RESET_STATUS {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `reset_sts_clr`"]
        pub type RESET_STS_CLR_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `reset_sts_clr`"]
        pub struct RESET_STS_CLR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_STS_CLR_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `pin_reset_sts`"]
        pub type PIN_RESET_STS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `pin_reset_sts`"]
        pub struct PIN_RESET_STS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIN_RESET_STS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `wdt0_reset_sts`"]
        pub type WDT0_RESET_STS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `wdt0_reset_sts`"]
        pub struct WDT0_RESET_STS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT0_RESET_STS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `wdt1_reset_sts`"]
        pub type WDT1_RESET_STS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `wdt1_reset_sts`"]
        pub struct WDT1_RESET_STS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDT1_RESET_STS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `soft_reset_sts`"]
        pub type SOFT_RESET_STS_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `soft_reset_sts`"]
        pub struct SOFT_RESET_STS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SOFT_RESET_STS_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn reset_sts_clr(&self) -> RESET_STS_CLR_R {
                RESET_STS_CLR_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin_reset_sts(&self) -> PIN_RESET_STS_R {
                PIN_RESET_STS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn wdt0_reset_sts(&self) -> WDT0_RESET_STS_R {
                WDT0_RESET_STS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn wdt1_reset_sts(&self) -> WDT1_RESET_STS_R {
                WDT1_RESET_STS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn soft_reset_sts(&self) -> SOFT_RESET_STS_R {
                SOFT_RESET_STS_R::new(((self.bits >> 4) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn reset_sts_clr(&mut self) -> RESET_STS_CLR_W {
                RESET_STS_CLR_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn pin_reset_sts(&mut self) -> PIN_RESET_STS_W {
                PIN_RESET_STS_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn wdt0_reset_sts(&mut self) -> WDT0_RESET_STS_W {
                WDT0_RESET_STS_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn wdt1_reset_sts(&mut self) -> WDT1_RESET_STS_W {
                WDT1_RESET_STS_W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn soft_reset_sts(&mut self) -> SOFT_RESET_STS_W {
                SOFT_RESET_STS_W { w: self }
            }
        }
    }
    #[doc = "DMA handshake selector\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dma_sel0](dma_sel0) module"]
    pub type DMA_SEL0 = crate::Reg<u32, _DMA_SEL0>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMA_SEL0;
    #[doc = "`read()` method returns [dma_sel0::R](dma_sel0::R) reader structure"]
    impl crate::Readable for DMA_SEL0 {}
    #[doc = "`write(|w| ..)` method takes [dma_sel0::W](dma_sel0::W) writer structure"]
    impl crate::Writable for DMA_SEL0 {}
    #[doc = "DMA handshake selector"]
    pub mod dma_sel0 {
        #[doc = "Reader of register dma_sel0"]
        pub type R = crate::R<u32, super::DMA_SEL0>;
        #[doc = "Writer for register dma_sel0"]
        pub type W = crate::W<u32, super::DMA_SEL0>;
        #[doc = "Register dma_sel0 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMA_SEL0 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum DMA_SEL0_A {
            #[doc = "0: `0`"]
            SSI0_RX_REQ = 0,
            #[doc = "1: `1`"]
            SSI0_TX_REQ = 1,
            #[doc = "2: `10`"]
            SSI1_RX_REQ = 2,
            #[doc = "3: `11`"]
            SSI1_TX_REQ = 3,
            #[doc = "4: `100`"]
            SSI2_RX_REQ = 4,
            #[doc = "5: `101`"]
            SSI2_TX_REQ = 5,
            #[doc = "6: `110`"]
            SSI3_RX_REQ = 6,
            #[doc = "7: `111`"]
            SSI3_TX_REQ = 7,
            #[doc = "8: `1000`"]
            I2C0_RX_REQ = 8,
            #[doc = "9: `1001`"]
            I2C0_TX_REQ = 9,
            #[doc = "10: `1010`"]
            I2C1_RX_REQ = 10,
            #[doc = "11: `1011`"]
            I2C1_TX_REQ = 11,
            #[doc = "12: `1100`"]
            I2C2_RX_REQ = 12,
            #[doc = "13: `1101`"]
            I2C2_TX_REQ = 13,
            #[doc = "14: `1110`"]
            UART1_RX_REQ = 14,
            #[doc = "15: `1111`"]
            UART1_TX_REQ = 15,
            #[doc = "16: `10000`"]
            UART2_RX_REQ = 16,
            #[doc = "17: `10001`"]
            UART2_TX_REQ = 17,
            #[doc = "18: `10010`"]
            UART3_RX_REQ = 18,
            #[doc = "19: `10011`"]
            UART3_TX_REQ = 19,
            #[doc = "20: `10100`"]
            AES_REQ = 20,
            #[doc = "21: `10101`"]
            SHA_RX_REQ = 21,
            #[doc = "22: `10110`"]
            AI_RX_REQ = 22,
            #[doc = "23: `10111`"]
            FFT_RX_REQ = 23,
            #[doc = "24: `11000`"]
            FFT_TX_REQ = 24,
            #[doc = "25: `11001`"]
            I2S0_TX_REQ = 25,
            #[doc = "26: `11010`"]
            I2S0_RX_REQ = 26,
            #[doc = "27: `11011`"]
            I2S1_TX_REQ = 27,
            #[doc = "28: `11100`"]
            I2S1_RX_REQ = 28,
            #[doc = "29: `11101`"]
            I2S2_TX_REQ = 29,
            #[doc = "30: `11110`"]
            I2S2_RX_REQ = 30,
            #[doc = "31: `11111`"]
            I2S0_BF_DIR_REQ = 31,
            #[doc = "32: `100000`"]
            I2S0_BF_VOICE_REQ = 32,
        }
        impl From<DMA_SEL0_A> for u8 {
            #[inline(always)]
            fn from(variant: DMA_SEL0_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `dma_sel0`"]
        pub type DMA_SEL0_R = crate::R<u8, DMA_SEL0_A>;
        impl DMA_SEL0_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, DMA_SEL0_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(DMA_SEL0_A::SSI0_RX_REQ),
                    1 => Val(DMA_SEL0_A::SSI0_TX_REQ),
                    2 => Val(DMA_SEL0_A::SSI1_RX_REQ),
                    3 => Val(DMA_SEL0_A::SSI1_TX_REQ),
                    4 => Val(DMA_SEL0_A::SSI2_RX_REQ),
                    5 => Val(DMA_SEL0_A::SSI2_TX_REQ),
                    6 => Val(DMA_SEL0_A::SSI3_RX_REQ),
                    7 => Val(DMA_SEL0_A::SSI3_TX_REQ),
                    8 => Val(DMA_SEL0_A::I2C0_RX_REQ),
                    9 => Val(DMA_SEL0_A::I2C0_TX_REQ),
                    10 => Val(DMA_SEL0_A::I2C1_RX_REQ),
                    11 => Val(DMA_SEL0_A::I2C1_TX_REQ),
                    12 => Val(DMA_SEL0_A::I2C2_RX_REQ),
                    13 => Val(DMA_SEL0_A::I2C2_TX_REQ),
                    14 => Val(DMA_SEL0_A::UART1_RX_REQ),
                    15 => Val(DMA_SEL0_A::UART1_TX_REQ),
                    16 => Val(DMA_SEL0_A::UART2_RX_REQ),
                    17 => Val(DMA_SEL0_A::UART2_TX_REQ),
                    18 => Val(DMA_SEL0_A::UART3_RX_REQ),
                    19 => Val(DMA_SEL0_A::UART3_TX_REQ),
                    20 => Val(DMA_SEL0_A::AES_REQ),
                    21 => Val(DMA_SEL0_A::SHA_RX_REQ),
                    22 => Val(DMA_SEL0_A::AI_RX_REQ),
                    23 => Val(DMA_SEL0_A::FFT_RX_REQ),
                    24 => Val(DMA_SEL0_A::FFT_TX_REQ),
                    25 => Val(DMA_SEL0_A::I2S0_TX_REQ),
                    26 => Val(DMA_SEL0_A::I2S0_RX_REQ),
                    27 => Val(DMA_SEL0_A::I2S1_TX_REQ),
                    28 => Val(DMA_SEL0_A::I2S1_RX_REQ),
                    29 => Val(DMA_SEL0_A::I2S2_TX_REQ),
                    30 => Val(DMA_SEL0_A::I2S2_RX_REQ),
                    31 => Val(DMA_SEL0_A::I2S0_BF_DIR_REQ),
                    32 => Val(DMA_SEL0_A::I2S0_BF_VOICE_REQ),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `SSI0_RX_REQ`"]
            #[inline(always)]
            pub fn is_ssi0_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI0_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI0_TX_REQ`"]
            #[inline(always)]
            pub fn is_ssi0_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI0_TX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI1_RX_REQ`"]
            #[inline(always)]
            pub fn is_ssi1_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI1_TX_REQ`"]
            #[inline(always)]
            pub fn is_ssi1_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI2_RX_REQ`"]
            #[inline(always)]
            pub fn is_ssi2_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI2_TX_REQ`"]
            #[inline(always)]
            pub fn is_ssi2_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI3_RX_REQ`"]
            #[inline(always)]
            pub fn is_ssi3_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI3_RX_REQ
            }
            #[doc = "Checks if the value of the field is `SSI3_TX_REQ`"]
            #[inline(always)]
            pub fn is_ssi3_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::SSI3_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C0_RX_REQ`"]
            #[inline(always)]
            pub fn is_i2c0_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2C0_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C0_TX_REQ`"]
            #[inline(always)]
            pub fn is_i2c0_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2C0_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C1_RX_REQ`"]
            #[inline(always)]
            pub fn is_i2c1_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2C1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C1_TX_REQ`"]
            #[inline(always)]
            pub fn is_i2c1_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2C1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C2_RX_REQ`"]
            #[inline(always)]
            pub fn is_i2c2_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2C2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2C2_TX_REQ`"]
            #[inline(always)]
            pub fn is_i2c2_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2C2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `UART1_RX_REQ`"]
            #[inline(always)]
            pub fn is_uart1_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::UART1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `UART1_TX_REQ`"]
            #[inline(always)]
            pub fn is_uart1_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::UART1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `UART2_RX_REQ`"]
            #[inline(always)]
            pub fn is_uart2_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::UART2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `UART2_TX_REQ`"]
            #[inline(always)]
            pub fn is_uart2_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::UART2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `UART3_RX_REQ`"]
            #[inline(always)]
            pub fn is_uart3_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::UART3_RX_REQ
            }
            #[doc = "Checks if the value of the field is `UART3_TX_REQ`"]
            #[inline(always)]
            pub fn is_uart3_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::UART3_TX_REQ
            }
            #[doc = "Checks if the value of the field is `AES_REQ`"]
            #[inline(always)]
            pub fn is_aes_req(&self) -> bool {
                *self == DMA_SEL0_A::AES_REQ
            }
            #[doc = "Checks if the value of the field is `SHA_RX_REQ`"]
            #[inline(always)]
            pub fn is_sha_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::SHA_RX_REQ
            }
            #[doc = "Checks if the value of the field is `AI_RX_REQ`"]
            #[inline(always)]
            pub fn is_ai_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::AI_RX_REQ
            }
            #[doc = "Checks if the value of the field is `FFT_RX_REQ`"]
            #[inline(always)]
            pub fn is_fft_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::FFT_RX_REQ
            }
            #[doc = "Checks if the value of the field is `FFT_TX_REQ`"]
            #[inline(always)]
            pub fn is_fft_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::FFT_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_TX_REQ`"]
            #[inline(always)]
            pub fn is_i2s0_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S0_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_RX_REQ`"]
            #[inline(always)]
            pub fn is_i2s0_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S0_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S1_TX_REQ`"]
            #[inline(always)]
            pub fn is_i2s1_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S1_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S1_RX_REQ`"]
            #[inline(always)]
            pub fn is_i2s1_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S1_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S2_TX_REQ`"]
            #[inline(always)]
            pub fn is_i2s2_tx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S2_TX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S2_RX_REQ`"]
            #[inline(always)]
            pub fn is_i2s2_rx_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S2_RX_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_BF_DIR_REQ`"]
            #[inline(always)]
            pub fn is_i2s0_bf_dir_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S0_BF_DIR_REQ
            }
            #[doc = "Checks if the value of the field is `I2S0_BF_VOICE_REQ`"]
            #[inline(always)]
            pub fn is_i2s0_bf_voice_req(&self) -> bool {
                *self == DMA_SEL0_A::I2S0_BF_VOICE_REQ
            }
        }
        #[doc = "Write proxy for field `dma_sel0`"]
        pub struct DMA_SEL0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEL0_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA_SEL0_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline(always)]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline(always)]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline(always)]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline(always)]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline(always)]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline(always)]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline(always)]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline(always)]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline(always)]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline(always)]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline(always)]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline(always)]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline(always)]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline(always)]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline(always)]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline(always)]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline(always)]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline(always)]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline(always)]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline(always)]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline(always)]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline(always)]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline(always)]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline(always)]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline(always)]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL0_A::I2S0_BF_VOICE_REQ)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3f) | ((value as u32) & 0x3f);
                self.w
            }
        }
        #[doc = ""]
        pub type DMA_SEL1_A = DMA_SEL0_A;
        #[doc = "Reader of field `dma_sel1`"]
        pub type DMA_SEL1_R = crate::R<u8, DMA_SEL1_A>;
        #[doc = "Write proxy for field `dma_sel1`"]
        pub struct DMA_SEL1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEL1_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA_SEL1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline(always)]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline(always)]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline(always)]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline(always)]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline(always)]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline(always)]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline(always)]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline(always)]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline(always)]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline(always)]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline(always)]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline(always)]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline(always)]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline(always)]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline(always)]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline(always)]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline(always)]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline(always)]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline(always)]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline(always)]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline(always)]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline(always)]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline(always)]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline(always)]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline(always)]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL1_A::I2S0_BF_VOICE_REQ)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 6)) | (((value as u32) & 0x3f) << 6);
                self.w
            }
        }
        #[doc = ""]
        pub type DMA_SEL2_A = DMA_SEL0_A;
        #[doc = "Reader of field `dma_sel2`"]
        pub type DMA_SEL2_R = crate::R<u8, DMA_SEL2_A>;
        #[doc = "Write proxy for field `dma_sel2`"]
        pub struct DMA_SEL2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEL2_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA_SEL2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline(always)]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline(always)]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline(always)]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline(always)]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline(always)]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline(always)]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline(always)]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline(always)]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline(always)]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline(always)]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline(always)]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline(always)]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline(always)]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline(always)]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline(always)]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline(always)]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline(always)]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline(always)]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline(always)]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline(always)]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline(always)]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline(always)]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline(always)]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline(always)]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline(always)]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL2_A::I2S0_BF_VOICE_REQ)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 12)) | (((value as u32) & 0x3f) << 12);
                self.w
            }
        }
        #[doc = ""]
        pub type DMA_SEL3_A = DMA_SEL0_A;
        #[doc = "Reader of field `dma_sel3`"]
        pub type DMA_SEL3_R = crate::R<u8, DMA_SEL3_A>;
        #[doc = "Write proxy for field `dma_sel3`"]
        pub struct DMA_SEL3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEL3_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA_SEL3_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline(always)]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline(always)]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline(always)]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline(always)]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline(always)]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline(always)]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline(always)]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline(always)]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline(always)]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline(always)]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline(always)]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline(always)]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline(always)]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline(always)]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline(always)]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline(always)]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline(always)]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline(always)]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline(always)]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline(always)]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline(always)]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline(always)]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline(always)]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline(always)]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline(always)]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL3_A::I2S0_BF_VOICE_REQ)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 18)) | (((value as u32) & 0x3f) << 18);
                self.w
            }
        }
        #[doc = ""]
        pub type DMA_SEL4_A = DMA_SEL0_A;
        #[doc = "Reader of field `dma_sel4`"]
        pub type DMA_SEL4_R = crate::R<u8, DMA_SEL4_A>;
        #[doc = "Write proxy for field `dma_sel4`"]
        pub struct DMA_SEL4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEL4_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA_SEL4_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline(always)]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline(always)]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline(always)]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline(always)]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline(always)]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline(always)]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline(always)]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline(always)]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline(always)]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline(always)]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline(always)]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline(always)]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline(always)]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline(always)]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline(always)]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline(always)]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline(always)]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline(always)]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline(always)]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline(always)]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline(always)]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline(always)]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline(always)]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline(always)]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline(always)]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL4_A::I2S0_BF_VOICE_REQ)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 24)) | (((value as u32) & 0x3f) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn dma_sel0(&self) -> DMA_SEL0_R {
                DMA_SEL0_R::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bits 6:11"]
            #[inline(always)]
            pub fn dma_sel1(&self) -> DMA_SEL1_R {
                DMA_SEL1_R::new(((self.bits >> 6) & 0x3f) as u8)
            }
            #[doc = "Bits 12:17"]
            #[inline(always)]
            pub fn dma_sel2(&self) -> DMA_SEL2_R {
                DMA_SEL2_R::new(((self.bits >> 12) & 0x3f) as u8)
            }
            #[doc = "Bits 18:23"]
            #[inline(always)]
            pub fn dma_sel3(&self) -> DMA_SEL3_R {
                DMA_SEL3_R::new(((self.bits >> 18) & 0x3f) as u8)
            }
            #[doc = "Bits 24:29"]
            #[inline(always)]
            pub fn dma_sel4(&self) -> DMA_SEL4_R {
                DMA_SEL4_R::new(((self.bits >> 24) & 0x3f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn dma_sel0(&mut self) -> DMA_SEL0_W {
                DMA_SEL0_W { w: self }
            }
            #[doc = "Bits 6:11"]
            #[inline(always)]
            pub fn dma_sel1(&mut self) -> DMA_SEL1_W {
                DMA_SEL1_W { w: self }
            }
            #[doc = "Bits 12:17"]
            #[inline(always)]
            pub fn dma_sel2(&mut self) -> DMA_SEL2_W {
                DMA_SEL2_W { w: self }
            }
            #[doc = "Bits 18:23"]
            #[inline(always)]
            pub fn dma_sel3(&mut self) -> DMA_SEL3_W {
                DMA_SEL3_W { w: self }
            }
            #[doc = "Bits 24:29"]
            #[inline(always)]
            pub fn dma_sel4(&mut self) -> DMA_SEL4_W {
                DMA_SEL4_W { w: self }
            }
        }
    }
    #[doc = "DMA handshake selector\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dma_sel1](dma_sel1) module"]
    pub type DMA_SEL1 = crate::Reg<u32, _DMA_SEL1>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMA_SEL1;
    #[doc = "`read()` method returns [dma_sel1::R](dma_sel1::R) reader structure"]
    impl crate::Readable for DMA_SEL1 {}
    #[doc = "`write(|w| ..)` method takes [dma_sel1::W](dma_sel1::W) writer structure"]
    impl crate::Writable for DMA_SEL1 {}
    #[doc = "DMA handshake selector"]
    pub mod dma_sel1 {
        #[doc = "Reader of register dma_sel1"]
        pub type R = crate::R<u32, super::DMA_SEL1>;
        #[doc = "Writer for register dma_sel1"]
        pub type W = crate::W<u32, super::DMA_SEL1>;
        #[doc = "Register dma_sel1 `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMA_SEL1 {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = ""]
        pub type DMA_SEL5_A = super::dma_sel0::DMA_SEL0_A;
        #[doc = "Reader of field `dma_sel5`"]
        pub type DMA_SEL5_R = crate::R<u8, DMA_SEL5_A>;
        #[doc = "Write proxy for field `dma_sel5`"]
        pub struct DMA_SEL5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEL5_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DMA_SEL5_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "`0`"]
            #[inline(always)]
            pub fn ssi0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI0_RX_REQ)
            }
            #[doc = "`1`"]
            #[inline(always)]
            pub fn ssi0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI0_TX_REQ)
            }
            #[doc = "`10`"]
            #[inline(always)]
            pub fn ssi1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI1_RX_REQ)
            }
            #[doc = "`11`"]
            #[inline(always)]
            pub fn ssi1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI1_TX_REQ)
            }
            #[doc = "`100`"]
            #[inline(always)]
            pub fn ssi2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI2_RX_REQ)
            }
            #[doc = "`101`"]
            #[inline(always)]
            pub fn ssi2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI2_TX_REQ)
            }
            #[doc = "`110`"]
            #[inline(always)]
            pub fn ssi3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI3_RX_REQ)
            }
            #[doc = "`111`"]
            #[inline(always)]
            pub fn ssi3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SSI3_TX_REQ)
            }
            #[doc = "`1000`"]
            #[inline(always)]
            pub fn i2c0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2C0_RX_REQ)
            }
            #[doc = "`1001`"]
            #[inline(always)]
            pub fn i2c0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2C0_TX_REQ)
            }
            #[doc = "`1010`"]
            #[inline(always)]
            pub fn i2c1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2C1_RX_REQ)
            }
            #[doc = "`1011`"]
            #[inline(always)]
            pub fn i2c1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2C1_TX_REQ)
            }
            #[doc = "`1100`"]
            #[inline(always)]
            pub fn i2c2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2C2_RX_REQ)
            }
            #[doc = "`1101`"]
            #[inline(always)]
            pub fn i2c2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2C2_TX_REQ)
            }
            #[doc = "`1110`"]
            #[inline(always)]
            pub fn uart1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::UART1_RX_REQ)
            }
            #[doc = "`1111`"]
            #[inline(always)]
            pub fn uart1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::UART1_TX_REQ)
            }
            #[doc = "`10000`"]
            #[inline(always)]
            pub fn uart2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::UART2_RX_REQ)
            }
            #[doc = "`10001`"]
            #[inline(always)]
            pub fn uart2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::UART2_TX_REQ)
            }
            #[doc = "`10010`"]
            #[inline(always)]
            pub fn uart3_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::UART3_RX_REQ)
            }
            #[doc = "`10011`"]
            #[inline(always)]
            pub fn uart3_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::UART3_TX_REQ)
            }
            #[doc = "`10100`"]
            #[inline(always)]
            pub fn aes_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::AES_REQ)
            }
            #[doc = "`10101`"]
            #[inline(always)]
            pub fn sha_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::SHA_RX_REQ)
            }
            #[doc = "`10110`"]
            #[inline(always)]
            pub fn ai_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::AI_RX_REQ)
            }
            #[doc = "`10111`"]
            #[inline(always)]
            pub fn fft_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::FFT_RX_REQ)
            }
            #[doc = "`11000`"]
            #[inline(always)]
            pub fn fft_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::FFT_TX_REQ)
            }
            #[doc = "`11001`"]
            #[inline(always)]
            pub fn i2s0_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S0_TX_REQ)
            }
            #[doc = "`11010`"]
            #[inline(always)]
            pub fn i2s0_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S0_RX_REQ)
            }
            #[doc = "`11011`"]
            #[inline(always)]
            pub fn i2s1_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S1_TX_REQ)
            }
            #[doc = "`11100`"]
            #[inline(always)]
            pub fn i2s1_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S1_RX_REQ)
            }
            #[doc = "`11101`"]
            #[inline(always)]
            pub fn i2s2_tx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S2_TX_REQ)
            }
            #[doc = "`11110`"]
            #[inline(always)]
            pub fn i2s2_rx_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S2_RX_REQ)
            }
            #[doc = "`11111`"]
            #[inline(always)]
            pub fn i2s0_bf_dir_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S0_BF_DIR_REQ)
            }
            #[doc = "`100000`"]
            #[inline(always)]
            pub fn i2s0_bf_voice_req(self) -> &'a mut W {
                self.variant(DMA_SEL5_A::I2S0_BF_VOICE_REQ)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3f) | ((value as u32) & 0x3f);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn dma_sel5(&self) -> DMA_SEL5_R {
                DMA_SEL5_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:5"]
            #[inline(always)]
            pub fn dma_sel5(&mut self) -> DMA_SEL5_W {
                DMA_SEL5_W { w: self }
            }
        }
    }
    #[doc = "IO Power Mode Select controller\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [power_sel](power_sel) module"]
    pub type POWER_SEL = crate::Reg<u32, _POWER_SEL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _POWER_SEL;
    #[doc = "`read()` method returns [power_sel::R](power_sel::R) reader structure"]
    impl crate::Readable for POWER_SEL {}
    #[doc = "`write(|w| ..)` method takes [power_sel::W](power_sel::W) writer structure"]
    impl crate::Writable for POWER_SEL {}
    #[doc = "IO Power Mode Select controller"]
    pub mod power_sel {
        #[doc = "Reader of register power_sel"]
        pub type R = crate::R<u32, super::POWER_SEL>;
        #[doc = "Writer for register power_sel"]
        pub type W = crate::W<u32, super::POWER_SEL>;
        #[doc = "Register power_sel `reset()`'s with value 0"]
        impl crate::ResetValue for super::POWER_SEL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `power_mode_sel0`"]
        pub type POWER_MODE_SEL0_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel0`"]
        pub struct POWER_MODE_SEL0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL0_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `power_mode_sel1`"]
        pub type POWER_MODE_SEL1_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel1`"]
        pub struct POWER_MODE_SEL1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL1_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `power_mode_sel2`"]
        pub type POWER_MODE_SEL2_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel2`"]
        pub struct POWER_MODE_SEL2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL2_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | (((value as u32) & 0x01) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `power_mode_sel3`"]
        pub type POWER_MODE_SEL3_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel3`"]
        pub struct POWER_MODE_SEL3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL3_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | (((value as u32) & 0x01) << 3);
                self.w
            }
        }
        #[doc = "Reader of field `power_mode_sel4`"]
        pub type POWER_MODE_SEL4_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel4`"]
        pub struct POWER_MODE_SEL4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL4_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | (((value as u32) & 0x01) << 4);
                self.w
            }
        }
        #[doc = "Reader of field `power_mode_sel5`"]
        pub type POWER_MODE_SEL5_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel5`"]
        pub struct POWER_MODE_SEL5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL5_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Reader of field `power_mode_sel6`"]
        pub type POWER_MODE_SEL6_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel6`"]
        pub struct POWER_MODE_SEL6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL6_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | (((value as u32) & 0x01) << 6);
                self.w
            }
        }
        #[doc = "Reader of field `power_mode_sel7`"]
        pub type POWER_MODE_SEL7_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `power_mode_sel7`"]
        pub struct POWER_MODE_SEL7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POWER_MODE_SEL7_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn power_mode_sel0(&self) -> POWER_MODE_SEL0_R {
                POWER_MODE_SEL0_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn power_mode_sel1(&self) -> POWER_MODE_SEL1_R {
                POWER_MODE_SEL1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn power_mode_sel2(&self) -> POWER_MODE_SEL2_R {
                POWER_MODE_SEL2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn power_mode_sel3(&self) -> POWER_MODE_SEL3_R {
                POWER_MODE_SEL3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn power_mode_sel4(&self) -> POWER_MODE_SEL4_R {
                POWER_MODE_SEL4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn power_mode_sel5(&self) -> POWER_MODE_SEL5_R {
                POWER_MODE_SEL5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn power_mode_sel6(&self) -> POWER_MODE_SEL6_R {
                POWER_MODE_SEL6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn power_mode_sel7(&self) -> POWER_MODE_SEL7_R {
                POWER_MODE_SEL7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0"]
            #[inline(always)]
            pub fn power_mode_sel0(&mut self) -> POWER_MODE_SEL0_W {
                POWER_MODE_SEL0_W { w: self }
            }
            #[doc = "Bit 1"]
            #[inline(always)]
            pub fn power_mode_sel1(&mut self) -> POWER_MODE_SEL1_W {
                POWER_MODE_SEL1_W { w: self }
            }
            #[doc = "Bit 2"]
            #[inline(always)]
            pub fn power_mode_sel2(&mut self) -> POWER_MODE_SEL2_W {
                POWER_MODE_SEL2_W { w: self }
            }
            #[doc = "Bit 3"]
            #[inline(always)]
            pub fn power_mode_sel3(&mut self) -> POWER_MODE_SEL3_W {
                POWER_MODE_SEL3_W { w: self }
            }
            #[doc = "Bit 4"]
            #[inline(always)]
            pub fn power_mode_sel4(&mut self) -> POWER_MODE_SEL4_W {
                POWER_MODE_SEL4_W { w: self }
            }
            #[doc = "Bit 5"]
            #[inline(always)]
            pub fn power_mode_sel5(&mut self) -> POWER_MODE_SEL5_W {
                POWER_MODE_SEL5_W { w: self }
            }
            #[doc = "Bit 6"]
            #[inline(always)]
            pub fn power_mode_sel6(&mut self) -> POWER_MODE_SEL6_W {
                POWER_MODE_SEL6_W { w: self }
            }
            #[doc = "Bit 7"]
            #[inline(always)]
            pub fn power_mode_sel7(&mut self) -> POWER_MODE_SEL7_W {
                POWER_MODE_SEL7_W { w: self }
            }
        }
    }
}
#[doc = "AES Accelerator"]
pub struct AES {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AES {}
impl AES {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const aes::RegisterBlock {
        0x5045_0000 as *const _
    }
}
impl Deref for AES {
    type Target = aes::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*AES::ptr() }
    }
}
#[doc = "AES Accelerator"]
pub mod aes {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - 1st-4th word of key"]
        pub key: [KEY; 4],
        #[doc = "0x10 - Encryption or decryption select"]
        pub encrypt_sel: ENCRYPT_SEL,
        #[doc = "0x14 - AES mode register"]
        pub mode_ctl: MODE_CTL,
        #[doc = "0x18 - Initialisation Vector (96 bit for GCM, 128 bit for CBC)"]
        pub iv: [IV; 4],
        #[doc = "0x28 - Endian control"]
        pub endian: ENDIAN,
        #[doc = "0x2c - Finished status"]
        pub finish: FINISH,
        #[doc = "0x30 - DMA select"]
        pub dma_sel: DMA_SEL,
        #[doc = "0x34 - GCM additional authenticated data count in bytes, minus one"]
        pub aad_num: AAD_NUM,
        _reserved8: [u8; 4usize],
        #[doc = "0x3c - Plaintext/ciphertext input data count in bytes, minus one"]
        pub pc_num: PC_NUM,
        #[doc = "0x40 - Plaintext/ciphertext input data"]
        pub text_data: TEXT_DATA,
        #[doc = "0x44 - Additional authenticated data"]
        pub aad_data: AAD_DATA,
        #[doc = "0x48 - Tag check status"]
        pub tag_chk: TAG_CHK,
        #[doc = "0x4c - Data can input flag"]
        pub data_in_flag: DATA_IN_FLAG,
        #[doc = "0x50 - GCM input tag for comparison with the calculated tag"]
        pub gcm_in_tag: [GCM_IN_TAG; 4],
        #[doc = "0x60 - Plaintext/ciphertext output data"]
        pub out_data: OUT_DATA,
        #[doc = "0x64 - AES module enable"]
        pub en: EN,
        #[doc = "0x68 - Data can output flag"]
        pub data_out_flag: DATA_OUT_FLAG,
        #[doc = "0x6c - Can input tag (when using GCM)"]
        pub tag_in_flag: TAG_IN_FLAG,
        #[doc = "0x70 - Tag clear (a write to this register clears the tag_chk status)"]
        pub tag_clear: TAG_CLEAR,
        #[doc = "0x74 - Computed GCM output tag"]
        pub gcm_out_tag: [GCM_OUT_TAG; 4],
        #[doc = "0x84 - 5th-8th word of key"]
        pub key_ext: [KEY_EXT; 4],
    }
    #[doc = "1st-4th word of key\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key](key) module"]
    pub type KEY = crate::Reg<u32, _KEY>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KEY;
    #[doc = "`read()` method returns [key::R](key::R) reader structure"]
    impl crate::Readable for KEY {}
    #[doc = "`write(|w| ..)` method takes [key::W](key::W) writer structure"]
    impl crate::Writable for KEY {}
    #[doc = "1st-4th word of key"]
    pub mod key {
        #[doc = "Reader of register key[%s]"]
        pub type R = crate::R<u32, super::KEY>;
        #[doc = "Writer for register key[%s]"]
        pub type W = crate::W<u32, super::KEY>;
        #[doc = "Register key[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::KEY {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Encryption or decryption select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [encrypt_sel](encrypt_sel) module"]
    pub type ENCRYPT_SEL = crate::Reg<u32, _ENCRYPT_SEL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ENCRYPT_SEL;
    #[doc = "`read()` method returns [encrypt_sel::R](encrypt_sel::R) reader structure"]
    impl crate::Readable for ENCRYPT_SEL {}
    #[doc = "`write(|w| ..)` method takes [encrypt_sel::W](encrypt_sel::W) writer structure"]
    impl crate::Writable for ENCRYPT_SEL {}
    #[doc = "Encryption or decryption select"]
    pub mod encrypt_sel {
        #[doc = "Reader of register encrypt_sel"]
        pub type R = crate::R<u32, super::ENCRYPT_SEL>;
        #[doc = "Writer for register encrypt_sel"]
        pub type W = crate::W<u32, super::ENCRYPT_SEL>;
        #[doc = "Register encrypt_sel `reset()`'s with value 0"]
        impl crate::ResetValue for super::ENCRYPT_SEL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Select encryption or decryption mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENCRYPT_SEL_A {
            #[doc = "0: Sets encryption mode"]
            ENCRYPTION = 0,
            #[doc = "1: Sets decryption mode"]
            DECRYPTION = 1,
        }
        impl From<ENCRYPT_SEL_A> for bool {
            #[inline(always)]
            fn from(variant: ENCRYPT_SEL_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `encrypt_sel`"]
        pub type ENCRYPT_SEL_R = crate::R<bool, ENCRYPT_SEL_A>;
        impl ENCRYPT_SEL_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> ENCRYPT_SEL_A {
                match self.bits {
                    false => ENCRYPT_SEL_A::ENCRYPTION,
                    true => ENCRYPT_SEL_A::DECRYPTION,
                }
            }
            #[doc = "Checks if the value of the field is `ENCRYPTION`"]
            #[inline(always)]
            pub fn is_encryption(&self) -> bool {
                *self == ENCRYPT_SEL_A::ENCRYPTION
            }
            #[doc = "Checks if the value of the field is `DECRYPTION`"]
            #[inline(always)]
            pub fn is_decryption(&self) -> bool {
                *self == ENCRYPT_SEL_A::DECRYPTION
            }
        }
        #[doc = "Write proxy for field `encrypt_sel`"]
        pub struct ENCRYPT_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENCRYPT_SEL_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENCRYPT_SEL_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Sets encryption mode"]
            #[inline(always)]
            pub fn encryption(self) -> &'a mut W {
                self.variant(ENCRYPT_SEL_A::ENCRYPTION)
            }
            #[doc = "Sets decryption mode"]
            #[inline(always)]
            pub fn decryption(self) -> &'a mut W {
                self.variant(ENCRYPT_SEL_A::DECRYPTION)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Select encryption or decryption mode"]
            #[inline(always)]
            pub fn encrypt_sel(&self) -> ENCRYPT_SEL_R {
                ENCRYPT_SEL_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Select encryption or decryption mode"]
            #[inline(always)]
            pub fn encrypt_sel(&mut self) -> ENCRYPT_SEL_W {
                ENCRYPT_SEL_W { w: self }
            }
        }
    }
    #[doc = "AES mode register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [mode_ctl](mode_ctl) module"]
    pub type MODE_CTL = crate::Reg<u32, _MODE_CTL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _MODE_CTL;
    #[doc = "`read()` method returns [mode_ctl::R](mode_ctl::R) reader structure"]
    impl crate::Readable for MODE_CTL {}
    #[doc = "`write(|w| ..)` method takes [mode_ctl::W](mode_ctl::W) writer structure"]
    impl crate::Writable for MODE_CTL {}
    #[doc = "AES mode register"]
    pub mod mode_ctl {
        #[doc = "Reader of register mode_ctl"]
        pub type R = crate::R<u32, super::MODE_CTL>;
        #[doc = "Writer for register mode_ctl"]
        pub type W = crate::W<u32, super::MODE_CTL>;
        #[doc = "Register mode_ctl `reset()`'s with value 0"]
        impl crate::ResetValue for super::MODE_CTL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Cipher mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CIPHER_MODE_A {
            #[doc = "0: Electronic Codebook"]
            ECB = 0,
            #[doc = "1: Cipher Block Chaining"]
            CBC = 1,
            #[doc = "2: Galois/Counter Mode"]
            GCM = 2,
        }
        impl From<CIPHER_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: CIPHER_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `cipher_mode`"]
        pub type CIPHER_MODE_R = crate::R<u8, CIPHER_MODE_A>;
        impl CIPHER_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, CIPHER_MODE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(CIPHER_MODE_A::ECB),
                    1 => Val(CIPHER_MODE_A::CBC),
                    2 => Val(CIPHER_MODE_A::GCM),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `ECB`"]
            #[inline(always)]
            pub fn is_ecb(&self) -> bool {
                *self == CIPHER_MODE_A::ECB
            }
            #[doc = "Checks if the value of the field is `CBC`"]
            #[inline(always)]
            pub fn is_cbc(&self) -> bool {
                *self == CIPHER_MODE_A::CBC
            }
            #[doc = "Checks if the value of the field is `GCM`"]
            #[inline(always)]
            pub fn is_gcm(&self) -> bool {
                *self == CIPHER_MODE_A::GCM
            }
        }
        #[doc = "Write proxy for field `cipher_mode`"]
        pub struct CIPHER_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CIPHER_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CIPHER_MODE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Electronic Codebook"]
            #[inline(always)]
            pub fn ecb(self) -> &'a mut W {
                self.variant(CIPHER_MODE_A::ECB)
            }
            #[doc = "Cipher Block Chaining"]
            #[inline(always)]
            pub fn cbc(self) -> &'a mut W {
                self.variant(CIPHER_MODE_A::CBC)
            }
            #[doc = "Galois/Counter Mode"]
            #[inline(always)]
            pub fn gcm(self) -> &'a mut W {
                self.variant(CIPHER_MODE_A::GCM)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Key mode\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum KEY_MODE_A {
            #[doc = "0: AES-128"]
            AES128 = 0,
            #[doc = "1: AES-192"]
            AES192 = 1,
            #[doc = "2: AES-256"]
            AES256 = 2,
        }
        impl From<KEY_MODE_A> for u8 {
            #[inline(always)]
            fn from(variant: KEY_MODE_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `key_mode`"]
        pub type KEY_MODE_R = crate::R<u8, KEY_MODE_A>;
        impl KEY_MODE_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, KEY_MODE_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(KEY_MODE_A::AES128),
                    1 => Val(KEY_MODE_A::AES192),
                    2 => Val(KEY_MODE_A::AES256),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `AES128`"]
            #[inline(always)]
            pub fn is_aes128(&self) -> bool {
                *self == KEY_MODE_A::AES128
            }
            #[doc = "Checks if the value of the field is `AES192`"]
            #[inline(always)]
            pub fn is_aes192(&self) -> bool {
                *self == KEY_MODE_A::AES192
            }
            #[doc = "Checks if the value of the field is `AES256`"]
            #[inline(always)]
            pub fn is_aes256(&self) -> bool {
                *self == KEY_MODE_A::AES256
            }
        }
        #[doc = "Write proxy for field `key_mode`"]
        pub struct KEY_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_MODE_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: KEY_MODE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "AES-128"]
            #[inline(always)]
            pub fn aes128(self) -> &'a mut W {
                self.variant(KEY_MODE_A::AES128)
            }
            #[doc = "AES-192"]
            #[inline(always)]
            pub fn aes192(self) -> &'a mut W {
                self.variant(KEY_MODE_A::AES192)
            }
            #[doc = "AES-256"]
            #[inline(always)]
            pub fn aes256(self) -> &'a mut W {
                self.variant(KEY_MODE_A::AES256)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 3)) | (((value as u32) & 0x03) << 3);
                self.w
            }
        }
        #[doc = "Input key order\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum KEY_ORDER_A {
            #[doc = "0: Big Endian"]
            BE = 0,
            #[doc = "1: Little Endian"]
            LE = 1,
        }
        impl From<KEY_ORDER_A> for bool {
            #[inline(always)]
            fn from(variant: KEY_ORDER_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `key_order`"]
        pub type KEY_ORDER_R = crate::R<bool, KEY_ORDER_A>;
        impl KEY_ORDER_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> KEY_ORDER_A {
                match self.bits {
                    false => KEY_ORDER_A::BE,
                    true => KEY_ORDER_A::LE,
                }
            }
            #[doc = "Checks if the value of the field is `BE`"]
            #[inline(always)]
            pub fn is_be(&self) -> bool {
                *self == KEY_ORDER_A::BE
            }
            #[doc = "Checks if the value of the field is `LE`"]
            #[inline(always)]
            pub fn is_le(&self) -> bool {
                *self == KEY_ORDER_A::LE
            }
        }
        #[doc = "Write proxy for field `key_order`"]
        pub struct KEY_ORDER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_ORDER_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: KEY_ORDER_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Big Endian"]
            #[inline(always)]
            pub fn be(self) -> &'a mut W {
                self.variant(KEY_ORDER_A::BE)
            }
            #[doc = "Little Endian"]
            #[inline(always)]
            pub fn le(self) -> &'a mut W {
                self.variant(KEY_ORDER_A::LE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        #[doc = "Input data order"]
        pub type INPUT_ORDER_A = KEY_ORDER_A;
        #[doc = "Reader of field `input_order`"]
        pub type INPUT_ORDER_R = crate::R<bool, INPUT_ORDER_A>;
        #[doc = "Write proxy for field `input_order`"]
        pub struct INPUT_ORDER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INPUT_ORDER_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INPUT_ORDER_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Big Endian"]
            #[inline(always)]
            pub fn be(self) -> &'a mut W {
                self.variant(INPUT_ORDER_A::BE)
            }
            #[doc = "Little Endian"]
            #[inline(always)]
            pub fn le(self) -> &'a mut W {
                self.variant(INPUT_ORDER_A::LE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | (((value as u32) & 0x01) << 7);
                self.w
            }
        }
        #[doc = "Output data order"]
        pub type OUTPUT_ORDER_A = KEY_ORDER_A;
        #[doc = "Reader of field `output_order`"]
        pub type OUTPUT_ORDER_R = crate::R<bool, OUTPUT_ORDER_A>;
        #[doc = "Write proxy for field `output_order`"]
        pub struct OUTPUT_ORDER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OUTPUT_ORDER_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTPUT_ORDER_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Big Endian"]
            #[inline(always)]
            pub fn be(self) -> &'a mut W {
                self.variant(OUTPUT_ORDER_A::BE)
            }
            #[doc = "Little Endian"]
            #[inline(always)]
            pub fn le(self) -> &'a mut W {
                self.variant(OUTPUT_ORDER_A::LE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | (((value as u32) & 0x01) << 9);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Cipher mode"]
            #[inline(always)]
            pub fn cipher_mode(&self) -> CIPHER_MODE_R {
                CIPHER_MODE_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 3:4 - Key mode"]
            #[inline(always)]
            pub fn key_mode(&self) -> KEY_MODE_R {
                KEY_MODE_R::new(((self.bits >> 3) & 0x03) as u8)
            }
            #[doc = "Bit 5 - Input key order"]
            #[inline(always)]
            pub fn key_order(&self) -> KEY_ORDER_R {
                KEY_ORDER_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            #[doc = "Bit 7 - Input data order"]
            #[inline(always)]
            pub fn input_order(&self) -> INPUT_ORDER_R {
                INPUT_ORDER_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            #[doc = "Bit 9 - Output data order"]
            #[inline(always)]
            pub fn output_order(&self) -> OUTPUT_ORDER_R {
                OUTPUT_ORDER_R::new(((self.bits >> 9) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Cipher mode"]
            #[inline(always)]
            pub fn cipher_mode(&mut self) -> CIPHER_MODE_W {
                CIPHER_MODE_W { w: self }
            }
            #[doc = "Bits 3:4 - Key mode"]
            #[inline(always)]
            pub fn key_mode(&mut self) -> KEY_MODE_W {
                KEY_MODE_W { w: self }
            }
            #[doc = "Bit 5 - Input key order"]
            #[inline(always)]
            pub fn key_order(&mut self) -> KEY_ORDER_W {
                KEY_ORDER_W { w: self }
            }
            #[doc = "Bit 7 - Input data order"]
            #[inline(always)]
            pub fn input_order(&mut self) -> INPUT_ORDER_W {
                INPUT_ORDER_W { w: self }
            }
            #[doc = "Bit 9 - Output data order"]
            #[inline(always)]
            pub fn output_order(&mut self) -> OUTPUT_ORDER_W {
                OUTPUT_ORDER_W { w: self }
            }
        }
    }
    #[doc = "Initialisation Vector (96 bit for GCM, 128 bit for CBC)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [iv](iv) module"]
    pub type IV = crate::Reg<u32, _IV>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _IV;
    #[doc = "`read()` method returns [iv::R](iv::R) reader structure"]
    impl crate::Readable for IV {}
    #[doc = "`write(|w| ..)` method takes [iv::W](iv::W) writer structure"]
    impl crate::Writable for IV {}
    #[doc = "Initialisation Vector (96 bit for GCM, 128 bit for CBC)"]
    pub mod iv {
        #[doc = "Reader of register iv[%s]"]
        pub type R = crate::R<u32, super::IV>;
        #[doc = "Writer for register iv[%s]"]
        pub type W = crate::W<u32, super::IV>;
        #[doc = "Register iv[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::IV {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Endian control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [endian](endian) module"]
    pub type ENDIAN = crate::Reg<u32, _ENDIAN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ENDIAN;
    #[doc = "`read()` method returns [endian::R](endian::R) reader structure"]
    impl crate::Readable for ENDIAN {}
    #[doc = "`write(|w| ..)` method takes [endian::W](endian::W) writer structure"]
    impl crate::Writable for ENDIAN {}
    #[doc = "Endian control"]
    pub mod endian {
        #[doc = "Reader of register endian"]
        pub type R = crate::R<u32, super::ENDIAN>;
        #[doc = "Writer for register endian"]
        pub type W = crate::W<u32, super::ENDIAN>;
        #[doc = "Register endian `reset()`'s with value 0"]
        impl crate::ResetValue for super::ENDIAN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Input data endian"]
        pub type ENDIAN_A = super::mode_ctl::KEY_ORDER_A;
        #[doc = "Reader of field `endian`"]
        pub type ENDIAN_R = crate::R<bool, ENDIAN_A>;
        #[doc = "Write proxy for field `endian`"]
        pub struct ENDIAN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENDIAN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENDIAN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Big Endian"]
            #[inline(always)]
            pub fn be(self) -> &'a mut W {
                self.variant(ENDIAN_A::BE)
            }
            #[doc = "Little Endian"]
            #[inline(always)]
            pub fn le(self) -> &'a mut W {
                self.variant(ENDIAN_A::LE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Input data endian"]
            #[inline(always)]
            pub fn endian(&self) -> ENDIAN_R {
                ENDIAN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Input data endian"]
            #[inline(always)]
            pub fn endian(&mut self) -> ENDIAN_W {
                ENDIAN_W { w: self }
            }
        }
    }
    #[doc = "Finished status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [finish](finish) module"]
    pub type FINISH = crate::Reg<u32, _FINISH>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _FINISH;
    #[doc = "`read()` method returns [finish::R](finish::R) reader structure"]
    impl crate::Readable for FINISH {}
    #[doc = "`write(|w| ..)` method takes [finish::W](finish::W) writer structure"]
    impl crate::Writable for FINISH {}
    #[doc = "Finished status"]
    pub mod finish {
        #[doc = "Reader of register finish"]
        pub type R = crate::R<u32, super::FINISH>;
        #[doc = "Writer for register finish"]
        pub type W = crate::W<u32, super::FINISH>;
        #[doc = "Register finish `reset()`'s with value 0"]
        impl crate::ResetValue for super::FINISH {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "AES operation finished status\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FINISH_A {
            #[doc = "0: Operation not finished"]
            NOT_FINISHED = 0,
            #[doc = "1: Operation finished"]
            FINISHED = 1,
        }
        impl From<FINISH_A> for bool {
            #[inline(always)]
            fn from(variant: FINISH_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `finish`"]
        pub type FINISH_R = crate::R<bool, FINISH_A>;
        impl FINISH_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> FINISH_A {
                match self.bits {
                    false => FINISH_A::NOT_FINISHED,
                    true => FINISH_A::FINISHED,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_FINISHED`"]
            #[inline(always)]
            pub fn is_not_finished(&self) -> bool {
                *self == FINISH_A::NOT_FINISHED
            }
            #[doc = "Checks if the value of the field is `FINISHED`"]
            #[inline(always)]
            pub fn is_finished(&self) -> bool {
                *self == FINISH_A::FINISHED
            }
        }
        #[doc = "Write proxy for field `finish`"]
        pub struct FINISH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FINISH_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FINISH_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Operation not finished"]
            #[inline(always)]
            pub fn not_finished(self) -> &'a mut W {
                self.variant(FINISH_A::NOT_FINISHED)
            }
            #[doc = "Operation finished"]
            #[inline(always)]
            pub fn finished(self) -> &'a mut W {
                self.variant(FINISH_A::FINISHED)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - AES operation finished status"]
            #[inline(always)]
            pub fn finish(&self) -> FINISH_R {
                FINISH_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - AES operation finished status"]
            #[inline(always)]
            pub fn finish(&mut self) -> FINISH_W {
                FINISH_W { w: self }
            }
        }
    }
    #[doc = "DMA select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [dma_sel](dma_sel) module"]
    pub type DMA_SEL = crate::Reg<u32, _DMA_SEL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DMA_SEL;
    #[doc = "`read()` method returns [dma_sel::R](dma_sel::R) reader structure"]
    impl crate::Readable for DMA_SEL {}
    #[doc = "`write(|w| ..)` method takes [dma_sel::W](dma_sel::W) writer structure"]
    impl crate::Writable for DMA_SEL {}
    #[doc = "DMA select"]
    pub mod dma_sel {
        #[doc = "Reader of register dma_sel"]
        pub type R = crate::R<u32, super::DMA_SEL>;
        #[doc = "Writer for register dma_sel"]
        pub type W = crate::W<u32, super::DMA_SEL>;
        #[doc = "Register dma_sel `reset()`'s with value 0"]
        impl crate::ResetValue for super::DMA_SEL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `dma_sel`"]
        pub type DMA_SEL_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `dma_sel`"]
        pub struct DMA_SEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_SEL_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Output to DMA if set, to CPU otherwise"]
            #[inline(always)]
            pub fn dma_sel(&self) -> DMA_SEL_R {
                DMA_SEL_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Output to DMA if set, to CPU otherwise"]
            #[inline(always)]
            pub fn dma_sel(&mut self) -> DMA_SEL_W {
                DMA_SEL_W { w: self }
            }
        }
    }
    #[doc = "GCM additional authenticated data count in bytes, minus one\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [aad_num](aad_num) module"]
    pub type AAD_NUM = crate::Reg<u32, _AAD_NUM>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AAD_NUM;
    #[doc = "`read()` method returns [aad_num::R](aad_num::R) reader structure"]
    impl crate::Readable for AAD_NUM {}
    #[doc = "`write(|w| ..)` method takes [aad_num::W](aad_num::W) writer structure"]
    impl crate::Writable for AAD_NUM {}
    #[doc = "GCM additional authenticated data count in bytes, minus one"]
    pub mod aad_num {
        #[doc = "Reader of register aad_num"]
        pub type R = crate::R<u32, super::AAD_NUM>;
        #[doc = "Writer for register aad_num"]
        pub type W = crate::W<u32, super::AAD_NUM>;
        #[doc = "Register aad_num `reset()`'s with value 0"]
        impl crate::ResetValue for super::AAD_NUM {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Plaintext/ciphertext input data count in bytes, minus one\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [pc_num](pc_num) module"]
    pub type PC_NUM = crate::Reg<u32, _PC_NUM>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _PC_NUM;
    #[doc = "`read()` method returns [pc_num::R](pc_num::R) reader structure"]
    impl crate::Readable for PC_NUM {}
    #[doc = "`write(|w| ..)` method takes [pc_num::W](pc_num::W) writer structure"]
    impl crate::Writable for PC_NUM {}
    #[doc = "Plaintext/ciphertext input data count in bytes, minus one"]
    pub mod pc_num {
        #[doc = "Reader of register pc_num"]
        pub type R = crate::R<u32, super::PC_NUM>;
        #[doc = "Writer for register pc_num"]
        pub type W = crate::W<u32, super::PC_NUM>;
        #[doc = "Register pc_num `reset()`'s with value 0"]
        impl crate::ResetValue for super::PC_NUM {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Plaintext/ciphertext input data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [text_data](text_data) module"]
    pub type TEXT_DATA = crate::Reg<u32, _TEXT_DATA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TEXT_DATA;
    #[doc = "`read()` method returns [text_data::R](text_data::R) reader structure"]
    impl crate::Readable for TEXT_DATA {}
    #[doc = "`write(|w| ..)` method takes [text_data::W](text_data::W) writer structure"]
    impl crate::Writable for TEXT_DATA {}
    #[doc = "Plaintext/ciphertext input data"]
    pub mod text_data {
        #[doc = "Reader of register text_data"]
        pub type R = crate::R<u32, super::TEXT_DATA>;
        #[doc = "Writer for register text_data"]
        pub type W = crate::W<u32, super::TEXT_DATA>;
        #[doc = "Register text_data `reset()`'s with value 0"]
        impl crate::ResetValue for super::TEXT_DATA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Additional authenticated data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [aad_data](aad_data) module"]
    pub type AAD_DATA = crate::Reg<u32, _AAD_DATA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _AAD_DATA;
    #[doc = "`read()` method returns [aad_data::R](aad_data::R) reader structure"]
    impl crate::Readable for AAD_DATA {}
    #[doc = "`write(|w| ..)` method takes [aad_data::W](aad_data::W) writer structure"]
    impl crate::Writable for AAD_DATA {}
    #[doc = "Additional authenticated data"]
    pub mod aad_data {
        #[doc = "Reader of register aad_data"]
        pub type R = crate::R<u32, super::AAD_DATA>;
        #[doc = "Writer for register aad_data"]
        pub type W = crate::W<u32, super::AAD_DATA>;
        #[doc = "Register aad_data `reset()`'s with value 0"]
        impl crate::ResetValue for super::AAD_DATA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Tag check status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tag_chk](tag_chk) module"]
    pub type TAG_CHK = crate::Reg<u32, _TAG_CHK>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TAG_CHK;
    #[doc = "`read()` method returns [tag_chk::R](tag_chk::R) reader structure"]
    impl crate::Readable for TAG_CHK {}
    #[doc = "`write(|w| ..)` method takes [tag_chk::W](tag_chk::W) writer structure"]
    impl crate::Writable for TAG_CHK {}
    #[doc = "Tag check status"]
    pub mod tag_chk {
        #[doc = "Reader of register tag_chk"]
        pub type R = crate::R<u32, super::TAG_CHK>;
        #[doc = "Writer for register tag_chk"]
        pub type W = crate::W<u32, super::TAG_CHK>;
        #[doc = "Register tag_chk `reset()`'s with value 0"]
        impl crate::ResetValue for super::TAG_CHK {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Tag check status\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TAG_CHK_A {
            #[doc = "0: Check not finished"]
            BUSY = 0,
            #[doc = "1: Check failed"]
            FAIL = 1,
            #[doc = "2: Check success"]
            SUCCESS = 2,
        }
        impl From<TAG_CHK_A> for u8 {
            #[inline(always)]
            fn from(variant: TAG_CHK_A) -> Self {
                variant as _
            }
        }
        #[doc = "Reader of field `tag_chk`"]
        pub type TAG_CHK_R = crate::R<u8, TAG_CHK_A>;
        impl TAG_CHK_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> crate::Variant<u8, TAG_CHK_A> {
                use crate::Variant::*;
                match self.bits {
                    0 => Val(TAG_CHK_A::BUSY),
                    1 => Val(TAG_CHK_A::FAIL),
                    2 => Val(TAG_CHK_A::SUCCESS),
                    i => Res(i),
                }
            }
            #[doc = "Checks if the value of the field is `BUSY`"]
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                *self == TAG_CHK_A::BUSY
            }
            #[doc = "Checks if the value of the field is `FAIL`"]
            #[inline(always)]
            pub fn is_fail(&self) -> bool {
                *self == TAG_CHK_A::FAIL
            }
            #[doc = "Checks if the value of the field is `SUCCESS`"]
            #[inline(always)]
            pub fn is_success(&self) -> bool {
                *self == TAG_CHK_A::SUCCESS
            }
        }
        #[doc = "Write proxy for field `tag_chk`"]
        pub struct TAG_CHK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAG_CHK_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAG_CHK_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            #[doc = "Check not finished"]
            #[inline(always)]
            pub fn busy(self) -> &'a mut W {
                self.variant(TAG_CHK_A::BUSY)
            }
            #[doc = "Check failed"]
            #[inline(always)]
            pub fn fail(self) -> &'a mut W {
                self.variant(TAG_CHK_A::FAIL)
            }
            #[doc = "Check success"]
            #[inline(always)]
            pub fn success(self) -> &'a mut W {
                self.variant(TAG_CHK_A::SUCCESS)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | ((value as u32) & 0x03);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:1 - Tag check status"]
            #[inline(always)]
            pub fn tag_chk(&self) -> TAG_CHK_R {
                TAG_CHK_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Tag check status"]
            #[inline(always)]
            pub fn tag_chk(&mut self) -> TAG_CHK_W {
                TAG_CHK_W { w: self }
            }
        }
    }
    #[doc = "Data can input flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_in_flag](data_in_flag) module"]
    pub type DATA_IN_FLAG = crate::Reg<u32, _DATA_IN_FLAG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DATA_IN_FLAG;
    #[doc = "`read()` method returns [data_in_flag::R](data_in_flag::R) reader structure"]
    impl crate::Readable for DATA_IN_FLAG {}
    #[doc = "`write(|w| ..)` method takes [data_in_flag::W](data_in_flag::W) writer structure"]
    impl crate::Writable for DATA_IN_FLAG {}
    #[doc = "Data can input flag"]
    pub mod data_in_flag {
        #[doc = "Reader of register data_in_flag"]
        pub type R = crate::R<u32, super::DATA_IN_FLAG>;
        #[doc = "Writer for register data_in_flag"]
        pub type W = crate::W<u32, super::DATA_IN_FLAG>;
        #[doc = "Register data_in_flag `reset()`'s with value 0"]
        impl crate::ResetValue for super::DATA_IN_FLAG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Data can be written to text_data or aad_data when this flag is set\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_IN_FLAG_A {
            #[doc = "0: Cannot input"]
            CANNOT_INPUT = 0,
            #[doc = "1: Can input"]
            CAN_INPUT = 1,
        }
        impl From<DATA_IN_FLAG_A> for bool {
            #[inline(always)]
            fn from(variant: DATA_IN_FLAG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `data_in_flag`"]
        pub type DATA_IN_FLAG_R = crate::R<bool, DATA_IN_FLAG_A>;
        impl DATA_IN_FLAG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DATA_IN_FLAG_A {
                match self.bits {
                    false => DATA_IN_FLAG_A::CANNOT_INPUT,
                    true => DATA_IN_FLAG_A::CAN_INPUT,
                }
            }
            #[doc = "Checks if the value of the field is `CANNOT_INPUT`"]
            #[inline(always)]
            pub fn is_cannot_input(&self) -> bool {
                *self == DATA_IN_FLAG_A::CANNOT_INPUT
            }
            #[doc = "Checks if the value of the field is `CAN_INPUT`"]
            #[inline(always)]
            pub fn is_can_input(&self) -> bool {
                *self == DATA_IN_FLAG_A::CAN_INPUT
            }
        }
        #[doc = "Write proxy for field `data_in_flag`"]
        pub struct DATA_IN_FLAG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_IN_FLAG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATA_IN_FLAG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Cannot input"]
            #[inline(always)]
            pub fn cannot_input(self) -> &'a mut W {
                self.variant(DATA_IN_FLAG_A::CANNOT_INPUT)
            }
            #[doc = "Can input"]
            #[inline(always)]
            pub fn can_input(self) -> &'a mut W {
                self.variant(DATA_IN_FLAG_A::CAN_INPUT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Data can be written to text_data or aad_data when this flag is set"]
            #[inline(always)]
            pub fn data_in_flag(&self) -> DATA_IN_FLAG_R {
                DATA_IN_FLAG_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data can be written to text_data or aad_data when this flag is set"]
            #[inline(always)]
            pub fn data_in_flag(&mut self) -> DATA_IN_FLAG_W {
                DATA_IN_FLAG_W { w: self }
            }
        }
    }
    #[doc = "GCM input tag for comparison with the calculated tag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gcm_in_tag](gcm_in_tag) module"]
    pub type GCM_IN_TAG = crate::Reg<u32, _GCM_IN_TAG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _GCM_IN_TAG;
    #[doc = "`read()` method returns [gcm_in_tag::R](gcm_in_tag::R) reader structure"]
    impl crate::Readable for GCM_IN_TAG {}
    #[doc = "`write(|w| ..)` method takes [gcm_in_tag::W](gcm_in_tag::W) writer structure"]
    impl crate::Writable for GCM_IN_TAG {}
    #[doc = "GCM input tag for comparison with the calculated tag"]
    pub mod gcm_in_tag {
        #[doc = "Reader of register gcm_in_tag[%s]"]
        pub type R = crate::R<u32, super::GCM_IN_TAG>;
        #[doc = "Writer for register gcm_in_tag[%s]"]
        pub type W = crate::W<u32, super::GCM_IN_TAG>;
        #[doc = "Register gcm_in_tag[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::GCM_IN_TAG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Plaintext/ciphertext output data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [out_data](out_data) module"]
    pub type OUT_DATA = crate::Reg<u32, _OUT_DATA>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _OUT_DATA;
    #[doc = "`read()` method returns [out_data::R](out_data::R) reader structure"]
    impl crate::Readable for OUT_DATA {}
    #[doc = "`write(|w| ..)` method takes [out_data::W](out_data::W) writer structure"]
    impl crate::Writable for OUT_DATA {}
    #[doc = "Plaintext/ciphertext output data"]
    pub mod out_data {
        #[doc = "Reader of register out_data"]
        pub type R = crate::R<u32, super::OUT_DATA>;
        #[doc = "Writer for register out_data"]
        pub type W = crate::W<u32, super::OUT_DATA>;
        #[doc = "Register out_data `reset()`'s with value 0"]
        impl crate::ResetValue for super::OUT_DATA {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "AES module enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [en](en) module"]
    pub type EN = crate::Reg<u32, _EN>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EN;
    #[doc = "`read()` method returns [en::R](en::R) reader structure"]
    impl crate::Readable for EN {}
    #[doc = "`write(|w| ..)` method takes [en::W](en::W) writer structure"]
    impl crate::Writable for EN {}
    #[doc = "AES module enable"]
    pub mod en {
        #[doc = "Reader of register en"]
        pub type R = crate::R<u32, super::EN>;
        #[doc = "Writer for register en"]
        pub type W = crate::W<u32, super::EN>;
        #[doc = "Register en `reset()`'s with value 0"]
        impl crate::ResetValue for super::EN {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "AES module enable\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EN_A {
            #[doc = "0: Disable module"]
            DISABLE = 0,
            #[doc = "1: Enable module"]
            ENABLE = 1,
        }
        impl From<EN_A> for bool {
            #[inline(always)]
            fn from(variant: EN_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `en`"]
        pub type EN_R = crate::R<bool, EN_A>;
        impl EN_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> EN_A {
                match self.bits {
                    false => EN_A::DISABLE,
                    true => EN_A::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == EN_A::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == EN_A::ENABLE
            }
        }
        #[doc = "Write proxy for field `en`"]
        pub struct EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EN_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Disable module"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(EN_A::DISABLE)
            }
            #[doc = "Enable module"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(EN_A::ENABLE)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - AES module enable"]
            #[inline(always)]
            pub fn en(&self) -> EN_R {
                EN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - AES module enable"]
            #[inline(always)]
            pub fn en(&mut self) -> EN_W {
                EN_W { w: self }
            }
        }
    }
    #[doc = "Data can output flag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [data_out_flag](data_out_flag) module"]
    pub type DATA_OUT_FLAG = crate::Reg<u32, _DATA_OUT_FLAG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DATA_OUT_FLAG;
    #[doc = "`read()` method returns [data_out_flag::R](data_out_flag::R) reader structure"]
    impl crate::Readable for DATA_OUT_FLAG {}
    #[doc = "`write(|w| ..)` method takes [data_out_flag::W](data_out_flag::W) writer structure"]
    impl crate::Writable for DATA_OUT_FLAG {}
    #[doc = "Data can output flag"]
    pub mod data_out_flag {
        #[doc = "Reader of register data_out_flag"]
        pub type R = crate::R<u32, super::DATA_OUT_FLAG>;
        #[doc = "Writer for register data_out_flag"]
        pub type W = crate::W<u32, super::DATA_OUT_FLAG>;
        #[doc = "Register data_out_flag `reset()`'s with value 0"]
        impl crate::ResetValue for super::DATA_OUT_FLAG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Data can be read from out_data when this flag is set\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATA_OUT_FLAG_A {
            #[doc = "0: Data cannot output"]
            CANNOT_OUTPUT = 0,
            #[doc = "1: Data can output"]
            CAN_OUTPUT = 1,
        }
        impl From<DATA_OUT_FLAG_A> for bool {
            #[inline(always)]
            fn from(variant: DATA_OUT_FLAG_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `data_out_flag`"]
        pub type DATA_OUT_FLAG_R = crate::R<bool, DATA_OUT_FLAG_A>;
        impl DATA_OUT_FLAG_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> DATA_OUT_FLAG_A {
                match self.bits {
                    false => DATA_OUT_FLAG_A::CANNOT_OUTPUT,
                    true => DATA_OUT_FLAG_A::CAN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `CANNOT_OUTPUT`"]
            #[inline(always)]
            pub fn is_cannot_output(&self) -> bool {
                *self == DATA_OUT_FLAG_A::CANNOT_OUTPUT
            }
            #[doc = "Checks if the value of the field is `CAN_OUTPUT`"]
            #[inline(always)]
            pub fn is_can_output(&self) -> bool {
                *self == DATA_OUT_FLAG_A::CAN_OUTPUT
            }
        }
        #[doc = "Write proxy for field `data_out_flag`"]
        pub struct DATA_OUT_FLAG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATA_OUT_FLAG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATA_OUT_FLAG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Data cannot output"]
            #[inline(always)]
            pub fn cannot_output(self) -> &'a mut W {
                self.variant(DATA_OUT_FLAG_A::CANNOT_OUTPUT)
            }
            #[doc = "Data can output"]
            #[inline(always)]
            pub fn can_output(self) -> &'a mut W {
                self.variant(DATA_OUT_FLAG_A::CAN_OUTPUT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - Data can be read from out_data when this flag is set"]
            #[inline(always)]
            pub fn data_out_flag(&self) -> DATA_OUT_FLAG_R {
                DATA_OUT_FLAG_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Data can be read from out_data when this flag is set"]
            #[inline(always)]
            pub fn data_out_flag(&mut self) -> DATA_OUT_FLAG_W {
                DATA_OUT_FLAG_W { w: self }
            }
        }
    }
    #[doc = "Can input tag (when using GCM)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tag_in_flag](tag_in_flag) module"]
    pub type TAG_IN_FLAG = crate::Reg<u32, _TAG_IN_FLAG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TAG_IN_FLAG;
    #[doc = "`read()` method returns [tag_in_flag::R](tag_in_flag::R) reader structure"]
    impl crate::Readable for TAG_IN_FLAG {}
    #[doc = "`write(|w| ..)` method takes [tag_in_flag::W](tag_in_flag::W) writer structure"]
    impl crate::Writable for TAG_IN_FLAG {}
    #[doc = "Can input tag (when using GCM)"]
    pub mod tag_in_flag {
        #[doc = "Reader of register tag_in_flag"]
        pub type R = crate::R<u32, super::TAG_IN_FLAG>;
        #[doc = "Writer for register tag_in_flag"]
        pub type W = crate::W<u32, super::TAG_IN_FLAG>;
        #[doc = "Register tag_in_flag `reset()`'s with value 0"]
        impl crate::ResetValue for super::TAG_IN_FLAG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "GCM tag can be written to gcm_in_tag when this flag is set"]
        pub type TAG_IN_FLAG_A = super::data_in_flag::DATA_IN_FLAG_A;
        #[doc = "Reader of field `tag_in_flag`"]
        pub type TAG_IN_FLAG_R = crate::R<bool, TAG_IN_FLAG_A>;
        #[doc = "Write proxy for field `tag_in_flag`"]
        pub struct TAG_IN_FLAG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TAG_IN_FLAG_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TAG_IN_FLAG_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "Cannot input"]
            #[inline(always)]
            pub fn cannot_input(self) -> &'a mut W {
                self.variant(TAG_IN_FLAG_A::CANNOT_INPUT)
            }
            #[doc = "Can input"]
            #[inline(always)]
            pub fn can_input(self) -> &'a mut W {
                self.variant(TAG_IN_FLAG_A::CAN_INPUT)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - GCM tag can be written to gcm_in_tag when this flag is set"]
            #[inline(always)]
            pub fn tag_in_flag(&self) -> TAG_IN_FLAG_R {
                TAG_IN_FLAG_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - GCM tag can be written to gcm_in_tag when this flag is set"]
            #[inline(always)]
            pub fn tag_in_flag(&mut self) -> TAG_IN_FLAG_W {
                TAG_IN_FLAG_W { w: self }
            }
        }
    }
    #[doc = "Tag clear (a write to this register clears the tag_chk status)\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [tag_clear](tag_clear) module"]
    pub type TAG_CLEAR = crate::Reg<u32, _TAG_CLEAR>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TAG_CLEAR;
    #[doc = "`read()` method returns [tag_clear::R](tag_clear::R) reader structure"]
    impl crate::Readable for TAG_CLEAR {}
    #[doc = "`write(|w| ..)` method takes [tag_clear::W](tag_clear::W) writer structure"]
    impl crate::Writable for TAG_CLEAR {}
    #[doc = "Tag clear (a write to this register clears the tag_chk status)"]
    pub mod tag_clear {
        #[doc = "Reader of register tag_clear"]
        pub type R = crate::R<u32, super::TAG_CLEAR>;
        #[doc = "Writer for register tag_clear"]
        pub type W = crate::W<u32, super::TAG_CLEAR>;
        #[doc = "Register tag_clear `reset()`'s with value 0"]
        impl crate::ResetValue for super::TAG_CLEAR {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "Computed GCM output tag\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [gcm_out_tag](gcm_out_tag) module"]
    pub type GCM_OUT_TAG = crate::Reg<u32, _GCM_OUT_TAG>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _GCM_OUT_TAG;
    #[doc = "`read()` method returns [gcm_out_tag::R](gcm_out_tag::R) reader structure"]
    impl crate::Readable for GCM_OUT_TAG {}
    #[doc = "`write(|w| ..)` method takes [gcm_out_tag::W](gcm_out_tag::W) writer structure"]
    impl crate::Writable for GCM_OUT_TAG {}
    #[doc = "Computed GCM output tag"]
    pub mod gcm_out_tag {
        #[doc = "Reader of register gcm_out_tag[%s]"]
        pub type R = crate::R<u32, super::GCM_OUT_TAG>;
        #[doc = "Writer for register gcm_out_tag[%s]"]
        pub type W = crate::W<u32, super::GCM_OUT_TAG>;
        #[doc = "Register gcm_out_tag[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::GCM_OUT_TAG {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
    #[doc = "5th-8th word of key\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [key_ext](key_ext) module"]
    pub type KEY_EXT = crate::Reg<u32, _KEY_EXT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _KEY_EXT;
    #[doc = "`read()` method returns [key_ext::R](key_ext::R) reader structure"]
    impl crate::Readable for KEY_EXT {}
    #[doc = "`write(|w| ..)` method takes [key_ext::W](key_ext::W) writer structure"]
    impl crate::Writable for KEY_EXT {}
    #[doc = "5th-8th word of key"]
    pub mod key_ext {
        #[doc = "Reader of register key_ext[%s]"]
        pub type R = crate::R<u32, super::KEY_EXT>;
        #[doc = "Writer for register key_ext[%s]"]
        pub type W = crate::W<u32, super::KEY_EXT>;
        #[doc = "Register key_ext[%s]
`reset()`'s with value 0"]
        impl crate::ResetValue for super::KEY_EXT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        impl R {}
        impl W {}
    }
}
#[doc = "Real Time Clock"]
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    #[doc = r"Returns a pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        0x5046_0000 as *const _
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*RTC::ptr() }
    }
}
#[doc = "Real Time Clock"]
pub mod rtc {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Timer date information"]
        pub date: DATE,
        #[doc = "0x04 - Timer time information"]
        pub time: TIME,
        #[doc = "0x08 - Alarm date information"]
        pub alarm_date: ALARM_DATE,
        #[doc = "0x0c - Alarm time information"]
        pub alarm_time: ALARM_TIME,
        #[doc = "0x10 - Timer counter initial value"]
        pub initial_count: INITIAL_COUNT,
        #[doc = "0x14 - Timer counter current value"]
        pub current_count: CURRENT_COUNT,
        #[doc = "0x18 - RTC interrupt settings"]
        pub interrupt_ctrl: INTERRUPT_CTRL,
        #[doc = "0x1c - RTC register settings"]
        pub register_ctrl: REGISTER_CTRL,
        _reserved8: [u8; 8usize],
        #[doc = "0x28 - Timer extended information"]
        pub extended: EXTENDED,
    }
    #[doc = "Timer date information\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [date](date) module"]
    pub type DATE = crate::Reg<u32, _DATE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _DATE;
    #[doc = "`read()` method returns [date::R](date::R) reader structure"]
    impl crate::Readable for DATE {}
    #[doc = "`write(|w| ..)` method takes [date::W](date::W) writer structure"]
    impl crate::Writable for DATE {}
    #[doc = "Timer date information"]
    pub mod date {
        #[doc = "Reader of register date"]
        pub type R = crate::R<u32, super::DATE>;
        #[doc = "Writer for register date"]
        pub type W = crate::W<u32, super::DATE>;
        #[doc = "Register date `reset()`'s with value 0"]
        impl crate::ResetValue for super::DATE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `week`"]
        pub type WEEK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `week`"]
        pub struct WEEK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WEEK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Reader of field `day`"]
        pub type DAY_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `day`"]
        pub struct DAY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DAY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `month`"]
        pub type MONTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `month`"]
        pub struct MONTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MONTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `year`"]
        pub type YEAR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `year`"]
        pub struct YEAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> YEAR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 20)) | (((value as u32) & 0x0fff) << 20);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline(always)]
            pub fn week(&self) -> WEEK_R {
                WEEK_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\]
or \\[1,30\\]
or \\[1,29\\]
or \\[1,28\\]"]
            #[inline(always)]
            pub fn day(&self) -> DAY_R {
                DAY_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline(always)]
            pub fn month(&self) -> MONTH_R {
                MONTH_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline(always)]
            pub fn year(&self) -> YEAR_R {
                YEAR_R::new(((self.bits >> 20) & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline(always)]
            pub fn week(&mut self) -> WEEK_W {
                WEEK_W { w: self }
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\]
or \\[1,30\\]
or \\[1,29\\]
or \\[1,28\\]"]
            #[inline(always)]
            pub fn day(&mut self) -> DAY_W {
                DAY_W { w: self }
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline(always)]
            pub fn month(&mut self) -> MONTH_W {
                MONTH_W { w: self }
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline(always)]
            pub fn year(&mut self) -> YEAR_W {
                YEAR_W { w: self }
            }
        }
    }
    #[doc = "Timer time information\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [time](time) module"]
    pub type TIME = crate::Reg<u32, _TIME>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _TIME;
    #[doc = "`read()` method returns [time::R](time::R) reader structure"]
    impl crate::Readable for TIME {}
    #[doc = "`write(|w| ..)` method takes [time::W](time::W) writer structure"]
    impl crate::Writable for TIME {}
    #[doc = "Timer time information"]
    pub mod time {
        #[doc = "Reader of register time"]
        pub type R = crate::R<u32, super::TIME>;
        #[doc = "Writer for register time"]
        pub type W = crate::W<u32, super::TIME>;
        #[doc = "Register time `reset()`'s with value 0"]
        impl crate::ResetValue for super::TIME {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `second`"]
        pub type SECOND_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `second`"]
        pub struct SECOND_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SECOND_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 10)) | (((value as u32) & 0x3f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `minute`"]
        pub type MINUTE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `minute`"]
        pub struct MINUTE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MINUTE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 16)) | (((value as u32) & 0x3f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `hour`"]
        pub type HOUR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `hour`"]
        pub struct HOUR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HOUR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 24)) | (((value as u32) & 0x1f) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn second(&self) -> SECOND_R {
                SECOND_R::new(((self.bits >> 10) & 0x3f) as u8)
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn minute(&self) -> MINUTE_R {
                MINUTE_R::new(((self.bits >> 16) & 0x3f) as u8)
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline(always)]
            pub fn hour(&self) -> HOUR_R {
                HOUR_R::new(((self.bits >> 24) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn second(&mut self) -> SECOND_W {
                SECOND_W { w: self }
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn minute(&mut self) -> MINUTE_W {
                MINUTE_W { w: self }
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline(always)]
            pub fn hour(&mut self) -> HOUR_W {
                HOUR_W { w: self }
            }
        }
    }
    #[doc = "Alarm date information\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alarm_date](alarm_date) module"]
    pub type ALARM_DATE = crate::Reg<u32, _ALARM_DATE>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALARM_DATE;
    #[doc = "`read()` method returns [alarm_date::R](alarm_date::R) reader structure"]
    impl crate::Readable for ALARM_DATE {}
    #[doc = "`write(|w| ..)` method takes [alarm_date::W](alarm_date::W) writer structure"]
    impl crate::Writable for ALARM_DATE {}
    #[doc = "Alarm date information"]
    pub mod alarm_date {
        #[doc = "Reader of register alarm_date"]
        pub type R = crate::R<u32, super::ALARM_DATE>;
        #[doc = "Writer for register alarm_date"]
        pub type W = crate::W<u32, super::ALARM_DATE>;
        #[doc = "Register alarm_date `reset()`'s with value 0"]
        impl crate::ResetValue for super::ALARM_DATE {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `week`"]
        pub type WEEK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `week`"]
        pub struct WEEK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WEEK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | ((value as u32) & 0x07);
                self.w
            }
        }
        #[doc = "Reader of field `day`"]
        pub type DAY_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `day`"]
        pub struct DAY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DAY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | (((value as u32) & 0x1f) << 8);
                self.w
            }
        }
        #[doc = "Reader of field `month`"]
        pub type MONTH_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `month`"]
        pub struct MONTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MONTH_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | (((value as u32) & 0x0f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `year`"]
        pub type YEAR_R = crate::R<u16, u16>;
        #[doc = "Write proxy for field `year`"]
        pub struct YEAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> YEAR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 20)) | (((value as u32) & 0x0fff) << 20);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline(always)]
            pub fn week(&self) -> WEEK_R {
                WEEK_R::new((self.bits & 0x07) as u8)
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\]
or \\[1,30\\]
or \\[1,29\\]
or \\[1,28\\]"]
            #[inline(always)]
            pub fn day(&self) -> DAY_R {
                DAY_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline(always)]
            pub fn month(&self) -> MONTH_R {
                MONTH_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline(always)]
            pub fn year(&self) -> YEAR_R {
                YEAR_R::new(((self.bits >> 20) & 0x0fff) as u16)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - Week. Range \\[0,6\\]. 0 is Sunday."]
            #[inline(always)]
            pub fn week(&mut self) -> WEEK_W {
                WEEK_W { w: self }
            }
            #[doc = "Bits 8:12 - Day. Range \\[1,31\\]
or \\[1,30\\]
or \\[1,29\\]
or \\[1,28\\]"]
            #[inline(always)]
            pub fn day(&mut self) -> DAY_W {
                DAY_W { w: self }
            }
            #[doc = "Bits 16:19 - Month. Range \\[1,12\\]"]
            #[inline(always)]
            pub fn month(&mut self) -> MONTH_W {
                MONTH_W { w: self }
            }
            #[doc = "Bits 20:31 - Year. Range \\[0,99\\]"]
            #[inline(always)]
            pub fn year(&mut self) -> YEAR_W {
                YEAR_W { w: self }
            }
        }
    }
    #[doc = "Alarm time information\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [alarm_time](alarm_time) module"]
    pub type ALARM_TIME = crate::Reg<u32, _ALARM_TIME>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _ALARM_TIME;
    #[doc = "`read()` method returns [alarm_time::R](alarm_time::R) reader structure"]
    impl crate::Readable for ALARM_TIME {}
    #[doc = "`write(|w| ..)` method takes [alarm_time::W](alarm_time::W) writer structure"]
    impl crate::Writable for ALARM_TIME {}
    #[doc = "Alarm time information"]
    pub mod alarm_time {
        #[doc = "Reader of register alarm_time"]
        pub type R = crate::R<u32, super::ALARM_TIME>;
        #[doc = "Writer for register alarm_time"]
        pub type W = crate::W<u32, super::ALARM_TIME>;
        #[doc = "Register alarm_time `reset()`'s with value 0"]
        impl crate::ResetValue for super::ALARM_TIME {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `second`"]
        pub type SECOND_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `second`"]
        pub struct SECOND_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SECOND_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 10)) | (((value as u32) & 0x3f) << 10);
                self.w
            }
        }
        #[doc = "Reader of field `minute`"]
        pub type MINUTE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `minute`"]
        pub struct MINUTE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MINUTE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x3f << 16)) | (((value as u32) & 0x3f) << 16);
                self.w
            }
        }
        #[doc = "Reader of field `hour`"]
        pub type HOUR_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `hour`"]
        pub struct HOUR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HOUR_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 24)) | (((value as u32) & 0x1f) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn second(&self) -> SECOND_R {
                SECOND_R::new(((self.bits >> 10) & 0x3f) as u8)
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn minute(&self) -> MINUTE_R {
                MINUTE_R::new(((self.bits >> 16) & 0x3f) as u8)
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline(always)]
            pub fn hour(&self) -> HOUR_R {
                HOUR_R::new(((self.bits >> 24) & 0x1f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 10:15 - Second. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn second(&mut self) -> SECOND_W {
                SECOND_W { w: self }
            }
            #[doc = "Bits 16:21 - Minute. Range \\[0,59\\]"]
            #[inline(always)]
            pub fn minute(&mut self) -> MINUTE_W {
                MINUTE_W { w: self }
            }
            #[doc = "Bits 24:28 - Hour. Range \\[0,23\\]"]
            #[inline(always)]
            pub fn hour(&mut self) -> HOUR_W {
                HOUR_W { w: self }
            }
        }
    }
    #[doc = "Timer counter initial value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [initial_count](initial_count) module"]
    pub type INITIAL_COUNT = crate::Reg<u32, _INITIAL_COUNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INITIAL_COUNT;
    #[doc = "`read()` method returns [initial_count::R](initial_count::R) reader structure"]
    impl crate::Readable for INITIAL_COUNT {}
    #[doc = "`write(|w| ..)` method takes [initial_count::W](initial_count::W) writer structure"]
    impl crate::Writable for INITIAL_COUNT {}
    #[doc = "Timer counter initial value"]
    pub mod initial_count {
        #[doc = "Reader of register initial_count"]
        pub type R = crate::R<u32, super::INITIAL_COUNT>;
        #[doc = "Writer for register initial_count"]
        pub type W = crate::W<u32, super::INITIAL_COUNT>;
        #[doc = "Register initial_count `reset()`'s with value 0"]
        impl crate::ResetValue for super::INITIAL_COUNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `count`"]
        pub type COUNT_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `count`"]
        pub struct COUNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - RTC counter initial value"]
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RTC counter initial value"]
            #[inline(always)]
            pub fn count(&mut self) -> COUNT_W {
                COUNT_W { w: self }
            }
        }
    }
    #[doc = "Timer counter current value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [current_count](current_count) module"]
    pub type CURRENT_COUNT = crate::Reg<u32, _CURRENT_COUNT>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _CURRENT_COUNT;
    #[doc = "`read()` method returns [current_count::R](current_count::R) reader structure"]
    impl crate::Readable for CURRENT_COUNT {}
    #[doc = "`write(|w| ..)` method takes [current_count::W](current_count::W) writer structure"]
    impl crate::Writable for CURRENT_COUNT {}
    #[doc = "Timer counter current value"]
    pub mod current_count {
        #[doc = "Reader of register current_count"]
        pub type R = crate::R<u32, super::CURRENT_COUNT>;
        #[doc = "Writer for register current_count"]
        pub type W = crate::W<u32, super::CURRENT_COUNT>;
        #[doc = "Register current_count `reset()`'s with value 0"]
        impl crate::ResetValue for super::CURRENT_COUNT {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `count`"]
        pub type COUNT_R = crate::R<u32, u32>;
        #[doc = "Write proxy for field `count`"]
        pub struct COUNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNT_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | ((value as u32) & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:31 - RTC counter current value"]
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RTC counter current value"]
            #[inline(always)]
            pub fn count(&mut self) -> COUNT_W {
                COUNT_W { w: self }
            }
        }
    }
    #[doc = "RTC interrupt settings\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [interrupt_ctrl](interrupt_ctrl) module"]
    pub type INTERRUPT_CTRL = crate::Reg<u32, _INTERRUPT_CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _INTERRUPT_CTRL;
    #[doc = "`read()` method returns [interrupt_ctrl::R](interrupt_ctrl::R) reader structure"]
    impl crate::Readable for INTERRUPT_CTRL {}
    #[doc = "`write(|w| ..)` method takes [interrupt_ctrl::W](interrupt_ctrl::W) writer structure"]
    impl crate::Writable for INTERRUPT_CTRL {}
    #[doc = "RTC interrupt settings"]
    pub mod interrupt_ctrl {
        #[doc = "Reader of register interrupt_ctrl"]
        pub type R = crate::R<u32, super::INTERRUPT_CTRL>;
        #[doc = "Writer for register interrupt_ctrl"]
        pub type W = crate::W<u32, super::INTERRUPT_CTRL>;
        #[doc = "Register interrupt_ctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::INTERRUPT_CTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `tick_enable`"]
        pub type TICK_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `tick_enable`"]
        pub struct TICK_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TICK_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `alarm_enable`"]
        pub type ALARM_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `alarm_enable`"]
        pub struct ALARM_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALARM_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `tick_int_mode`"]
        pub type TICK_INT_MODE_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `tick_int_mode`"]
        pub struct TICK_INT_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TICK_INT_MODE_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | (((value as u32) & 0x03) << 2);
                self.w
            }
        }
        #[doc = "Reader of field `alarm_compare_mask`"]
        pub type ALARM_COMPARE_MASK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `alarm_compare_mask`"]
        pub struct ALARM_COMPARE_MASK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALARM_COMPARE_MASK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 24)) | (((value as u32) & 0xff) << 24);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - TICK_ENABLE"]
            #[inline(always)]
            pub fn tick_enable(&self) -> TICK_ENABLE_R {
                TICK_ENABLE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - Alarm interrupt enable"]
            #[inline(always)]
            pub fn alarm_enable(&self) -> ALARM_ENABLE_R {
                ALARM_ENABLE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bits 2:3 - Tick interrupt enable"]
            #[inline(always)]
            pub fn tick_int_mode(&self) -> TICK_INT_MODE_R {
                TICK_INT_MODE_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            #[doc = "Bits 24:31 - Alarm compare mask for interrupt"]
            #[inline(always)]
            pub fn alarm_compare_mask(&self) -> ALARM_COMPARE_MASK_R {
                ALARM_COMPARE_MASK_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - TICK_ENABLE"]
            #[inline(always)]
            pub fn tick_enable(&mut self) -> TICK_ENABLE_W {
                TICK_ENABLE_W { w: self }
            }
            #[doc = "Bit 1 - Alarm interrupt enable"]
            #[inline(always)]
            pub fn alarm_enable(&mut self) -> ALARM_ENABLE_W {
                ALARM_ENABLE_W { w: self }
            }
            #[doc = "Bits 2:3 - Tick interrupt enable"]
            #[inline(always)]
            pub fn tick_int_mode(&mut self) -> TICK_INT_MODE_W {
                TICK_INT_MODE_W { w: self }
            }
            #[doc = "Bits 24:31 - Alarm compare mask for interrupt"]
            #[inline(always)]
            pub fn alarm_compare_mask(&mut self) -> ALARM_COMPARE_MASK_W {
                ALARM_COMPARE_MASK_W { w: self }
            }
        }
    }
    #[doc = "RTC register settings\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [register_ctrl](register_ctrl) module"]
    pub type REGISTER_CTRL = crate::Reg<u32, _REGISTER_CTRL>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _REGISTER_CTRL;
    #[doc = "`read()` method returns [register_ctrl::R](register_ctrl::R) reader structure"]
    impl crate::Readable for REGISTER_CTRL {}
    #[doc = "`write(|w| ..)` method takes [register_ctrl::W](register_ctrl::W) writer structure"]
    impl crate::Writable for REGISTER_CTRL {}
    #[doc = "RTC register settings"]
    pub mod register_ctrl {
        #[doc = "Reader of register register_ctrl"]
        pub type R = crate::R<u32, super::REGISTER_CTRL>;
        #[doc = "Writer for register register_ctrl"]
        pub type W = crate::W<u32, super::REGISTER_CTRL>;
        #[doc = "Register register_ctrl `reset()`'s with value 0"]
        impl crate::ResetValue for super::REGISTER_CTRL {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `read_enable`"]
        pub type READ_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `read_enable`"]
        pub struct READ_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> READ_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | ((value as u32) & 0x01);
                self.w
            }
        }
        #[doc = "Reader of field `write_enable`"]
        pub type WRITE_ENABLE_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `write_enable`"]
        pub struct WRITE_ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRITE_ENABLE_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | (((value as u32) & 0x01) << 1);
                self.w
            }
        }
        #[doc = "Reader of field `timer_mask`"]
        pub type TIMER_MASK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `timer_mask`"]
        pub struct TIMER_MASK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMER_MASK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 13)) | (((value as u32) & 0xff) << 13);
                self.w
            }
        }
        #[doc = "Reader of field `alarm_mask`"]
        pub type ALARM_MASK_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `alarm_mask`"]
        pub struct ALARM_MASK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALARM_MASK_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 21)) | (((value as u32) & 0xff) << 21);
                self.w
            }
        }
        #[doc = "Reader of field `initial_count_mask`"]
        pub type INITIAL_COUNT_MASK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `initial_count_mask`"]
        pub struct INITIAL_COUNT_MASK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INITIAL_COUNT_MASK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | (((value as u32) & 0x01) << 29);
                self.w
            }
        }
        #[doc = "Reader of field `interrupt_register_mask`"]
        pub type INTERRUPT_REGISTER_MASK_R = crate::R<bool, bool>;
        #[doc = "Write proxy for field `interrupt_register_mask`"]
        pub struct INTERRUPT_REGISTER_MASK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INTERRUPT_REGISTER_MASK_W<'a> {
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | (((value as u32) & 0x01) << 30);
                self.w
            }
        }
        impl R {
            #[doc = "Bit 0 - RTC timer read enable"]
            #[inline(always)]
            pub fn read_enable(&self) -> READ_ENABLE_R {
                READ_ENABLE_R::new((self.bits & 0x01) != 0)
            }
            #[doc = "Bit 1 - RTC timer write enable"]
            #[inline(always)]
            pub fn write_enable(&self) -> WRITE_ENABLE_R {
                WRITE_ENABLE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            #[doc = "Bits 13:20 - RTC timer mask"]
            #[inline(always)]
            pub fn timer_mask(&self) -> TIMER_MASK_R {
                TIMER_MASK_R::new(((self.bits >> 13) & 0xff) as u8)
            }
            #[doc = "Bits 21:28 - RTC alarm mask"]
            #[inline(always)]
            pub fn alarm_mask(&self) -> ALARM_MASK_R {
                ALARM_MASK_R::new(((self.bits >> 21) & 0xff) as u8)
            }
            #[doc = "Bit 29 - RTC counter initial count value mask"]
            #[inline(always)]
            pub fn initial_count_mask(&self) -> INITIAL_COUNT_MASK_R {
                INITIAL_COUNT_MASK_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            #[doc = "Bit 30 - RTC interrupt register mask"]
            #[inline(always)]
            pub fn interrupt_register_mask(&self) -> INTERRUPT_REGISTER_MASK_R {
                INTERRUPT_REGISTER_MASK_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RTC timer read enable"]
            #[inline(always)]
            pub fn read_enable(&mut self) -> READ_ENABLE_W {
                READ_ENABLE_W { w: self }
            }
            #[doc = "Bit 1 - RTC timer write enable"]
            #[inline(always)]
            pub fn write_enable(&mut self) -> WRITE_ENABLE_W {
                WRITE_ENABLE_W { w: self }
            }
            #[doc = "Bits 13:20 - RTC timer mask"]
            #[inline(always)]
            pub fn timer_mask(&mut self) -> TIMER_MASK_W {
                TIMER_MASK_W { w: self }
            }
            #[doc = "Bits 21:28 - RTC alarm mask"]
            #[inline(always)]
            pub fn alarm_mask(&mut self) -> ALARM_MASK_W {
                ALARM_MASK_W { w: self }
            }
            #[doc = "Bit 29 - RTC counter initial count value mask"]
            #[inline(always)]
            pub fn initial_count_mask(&mut self) -> INITIAL_COUNT_MASK_W {
                INITIAL_COUNT_MASK_W { w: self }
            }
            #[doc = "Bit 30 - RTC interrupt register mask"]
            #[inline(always)]
            pub fn interrupt_register_mask(&mut self) -> INTERRUPT_REGISTER_MASK_W {
                INTERRUPT_REGISTER_MASK_W { w: self }
            }
        }
    }
    #[doc = "Timer extended information\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [extended](extended) module"]
    pub type EXTENDED = crate::Reg<u32, _EXTENDED>;
    #[allow(missing_docs)]
    #[doc(hidden)]
    pub struct _EXTENDED;
    #[doc = "`read()` method returns [extended::R](extended::R) reader structure"]
    impl crate::Readable for EXTENDED {}
    #[doc = "`write(|w| ..)` method takes [extended::W](extended::W) writer structure"]
    impl crate::Writable for EXTENDED {}
    #[doc = "Timer extended information"]
    pub mod extended {
        #[doc = "Reader of register extended"]
        pub type R = crate::R<u32, super::EXTENDED>;
        #[doc = "Writer for register extended"]
        pub type W = crate::W<u32, super::EXTENDED>;
        #[doc = "Register extended `reset()`'s with value 0"]
        impl crate::ResetValue for super::EXTENDED {
            type Type = u32;
            #[inline(always)]
            fn reset_value() -> Self::Type {
                0
            }
        }
        #[doc = "Reader of field `century`"]
        pub type CENTURY_R = crate::R<u8, u8>;
        #[doc = "Write proxy for field `century`"]
        pub struct CENTURY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CENTURY_W<'a> {
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | ((value as u32) & 0x1f);
                self.w
            }
        }
        #[doc = "Is leap year. 1 is leap year, 0 is not leap year\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LEAP_YEAR_A {
            #[doc = "0: 0 is not leap year"]
            NOT_LEAP = 0,
            #[doc = "1: 1 is leap year"]
            LEAP = 1,
        }
        impl From<LEAP_YEAR_A> for bool {
            #[inline(always)]
            fn from(variant: LEAP_YEAR_A) -> Self {
                variant as u8 != 0
            }
        }
        #[doc = "Reader of field `leap_year`"]
        pub type LEAP_YEAR_R = crate::R<bool, LEAP_YEAR_A>;
        impl LEAP_YEAR_R {
            #[doc = r"Get enumerated values variant"]
            #[inline(always)]
            pub fn variant(&self) -> LEAP_YEAR_A {
                match self.bits {
                    false => LEAP_YEAR_A::NOT_LEAP,
                    true => LEAP_YEAR_A::LEAP,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_LEAP`"]
            #[inline(always)]
            pub fn is_not_leap(&self) -> bool {
                *self == LEAP_YEAR_A::NOT_LEAP
            }
            #[doc = "Checks if the value of the field is `LEAP`"]
            #[inline(always)]
            pub fn is_leap(&self) -> bool {
                *self == LEAP_YEAR_A::LEAP
            }
        }
        #[doc = "Write proxy for field `leap_year`"]
        pub struct LEAP_YEAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LEAP_YEAR_W<'a> {
            #[doc = r"Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LEAP_YEAR_A) -> &'a mut W {
                {
                    self.bit(variant.into())
                }
            }
            #[doc = "0 is not leap year"]
            #[inline(always)]
            pub fn not_leap(self) -> &'a mut W {
                self.variant(LEAP_YEAR_A::NOT_LEAP)
            }
            #[doc = "1 is leap year"]
            #[inline(always)]
            pub fn leap(self) -> &'a mut W {
                self.variant(LEAP_YEAR_A::LEAP)
            }
            #[doc = r"Sets the field bit"]
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r"Clears the field bit"]
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r"Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | (((value as u32) & 0x01) << 5);
                self.w
            }
        }
        impl R {
            #[doc = "Bits 0:4 - Century. Range \\[0,31\\]"]
            #[inline(always)]
            pub fn century(&self) -> CENTURY_R {
                CENTURY_R::new((self.bits & 0x1f) as u8)
            }
            #[doc = "Bit 5 - Is leap year. 1 is leap year, 0 is not leap year"]
            #[inline(always)]
            pub fn leap_year(&self) -> LEAP_YEAR_R {
                LEAP_YEAR_R::new(((self.bits >> 5) & 0x01) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - Century. Range \\[0,31\\]"]
            #[inline(always)]
            pub fn century(&mut self) -> CENTURY_W {
                CENTURY_W { w: self }
            }
            #[doc = "Bit 5 - Is leap year. 1 is leap year, 0 is not leap year"]
            #[inline(always)]
            pub fn leap_year(&mut self) -> LEAP_YEAR_W {
                LEAP_YEAR_W { w: self }
            }
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r"All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "CLINT"]
    pub CLINT: CLINT,
    #[doc = "PLIC"]
    pub PLIC: PLIC,
    #[doc = "UARTHS"]
    pub UARTHS: UARTHS,
    #[doc = "GPIOHS"]
    pub GPIOHS: GPIOHS,
    #[doc = "KPU"]
    pub KPU: KPU,
    #[doc = "FFT"]
    pub FFT: FFT,
    #[doc = "DMAC"]
    pub DMAC: DMAC,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
    #[doc = "UART1"]
    pub UART1: UART1,
    #[doc = "UART2"]
    pub UART2: UART2,
    #[doc = "UART3"]
    pub UART3: UART3,
    #[doc = "SPI0"]
    pub SPI0: SPI0,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "SPI2"]
    pub SPI2: SPI2,
    #[doc = "SPI3"]
    pub SPI3: SPI3,
    #[doc = "I2S0"]
    pub I2S0: I2S0,
    #[doc = "APU"]
    pub APU: APU,
    #[doc = "I2S1"]
    pub I2S1: I2S1,
    #[doc = "I2S2"]
    pub I2S2: I2S2,
    #[doc = "I2C0"]
    pub I2C0: I2C0,
    #[doc = "I2C1"]
    pub I2C1: I2C1,
    #[doc = "I2C2"]
    pub I2C2: I2C2,
    #[doc = "FPIOA"]
    pub FPIOA: FPIOA,
    #[doc = "SHA256"]
    pub SHA256: SHA256,
    #[doc = "TIMER0"]
    pub TIMER0: TIMER0,
    #[doc = "TIMER1"]
    pub TIMER1: TIMER1,
    #[doc = "TIMER2"]
    pub TIMER2: TIMER2,
    #[doc = "WDT0"]
    pub WDT0: WDT0,
    #[doc = "WDT1"]
    pub WDT1: WDT1,
    #[doc = "OTP"]
    pub OTP: OTP,
    #[doc = "DVP"]
    pub DVP: DVP,
    #[doc = "SYSCTL"]
    pub SYSCTL: SYSCTL,
    #[doc = "AES"]
    pub AES: AES,
    #[doc = "RTC"]
    pub RTC: RTC,
}
impl Peripherals {
    #[doc = r"Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        riscv::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
        //Some(unsafe { Peripherals::steal() })
    }
    #[doc = r"Unchecked version of `Peripherals::take`"]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            CLINT: CLINT {
                _marker: PhantomData,
            },
            PLIC: PLIC {
                _marker: PhantomData,
            },
            UARTHS: UARTHS {
                _marker: PhantomData,
            },
            GPIOHS: GPIOHS {
                _marker: PhantomData,
            },
            KPU: KPU {
                _marker: PhantomData,
            },
            FFT: FFT {
                _marker: PhantomData,
            },
            DMAC: DMAC {
                _marker: PhantomData,
            },
            GPIO: GPIO {
                _marker: PhantomData,
            },
            UART1: UART1 {
                _marker: PhantomData,
            },
            UART2: UART2 {
                _marker: PhantomData,
            },
            UART3: UART3 {
                _marker: PhantomData,
            },
            SPI0: SPI0 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            SPI3: SPI3 {
                _marker: PhantomData,
            },
            I2S0: I2S0 {
                _marker: PhantomData,
            },
            APU: APU {
                _marker: PhantomData,
            },
            I2S1: I2S1 {
                _marker: PhantomData,
            },
            I2S2: I2S2 {
                _marker: PhantomData,
            },
            I2C0: I2C0 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            FPIOA: FPIOA {
                _marker: PhantomData,
            },
            SHA256: SHA256 {
                _marker: PhantomData,
            },
            TIMER0: TIMER0 {
                _marker: PhantomData,
            },
            TIMER1: TIMER1 {
                _marker: PhantomData,
            },
            TIMER2: TIMER2 {
                _marker: PhantomData,
            },
            WDT0: WDT0 {
                _marker: PhantomData,
            },
            WDT1: WDT1 {
                _marker: PhantomData,
            },
            OTP: OTP {
                _marker: PhantomData,
            },
            DVP: DVP {
                _marker: PhantomData,
            },
            SYSCTL: SYSCTL {
                _marker: PhantomData,
            },
            AES: AES {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
        }
    }
}
