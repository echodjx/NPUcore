## 页表项部分特殊项

对于页表架构，页表项有一些特殊项在优化和换页LRU中会有帮助：

+ `A(Access)`：访问位，如果用户/内核有访问（访存、取指等）到页表项对应页，则该位硬件自动置位为1，内核可以主动将该位清零，并可以通过检查页表项该位判断用户/内核自上次清位是否访问过该页。
+ `D(Dirty)`：脏位，如果用户/内核有写入数据到页表项对应页，则该位硬件自动置位为1，内核可以主动将该位清零，并可以通过检查页表项该位判断用户/内核自上次清位是否写入数据到该页。

一般来说`A`位用作换页时的LRU，通过定时清位可以了解到用户对页的使用频度，这样能够做出更好的判断，而`D`位用作文件系统写回的优化方法，如果该页的`D`位未被置位，可以采取直接丢弃的策略不写回，因为数据是与文件中是一致的，这样能有效减少文件I/O。

## 页表项与tlb(快表)

页表项能够描述页面的情况，但是在`NPUCore`团队在实现相关功能时发现实际上并不能直接访问对应页表项。

原因是硬件为了访存能够高效，设计了tlb用于cache页表项，这就导致在访问页表项时，它的真实数据其实放在tlb里，并没有被及时写回，访存到的还是旧的数据，所以就需要使用汇编命令(对risc-v是`sfence.vma`)将tlb写回到内存中。

但是经过实践得出，fence指令并不能做到将tlb中的数据完全写回到内存中，通过在qemu上测试，以下操作会让数据无法写回（括号里写的是`D`位的置位情况）。

1. 选取一特定页，写入一些数据使得该页变为脏页（tlb：1，页表项：?）
2. 用`sfence.vma`汇编使tlb写回内存（tlb：无数据，页表项：1）
3. 写入一些数据到该页使得该页变为脏页（tlb：1，页表项：1）
4. 对该页内存中页表项脏位清零（tlb：1，页表项：0）
5. 用`sfence.vma`汇编使tlb写回内存（tlb：无数据，页表项：0）

在这种序列下tlb的数据是无法写回的，我们推测可能的原因是这样的：tlb里不仅维护页表项的当前位，在tlb失效需要从内存读入页表项时还保存着那个时候的备份，而当tlb要写回到内存时会将备份与目前内存中的页表项进行比较，如果一致将现维护的页表项写回，否则不写回。可能这个原因有误，如果有错及时指出，不胜感激。

那么如何让页表项正确写回，目前`NPUCore`采取一个保守的逻辑，如果要修改页表项（除了页表项有效位（valid）从0变成1，因为修改页表项时页表项肯定不会由tlb维护，对目标页访存肯定会触发tlb的cache miss）就在修改之前使用`sfence.vma`将tlb写回。
