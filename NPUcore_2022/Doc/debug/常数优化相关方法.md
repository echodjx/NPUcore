## with_capacity优化

一般正常情况下写程序写vector其实可能并不会在意，直接开一个空vector就直接操作了，但是vector在实现机理上是当数组满时新申请一个两倍长的数组，将老数组的数据拷贝过去，然后将老数组的内存释放。

正常拷贝的时间复杂度为O(n)，但是实际情况上并不如此，空间的申请释放需要经过buddysystem内存分配器，而内存释放分配时间消耗并不少，所以建议使用`with_capacity`，通过预分配一个比较合理的数组大小来减少释放分配的时间消耗常数。

## 平衡树和线性表

在做映射的时候，大部分人会用平衡树map(这里不推荐hashmap，这会导致哈希碰撞，并对内核变成并不会是件好事)，平衡树的时间复杂度是O(logn)，理论复杂度很优秀，但是在输入域大小小于20的情况(就是输入的情况最多不超过20种)，其实开一个线性表(数组)进行线性扫描并非是个劣解，尽管复杂度可能是O(n)级别，但是n很小的情况，可能数组的表现的常数要比平衡树小得多。

## 拷贝相关

正常情况下，可能`copy_from_slice`成为复制数组的首选。但是实际上rust因为安全性要对做相关的检查，所以如果能够保证操作正确无误，`copy_nonoverlapping`会让效率有些许提升。

前几天在观察`FTLOS`队提交时还看到一个更加震撼的，他们认为`copy_nonoverlapping`在复制一整页4096字节的时候还要一些检查还是太慢了，于是直接开始直接手工遍历复制，代码大概长这样：

```rust
//凭记忆记的，可能语法不标准
let mut src = src as *const u64
let mut dst = dst as *mut u64
for i in 0..64 {
    unsafe {
        *dst = *src;
        src = src.add(1);
        dst = dst.add(1);
    }
}
```

感觉这样还是挺有意思的，能够通过各种试验试出一些意想不到的表现，可能就是这个比赛给各个选手的意义了，不断尝试接触系统底层实践找出较优解，并不是上课讲理论。

## 总结

这个就是系统编程跟平常编程的差别了，平常编程一般只关心时间复杂度，而系统编程不仅关心时间复杂度，更关心其实际情况，实际上可能时间复杂度不太好的方法反而效率会更高一些，细小地方的实现效率会让整个系统效率有不俗的提升，通过研究这些"小"优化，也能帮助系统底层的学习。