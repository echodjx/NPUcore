## 问题发现

我们在适配完轻量化C编译器：tcc之后，打算写一个a+b。

然后奇怪的事情发生了，shell调用a+b程序后输入啥都没有回显，但是程序依旧正常运行，而且退出程序之后shell依然能够正常回显。

![](./assets/tty-no%20echo-1.png)

一般shell我们都默认了会将输入的字符打印，但是运行子程序之后我们任然想要像平时用的终端能够打印输入的数据，否则不知道自己是否输入正确的数据。

通过系统调用的调试追踪可以发现，bash会调用`writev`系统调用用于回显输入的字符，而我们编译的小程序并没有调用`writev`，甚至没有调用任何write相关的系统调用。

## 问题原因

我们在网上查询相关资料后发现，tty的控制是通过`ioctl`系统调用进行查询修改`termio`结构体，里面有一个`lmode`变量，描述终端的相关状态，里面一个`ECHO`参数代表了是否需要内核对输入回显。

这个参数在linux上可以bash通过stty进行控制，这样就能决定输入是否回显：

![](./assets/tty-no%20echo-2.png)


在追踪过程中，发现bash在刚开始加载的时候将ECHO清位，在调用程序的时候会将ECHO先短暂复位，将主动权交给子进程，这个时候ECHO置位了就理应由内核决定是否将输入的字符打印，在子进程结束之后bash在进行复位，将ECHO清位。

## 问题解决

在TTY输入的时候加入小段代码用户回显输入的字符：

```rust
if inner.termios.lflag & LocalModes::ECHO.bits() != 0 {
    if inner.last_char == '\r' as u8 {
        print!("\n");
    } else {
        print!("{}", inner.last_char as char);
    }
}
```

需要注意的是用户输入的回车一般是`\r`而不是平常意义的`\n`换行符，所以需要稍加处理，可能还有很多要处理，不过这些暂时就够了。

这样就能正确将输入回显。

![](./assets/tty-no%20echo-3.png)